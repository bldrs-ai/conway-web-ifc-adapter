/* eslint-disable */
'use strict'
exports.__esModule = true
exports.IfcLanguageId = exports.IfcLabel = exports.IfcKinematicViscosityMeasure = exports.IfcIsothermalMoistureCapacityMeasure = exports.IfcIonConcentrationMeasure = exports.IfcIntegerCountRateMeasure = exports.IfcInteger = exports.IfcInductanceMeasure = exports.IfcIlluminanceMeasure = exports.IfcIdentifier = exports.IfcHeatingValueMeasure = exports.IfcHeatFluxDensityMeasure = exports.IfcGloballyUniqueId = exports.IfcFrequencyMeasure = exports.IfcForceMeasure = exports.IfcFontWeight = exports.IfcFontVariant = exports.IfcFontStyle = exports.IfcEnergyMeasure = exports.IfcElectricVoltageMeasure = exports.IfcElectricResistanceMeasure = exports.IfcElectricCurrentMeasure = exports.IfcElectricConductanceMeasure = exports.IfcElectricChargeMeasure = exports.IfcElectricCapacitanceMeasure = exports.IfcDynamicViscosityMeasure = exports.IfcDuration = exports.IfcDoseEquivalentMeasure = exports.IfcDimensionCount = exports.IfcDescriptiveMeasure = exports.IfcDayInWeekNumber = exports.IfcDayInMonthNumber = exports.IfcDateTime = exports.IfcDate = exports.IfcCurvatureMeasure = exports.IfcCountMeasure = exports.IfcContextDependentMeasure = exports.IfcCardinalPointReference = exports.IfcBoxAlignment = exports.IfcBoolean = exports.IfcBinary = exports.IfcAreaMeasure = exports.IfcAreaDensityMeasure = exports.IfcAngularVelocityMeasure = exports.IfcAmountOfSubstanceMeasure = exports.IfcAccelerationMeasure = exports.IfcAbsorbedDoseMeasure = exports.Value = exports.Write = exports.FromRawLineData = void 0
exports.IfcSoundPowerMeasure = exports.IfcSoundPowerLevelMeasure = exports.IfcSolidAngleMeasure = exports.IfcShearModulusMeasure = exports.IfcSectionalAreaIntegralMeasure = exports.IfcSectionModulusMeasure = exports.IfcRotationalStiffnessMeasure = exports.IfcRotationalMassMeasure = exports.IfcRotationalFrequencyMeasure = exports.IfcReal = exports.IfcRatioMeasure = exports.IfcRadioActivityMeasure = exports.IfcPressureMeasure = exports.IfcPresentableText = exports.IfcPowerMeasure = exports.IfcPositiveRatioMeasure = exports.IfcPositivePlaneAngleMeasure = exports.IfcPositiveLengthMeasure = exports.IfcPositiveInteger = exports.IfcPlaneAngleMeasure = exports.IfcPlanarForceMeasure = exports.IfcParameterValue = exports.IfcPHMeasure = exports.IfcNumericMeasure = exports.IfcNormalisedRatioMeasure = exports.IfcNonNegativeLengthMeasure = exports.IfcMonthInYearNumber = exports.IfcMonetaryMeasure = exports.IfcMomentOfInertiaMeasure = exports.IfcMolecularWeightMeasure = exports.IfcMoistureDiffusivityMeasure = exports.IfcModulusOfSubgradeReactionMeasure = exports.IfcModulusOfRotationalSubgradeReactionMeasure = exports.IfcModulusOfLinearSubgradeReactionMeasure = exports.IfcModulusOfElasticityMeasure = exports.IfcMassPerLengthMeasure = exports.IfcMassMeasure = exports.IfcMassFlowRateMeasure = exports.IfcMassDensityMeasure = exports.IfcMagneticFluxMeasure = exports.IfcMagneticFluxDensityMeasure = exports.IfcLuminousIntensityMeasure = exports.IfcLuminousIntensityDistributionMeasure = exports.IfcLuminousFluxMeasure = exports.IfcLogical = exports.IfcLinearVelocityMeasure = exports.IfcLinearStiffnessMeasure = exports.IfcLinearMomentMeasure = exports.IfcLinearForceMeasure = exports.IfcLengthMeasure = void 0
exports.IfcBoilerTypeEnum = exports.IfcBenchmarkEnum = exports.IfcBearingTypeEnum = exports.IfcBearingTypeDisplacementEnum = exports.IfcBeamTypeEnum = exports.IfcBSplineSurfaceForm = exports.IfcBSplineCurveForm = exports.IfcAudioVisualApplianceTypeEnum = exports.IfcAssemblyPlaceEnum = exports.IfcArithmeticOperatorEnum = exports.IfcAnalysisTheoryTypeEnum = exports.IfcAnalysisModelTypeEnum = exports.IfcAlignmentTypeEnum = exports.IfcAlarmTypeEnum = exports.IfcAirToAirHeatRecoveryTypeEnum = exports.IfcAirTerminalTypeEnum = exports.IfcAirTerminalBoxTypeEnum = exports.IfcAddressTypeEnum = exports.IfcActuatorTypeEnum = exports.IfcActionTypeEnum = exports.IfcActionSourceTypeEnum = exports.IfcActionRequestTypeEnum = exports.IfcWarpingMomentMeasure = exports.IfcWarpingConstantMeasure = exports.IfcVolumetricFlowRateMeasure = exports.IfcVolumeMeasure = exports.IfcVaporPermeabilityMeasure = exports.IfcURIReference = exports.IfcTorqueMeasure = exports.IfcTimeStamp = exports.IfcTimeMeasure = exports.IfcTime = exports.IfcThermodynamicTemperatureMeasure = exports.IfcThermalTransmittanceMeasure = exports.IfcThermalResistanceMeasure = exports.IfcThermalExpansionCoefficientMeasure = exports.IfcThermalConductivityMeasure = exports.IfcThermalAdmittanceMeasure = exports.IfcTextTransformation = exports.IfcTextFontName = exports.IfcTextDecoration = exports.IfcTextAlignment = exports.IfcText = exports.IfcTemperatureRateOfChangeMeasure = exports.IfcTemperatureGradientMeasure = exports.IfcSpecularRoughness = exports.IfcSpecularExponent = exports.IfcSpecificHeatCapacityMeasure = exports.IfcSoundPressureMeasure = exports.IfcSoundPressureLevelMeasure = void 0
exports.IfcDoorTypeEnum = exports.IfcDoorStyleOperationEnum = exports.IfcDoorStyleConstructionEnum = exports.IfcDoorPanelPositionEnum = exports.IfcDoorPanelOperationEnum = exports.IfcDocumentStatusEnum = exports.IfcDocumentConfidentialityEnum = exports.IfcDistributionSystemEnum = exports.IfcDistributionPortTypeEnum = exports.IfcDistributionChamberElementTypeEnum = exports.IfcDiscreteAccessoryTypeEnum = exports.IfcDirectionSenseEnum = exports.IfcDerivedUnitEnum = exports.IfcDataOriginEnum = exports.IfcDamperTypeEnum = exports.IfcCurveInterpolationEnum = exports.IfcCurtainWallTypeEnum = exports.IfcCrewResourceTypeEnum = exports.IfcCoveringTypeEnum = exports.IfcCostScheduleTypeEnum = exports.IfcCostItemTypeEnum = exports.IfcCoolingTowerTypeEnum = exports.IfcCooledBeamTypeEnum = exports.IfcControllerTypeEnum = exports.IfcConstructionProductResourceTypeEnum = exports.IfcConstructionMaterialResourceTypeEnum = exports.IfcConstructionEquipmentResourceTypeEnum = exports.IfcConstraintEnum = exports.IfcConnectionTypeEnum = exports.IfcCondenserTypeEnum = exports.IfcCompressorTypeEnum = exports.IfcComplexPropertyTemplateTypeEnum = exports.IfcCommunicationsApplianceTypeEnum = exports.IfcColumnTypeEnum = exports.IfcCoilTypeEnum = exports.IfcChimneyTypeEnum = exports.IfcChillerTypeEnum = exports.IfcChangeActionEnum = exports.IfcCaissonFoundationTypeEnum = exports.IfcCableSegmentTypeEnum = exports.IfcCableFittingTypeEnum = exports.IfcCableCarrierSegmentTypeEnum = exports.IfcCableCarrierFittingTypeEnum = exports.IfcBurnerTypeEnum = exports.IfcBuildingSystemTypeEnum = exports.IfcBuildingElementProxyTypeEnum = exports.IfcBuildingElementPartTypeEnum = exports.IfcBridgeTypeEnum = exports.IfcBridgePartTypeEnum = exports.IfcBooleanOperator = void 0
exports.IfcMotorConnectionTypeEnum = exports.IfcMemberTypeEnum = exports.IfcMedicalDeviceTypeEnum = exports.IfcMechanicalFastenerTypeEnum = exports.IfcLogicalOperatorEnum = exports.IfcLoadGroupTypeEnum = exports.IfcLightFixtureTypeEnum = exports.IfcLightEmissionSourceEnum = exports.IfcLightDistributionCurveEnum = exports.IfcLayerSetDirectionEnum = exports.IfcLampTypeEnum = exports.IfcLaborResourceTypeEnum = exports.IfcKnotType = exports.IfcJunctionBoxTypeEnum = exports.IfcInventoryTypeEnum = exports.IfcInternalOrExternalEnum = exports.IfcInterceptorTypeEnum = exports.IfcHumidifierTypeEnum = exports.IfcHeatExchangerTypeEnum = exports.IfcGridTypeEnum = exports.IfcGlobalOrLocalEnum = exports.IfcGeometricProjectionEnum = exports.IfcGeographicElementTypeEnum = exports.IfcFurnitureTypeEnum = exports.IfcFootingTypeEnum = exports.IfcFlowMeterTypeEnum = exports.IfcFlowInstrumentTypeEnum = exports.IfcFlowDirectionEnum = exports.IfcFireSuppressionTerminalTypeEnum = exports.IfcFilterTypeEnum = exports.IfcFastenerTypeEnum = exports.IfcFanTypeEnum = exports.IfcExternalSpatialElementTypeEnum = exports.IfcEventTypeEnum = exports.IfcEventTriggerTypeEnum = exports.IfcEvaporatorTypeEnum = exports.IfcEvaporativeCoolerTypeEnum = exports.IfcEngineTypeEnum = exports.IfcElementCompositionEnum = exports.IfcElementAssemblyTypeEnum = exports.IfcElectricTimeControlTypeEnum = exports.IfcElectricMotorTypeEnum = exports.IfcElectricGeneratorTypeEnum = exports.IfcElectricFlowStorageDeviceTypeEnum = exports.IfcElectricDistributionBoardTypeEnum = exports.IfcElectricApplianceTypeEnum = exports.IfcDuctSilencerTypeEnum = exports.IfcDuctSegmentTypeEnum = exports.IfcDuctFittingTypeEnum = exports.IfcDoorTypeOperationEnum = void 0
exports.IfcSpatialZoneTypeEnum = exports.IfcSpaceTypeEnum = exports.IfcSpaceHeaterTypeEnum = exports.IfcSolarDeviceTypeEnum = exports.IfcSlabTypeEnum = exports.IfcSimplePropertyTemplateTypeEnum = exports.IfcShadingDeviceTypeEnum = exports.IfcSequenceEnum = exports.IfcSensorTypeEnum = exports.IfcSectionTypeEnum = exports.IfcSanitaryTerminalTypeEnum = exports.IfcSIUnitName = exports.IfcSIPrefix = exports.IfcRoofTypeEnum = exports.IfcRoleEnum = exports.IfcReinforcingMeshTypeEnum = exports.IfcReinforcingBarTypeEnum = exports.IfcReinforcingBarSurfaceEnum = exports.IfcReinforcingBarRoleEnum = exports.IfcReflectanceMethodEnum = exports.IfcReferentTypeEnum = exports.IfcRecurrenceTypeEnum = exports.IfcRampTypeEnum = exports.IfcRampFlightTypeEnum = exports.IfcRailingTypeEnum = exports.IfcPumpTypeEnum = exports.IfcProtectiveDeviceTypeEnum = exports.IfcProtectiveDeviceTrippingUnitTypeEnum = exports.IfcPropertySetTemplateTypeEnum = exports.IfcProjectionElementTypeEnum = exports.IfcProjectedOrTrueLengthEnum = exports.IfcProjectOrderTypeEnum = exports.IfcProfileTypeEnum = exports.IfcProcedureTypeEnum = exports.IfcPreferredSurfaceCurveRepresentation = exports.IfcPlateTypeEnum = exports.IfcPipeSegmentTypeEnum = exports.IfcPipeFittingTypeEnum = exports.IfcPileTypeEnum = exports.IfcPileConstructionEnum = exports.IfcPhysicalOrVirtualEnum = exports.IfcPermitTypeEnum = exports.IfcPermeableCoveringOperationEnum = exports.IfcPerformanceHistoryTypeEnum = exports.IfcOutletTypeEnum = exports.IfcOpeningElementTypeEnum = exports.IfcOccupantTypeEnum = exports.IfcObjectiveEnum = exports.IfcObjectTypeEnum = exports.IfcNullStyle = void 0
exports.IfcActuatorType = exports.IfcActuator = exports.IfcActorRole = exports.IfcActor = exports.IfcActionRequest = exports.IfcWorkScheduleTypeEnum = exports.IfcWorkPlanTypeEnum = exports.IfcWorkCalendarTypeEnum = exports.IfcWindowTypePartitioningEnum = exports.IfcWindowTypeEnum = exports.IfcWindowStyleOperationEnum = exports.IfcWindowStyleConstructionEnum = exports.IfcWindowPanelPositionEnum = exports.IfcWindowPanelOperationEnum = exports.IfcWasteTerminalTypeEnum = exports.IfcWallTypeEnum = exports.IfcVoidingFeatureTypeEnum = exports.IfcVibrationIsolatorTypeEnum = exports.IfcVibrationDamperTypeEnum = exports.IfcValveTypeEnum = exports.IfcUnitaryEquipmentTypeEnum = exports.IfcUnitaryControlElementTypeEnum = exports.IfcUnitEnum = exports.IfcTubeBundleTypeEnum = exports.IfcTrimmingPreference = exports.IfcTransportElementTypeEnum = exports.IfcTransitionCurveType = exports.IfcTransitionCode = exports.IfcTransformerTypeEnum = exports.IfcTimeSeriesDataTypeEnum = exports.IfcTextPath = exports.IfcTendonTypeEnum = exports.IfcTendonConduitTypeEnum = exports.IfcTendonAnchorTypeEnum = exports.IfcTaskTypeEnum = exports.IfcTaskDurationEnum = exports.IfcTankTypeEnum = exports.IfcSystemFurnitureElementTypeEnum = exports.IfcSwitchingDeviceTypeEnum = exports.IfcSurfaceSide = exports.IfcSurfaceFeatureTypeEnum = exports.IfcSubContractResourceTypeEnum = exports.IfcStructuralSurfaceMemberTypeEnum = exports.IfcStructuralSurfaceActivityTypeEnum = exports.IfcStructuralCurveMemberTypeEnum = exports.IfcStructuralCurveActivityTypeEnum = exports.IfcStateEnum = exports.IfcStairTypeEnum = exports.IfcStairFlightTypeEnum = exports.IfcStackTerminalTypeEnum = void 0
exports.IfcBoiler = exports.IfcBlock = exports.IfcBlobTexture = exports.IfcBearingType = exports.IfcBearing = exports.IfcBeamType = exports.IfcBeamStandardCase = exports.IfcBeam = exports.IfcBSplineSurfaceWithKnots = exports.IfcBSplineSurface = exports.IfcBSplineCurveWithKnots = exports.IfcBSplineCurve = exports.IfcAxis2Placement3D = exports.IfcAxis2Placement2D = exports.IfcAxis1Placement = exports.IfcAudioVisualApplianceType = exports.IfcAudioVisualAppliance = exports.IfcAsymmetricIShapeProfileDef = exports.IfcAsset = exports.IfcArbitraryProfileDefWithVoids = exports.IfcArbitraryOpenProfileDef = exports.IfcArbitraryClosedProfileDef = exports.IfcApprovalRelationship = exports.IfcApproval = exports.IfcAppliedValue = exports.IfcApplication = exports.IfcAnnotationFillArea = exports.IfcAnnotation = exports.IfcAlignmentCurve = exports.IfcAlignment2DVerticalSegment = exports.IfcAlignment2DVertical = exports.IfcAlignment2DVerSegParabolicArc = exports.IfcAlignment2DVerSegLine = exports.IfcAlignment2DVerSegCircularArc = exports.IfcAlignment2DSegment = exports.IfcAlignment2DHorizontalSegment = exports.IfcAlignment2DHorizontal = exports.IfcAlignment = exports.IfcAlarmType = exports.IfcAlarm = exports.IfcAirToAirHeatRecoveryType = exports.IfcAirToAirHeatRecovery = exports.IfcAirTerminalType = exports.IfcAirTerminalBoxType = exports.IfcAirTerminalBox = exports.IfcAirTerminal = exports.IfcAdvancedFace = exports.IfcAdvancedBrepWithVoids = exports.IfcAdvancedBrep = exports.IfcAddress = void 0
exports.IfcChimney = exports.IfcChillerType = exports.IfcChiller = exports.IfcCenterLineProfileDef = exports.IfcCartesianTransformationOperator3DnonUniform = exports.IfcCartesianTransformationOperator3D = exports.IfcCartesianTransformationOperator2DnonUniform = exports.IfcCartesianTransformationOperator2D = exports.IfcCartesianTransformationOperator = exports.IfcCartesianPointList3D = exports.IfcCartesianPointList2D = exports.IfcCartesianPointList = exports.IfcCartesianPoint = exports.IfcCaissonFoundationType = exports.IfcCaissonFoundation = exports.IfcCableSegmentType = exports.IfcCableSegment = exports.IfcCableFittingType = exports.IfcCableFitting = exports.IfcCableCarrierSegmentType = exports.IfcCableCarrierSegment = exports.IfcCableCarrierFittingType = exports.IfcCableCarrierFitting = exports.IfcCShapeProfileDef = exports.IfcBurnerType = exports.IfcBurner = exports.IfcBuildingSystem = exports.IfcBuildingStorey = exports.IfcBuildingElementType = exports.IfcBuildingElementProxyType = exports.IfcBuildingElementProxy = exports.IfcBuildingElementPartType = exports.IfcBuildingElementPart = exports.IfcBuildingElement = exports.IfcBuilding = exports.IfcBridgePart = exports.IfcBridge = exports.IfcBoxedHalfSpace = exports.IfcBoundingBox = exports.IfcBoundedSurface = exports.IfcBoundedCurve = exports.IfcBoundaryNodeConditionWarping = exports.IfcBoundaryNodeCondition = exports.IfcBoundaryFaceCondition = exports.IfcBoundaryEdgeCondition = exports.IfcBoundaryCurve = exports.IfcBoundaryCondition = exports.IfcBooleanResult = exports.IfcBooleanClippingResult = exports.IfcBoilerType = void 0
exports.IfcControl = exports.IfcContextDependentUnit = exports.IfcContext = exports.IfcConstructionResourceType = exports.IfcConstructionResource = exports.IfcConstructionProductResourceType = exports.IfcConstructionProductResource = exports.IfcConstructionMaterialResourceType = exports.IfcConstructionMaterialResource = exports.IfcConstructionEquipmentResourceType = exports.IfcConstructionEquipmentResource = exports.IfcConstraint = exports.IfcConnectionVolumeGeometry = exports.IfcConnectionSurfaceGeometry = exports.IfcConnectionPointGeometry = exports.IfcConnectionPointEccentricity = exports.IfcConnectionGeometry = exports.IfcConnectionCurveGeometry = exports.IfcConnectedFaceSet = exports.IfcConic = exports.IfcCondenserType = exports.IfcCondenser = exports.IfcCompressorType = exports.IfcCompressor = exports.IfcCompositeProfileDef = exports.IfcCompositeCurveSegment = exports.IfcCompositeCurveOnSurface = exports.IfcCompositeCurve = exports.IfcComplexPropertyTemplate = exports.IfcComplexProperty = exports.IfcCommunicationsApplianceType = exports.IfcCommunicationsAppliance = exports.IfcColumnType = exports.IfcColumnStandardCase = exports.IfcColumn = exports.IfcColourSpecification = exports.IfcColourRgbList = exports.IfcColourRgb = exports.IfcCoilType = exports.IfcCoil = exports.IfcClosedShell = exports.IfcClassificationReference = exports.IfcClassification = exports.IfcCivilElementType = exports.IfcCivilElement = exports.IfcCircularArcSegment2D = exports.IfcCircleProfileDef = exports.IfcCircleHollowProfileDef = exports.IfcCircle = exports.IfcChimneyType = void 0
exports.IfcDistributionElementType = exports.IfcDistributionElement = exports.IfcDistributionControlElementType = exports.IfcDistributionControlElement = exports.IfcDistributionCircuit = exports.IfcDistributionChamberElementType = exports.IfcDistributionChamberElement = exports.IfcDistanceExpression = exports.IfcDiscreteAccessoryType = exports.IfcDiscreteAccessory = exports.IfcDirection = exports.IfcDimensionalExponents = exports.IfcDerivedUnitElement = exports.IfcDerivedUnit = exports.IfcDerivedProfileDef = exports.IfcDeepFoundationType = exports.IfcDeepFoundation = exports.IfcDamperType = exports.IfcDamper = exports.IfcCylindricalSurface = exports.IfcCurveStyleFontPattern = exports.IfcCurveStyleFontAndScaling = exports.IfcCurveStyleFont = exports.IfcCurveStyle = exports.IfcCurveSegment2D = exports.IfcCurveBoundedSurface = exports.IfcCurveBoundedPlane = exports.IfcCurve = exports.IfcCurtainWallType = exports.IfcCurtainWall = exports.IfcCurrencyRelationship = exports.IfcCsgSolid = exports.IfcCsgPrimitive3D = exports.IfcCrewResourceType = exports.IfcCrewResource = exports.IfcCoveringType = exports.IfcCovering = exports.IfcCostValue = exports.IfcCostSchedule = exports.IfcCostItem = exports.IfcCoordinateReferenceSystem = exports.IfcCoordinateOperation = exports.IfcCoolingTowerType = exports.IfcCoolingTower = exports.IfcCooledBeamType = exports.IfcCooledBeam = exports.IfcConversionBasedUnitWithOffset = exports.IfcConversionBasedUnit = exports.IfcControllerType = exports.IfcController = void 0
exports.IfcEngineType = exports.IfcEngine = exports.IfcEnergyConversionDeviceType = exports.IfcEnergyConversionDevice = exports.IfcEllipseProfileDef = exports.IfcEllipse = exports.IfcElementarySurface = exports.IfcElementType = exports.IfcElementQuantity = exports.IfcElementComponentType = exports.IfcElementComponent = exports.IfcElementAssemblyType = exports.IfcElementAssembly = exports.IfcElement = exports.IfcElectricTimeControlType = exports.IfcElectricTimeControl = exports.IfcElectricMotorType = exports.IfcElectricMotor = exports.IfcElectricGeneratorType = exports.IfcElectricGenerator = exports.IfcElectricFlowStorageDeviceType = exports.IfcElectricFlowStorageDevice = exports.IfcElectricDistributionBoardType = exports.IfcElectricDistributionBoard = exports.IfcElectricApplianceType = exports.IfcElectricAppliance = exports.IfcEdgeLoop = exports.IfcEdgeCurve = exports.IfcEdge = exports.IfcDuctSilencerType = exports.IfcDuctSilencer = exports.IfcDuctSegmentType = exports.IfcDuctSegment = exports.IfcDuctFittingType = exports.IfcDuctFitting = exports.IfcDraughtingPreDefinedCurveFont = exports.IfcDraughtingPreDefinedColour = exports.IfcDoorType = exports.IfcDoorStyle = exports.IfcDoorStandardCase = exports.IfcDoorPanelProperties = exports.IfcDoorLiningProperties = exports.IfcDoor = exports.IfcDocumentReference = exports.IfcDocumentInformationRelationship = exports.IfcDocumentInformation = exports.IfcDistributionSystem = exports.IfcDistributionPort = exports.IfcDistributionFlowElementType = exports.IfcDistributionFlowElement = void 0
exports.IfcFlowMeter = exports.IfcFlowInstrumentType = exports.IfcFlowInstrument = exports.IfcFlowFittingType = exports.IfcFlowFitting = exports.IfcFlowControllerType = exports.IfcFlowController = exports.IfcFixedReferenceSweptAreaSolid = exports.IfcFireSuppressionTerminalType = exports.IfcFireSuppressionTerminal = exports.IfcFilterType = exports.IfcFilter = exports.IfcFillAreaStyleTiles = exports.IfcFillAreaStyleHatching = exports.IfcFillAreaStyle = exports.IfcFeatureElementSubtraction = exports.IfcFeatureElementAddition = exports.IfcFeatureElement = exports.IfcFastenerType = exports.IfcFastener = exports.IfcFanType = exports.IfcFan = exports.IfcFailureConnectionCondition = exports.IfcFacilityPart = exports.IfcFacility = exports.IfcFacetedBrepWithVoids = exports.IfcFacetedBrep = exports.IfcFaceSurface = exports.IfcFaceOuterBound = exports.IfcFaceBound = exports.IfcFaceBasedSurfaceModel = exports.IfcFace = exports.IfcExtrudedAreaSolidTapered = exports.IfcExtrudedAreaSolid = exports.IfcExternallyDefinedTextFont = exports.IfcExternallyDefinedSurfaceStyle = exports.IfcExternallyDefinedHatchStyle = exports.IfcExternalSpatialStructureElement = exports.IfcExternalSpatialElement = exports.IfcExternalReferenceRelationship = exports.IfcExternalReference = exports.IfcExternalInformation = exports.IfcExtendedProperties = exports.IfcEventType = exports.IfcEventTime = exports.IfcEvent = exports.IfcEvaporatorType = exports.IfcEvaporator = exports.IfcEvaporativeCoolerType = exports.IfcEvaporativeCooler = void 0
exports.IfcLShapeProfileDef = exports.IfcJunctionBoxType = exports.IfcJunctionBox = exports.IfcIrregularTimeSeriesValue = exports.IfcIrregularTimeSeries = exports.IfcInventory = exports.IfcIntersectionCurve = exports.IfcInterceptorType = exports.IfcInterceptor = exports.IfcIndexedTriangleTextureMap = exports.IfcIndexedTextureMap = exports.IfcIndexedPolygonalFaceWithVoids = exports.IfcIndexedPolygonalFace = exports.IfcIndexedPolyCurve = exports.IfcIndexedColourMap = exports.IfcImageTexture = exports.IfcIShapeProfileDef = exports.IfcHumidifierType = exports.IfcHumidifier = exports.IfcHeatExchangerType = exports.IfcHeatExchanger = exports.IfcHalfSpaceSolid = exports.IfcGroup = exports.IfcGridPlacement = exports.IfcGridAxis = exports.IfcGrid = exports.IfcGeometricSet = exports.IfcGeometricRepresentationSubContext = exports.IfcGeometricRepresentationItem = exports.IfcGeometricRepresentationContext = exports.IfcGeometricCurveSet = exports.IfcGeographicElementType = exports.IfcGeographicElement = exports.IfcFurnitureType = exports.IfcFurniture = exports.IfcFurnishingElementType = exports.IfcFurnishingElement = exports.IfcFootingType = exports.IfcFooting = exports.IfcFlowTreatmentDeviceType = exports.IfcFlowTreatmentDevice = exports.IfcFlowTerminalType = exports.IfcFlowTerminal = exports.IfcFlowStorageDeviceType = exports.IfcFlowStorageDevice = exports.IfcFlowSegmentType = exports.IfcFlowSegment = exports.IfcFlowMovingDeviceType = exports.IfcFlowMovingDevice = exports.IfcFlowMeterType = void 0
exports.IfcMedicalDeviceType = exports.IfcMedicalDevice = exports.IfcMechanicalFastenerType = exports.IfcMechanicalFastener = exports.IfcMeasureWithUnit = exports.IfcMaterialUsageDefinition = exports.IfcMaterialRelationship = exports.IfcMaterialProperties = exports.IfcMaterialProfileWithOffsets = exports.IfcMaterialProfileSetUsageTapering = exports.IfcMaterialProfileSetUsage = exports.IfcMaterialProfileSet = exports.IfcMaterialProfile = exports.IfcMaterialList = exports.IfcMaterialLayerWithOffsets = exports.IfcMaterialLayerSetUsage = exports.IfcMaterialLayerSet = exports.IfcMaterialLayer = exports.IfcMaterialDefinitionRepresentation = exports.IfcMaterialDefinition = exports.IfcMaterialConstituentSet = exports.IfcMaterialConstituent = exports.IfcMaterialClassificationRelationship = exports.IfcMaterial = exports.IfcMappedItem = exports.IfcMapConversion = exports.IfcManifoldSolidBrep = exports.IfcLoop = exports.IfcLocalPlacement = exports.IfcLinearPositioningElement = exports.IfcLinearPlacement = exports.IfcLineSegment2D = exports.IfcLine = exports.IfcLightSourceSpot = exports.IfcLightSourcePositional = exports.IfcLightSourceGoniometric = exports.IfcLightSourceDirectional = exports.IfcLightSourceAmbient = exports.IfcLightSource = exports.IfcLightIntensityDistribution = exports.IfcLightFixtureType = exports.IfcLightFixture = exports.IfcLightDistributionData = exports.IfcLibraryReference = exports.IfcLibraryInformation = exports.IfcLampType = exports.IfcLamp = exports.IfcLagTime = exports.IfcLaborResourceType = exports.IfcLaborResource = void 0
exports.IfcPlanarExtent = exports.IfcPlanarBox = exports.IfcPlacement = exports.IfcPixelTexture = exports.IfcPipeSegmentType = exports.IfcPipeSegment = exports.IfcPipeFittingType = exports.IfcPipeFitting = exports.IfcPileType = exports.IfcPile = exports.IfcPhysicalSimpleQuantity = exports.IfcPhysicalQuantity = exports.IfcPhysicalComplexQuantity = exports.IfcPersonAndOrganization = exports.IfcPerson = exports.IfcPermit = exports.IfcPermeableCoveringProperties = exports.IfcPerformanceHistory = exports.IfcPcurve = exports.IfcPath = exports.IfcParameterizedProfileDef = exports.IfcOwnerHistory = exports.IfcOutletType = exports.IfcOutlet = exports.IfcOuterBoundaryCurve = exports.IfcOrientedEdge = exports.IfcOrientationExpression = exports.IfcOrganizationRelationship = exports.IfcOrganization = exports.IfcOpeningStandardCase = exports.IfcOpeningElement = exports.IfcOpenShell = exports.IfcOffsetCurveByDistances = exports.IfcOffsetCurve3D = exports.IfcOffsetCurve2D = exports.IfcOffsetCurve = exports.IfcOccupant = exports.IfcObjective = exports.IfcObjectPlacement = exports.IfcObjectDefinition = exports.IfcObject = exports.IfcNamedUnit = exports.IfcMotorConnectionType = exports.IfcMotorConnection = exports.IfcMonetaryUnit = exports.IfcMirroredProfileDef = exports.IfcMetric = exports.IfcMemberType = exports.IfcMemberStandardCase = exports.IfcMember = void 0
exports.IfcPropertySetTemplate = exports.IfcPropertySetDefinition = exports.IfcPropertySet = exports.IfcPropertyReferenceValue = exports.IfcPropertyListValue = exports.IfcPropertyEnumeration = exports.IfcPropertyEnumeratedValue = exports.IfcPropertyDependencyRelationship = exports.IfcPropertyDefinition = exports.IfcPropertyBoundedValue = exports.IfcPropertyAbstraction = exports.IfcProperty = exports.IfcProjectionElement = exports.IfcProjectedCRS = exports.IfcProjectOrder = exports.IfcProjectLibrary = exports.IfcProject = exports.IfcProfileProperties = exports.IfcProfileDef = exports.IfcProductRepresentation = exports.IfcProductDefinitionShape = exports.IfcProduct = exports.IfcProcess = exports.IfcProcedureType = exports.IfcProcedure = exports.IfcPresentationStyleAssignment = exports.IfcPresentationStyle = exports.IfcPresentationLayerWithStyle = exports.IfcPresentationLayerAssignment = exports.IfcPresentationItem = exports.IfcPreDefinedTextFont = exports.IfcPreDefinedPropertySet = exports.IfcPreDefinedProperties = exports.IfcPreDefinedItem = exports.IfcPreDefinedCurveFont = exports.IfcPreDefinedColour = exports.IfcPostalAddress = exports.IfcPositioningElement = exports.IfcPort = exports.IfcPolyline = exports.IfcPolygonalFaceSet = exports.IfcPolygonalBoundedHalfSpace = exports.IfcPolyLoop = exports.IfcPointOnSurface = exports.IfcPointOnCurve = exports.IfcPoint = exports.IfcPlateType = exports.IfcPlateStandardCase = exports.IfcPlate = exports.IfcPlane = void 0
exports.IfcRelAssignsToProduct = exports.IfcRelAssignsToProcess = exports.IfcRelAssignsToGroupByFactor = exports.IfcRelAssignsToGroup = exports.IfcRelAssignsToControl = exports.IfcRelAssignsToActor = exports.IfcRelAssigns = exports.IfcRelAggregates = exports.IfcReinforcingMeshType = exports.IfcReinforcingMesh = exports.IfcReinforcingElementType = exports.IfcReinforcingElement = exports.IfcReinforcingBarType = exports.IfcReinforcingBar = exports.IfcReinforcementDefinitionProperties = exports.IfcReinforcementBarProperties = exports.IfcRegularTimeSeries = exports.IfcReferent = exports.IfcReference = exports.IfcRecurrencePattern = exports.IfcRectangularTrimmedSurface = exports.IfcRectangularPyramid = exports.IfcRectangleProfileDef = exports.IfcRectangleHollowProfileDef = exports.IfcRationalBSplineSurfaceWithKnots = exports.IfcRationalBSplineCurveWithKnots = exports.IfcRampType = exports.IfcRampFlightType = exports.IfcRampFlight = exports.IfcRamp = exports.IfcRailingType = exports.IfcRailing = exports.IfcQuantityWeight = exports.IfcQuantityVolume = exports.IfcQuantityTime = exports.IfcQuantitySet = exports.IfcQuantityLength = exports.IfcQuantityCount = exports.IfcQuantityArea = exports.IfcPumpType = exports.IfcPump = exports.IfcProxy = exports.IfcProtectiveDeviceType = exports.IfcProtectiveDeviceTrippingUnitType = exports.IfcProtectiveDeviceTrippingUnit = exports.IfcProtectiveDevice = exports.IfcPropertyTemplateDefinition = exports.IfcPropertyTemplate = exports.IfcPropertyTableValue = exports.IfcPropertySingleValue = void 0
exports.IfcResourceLevelRelationship = exports.IfcResourceConstraintRelationship = exports.IfcResourceApprovalRelationship = exports.IfcResource = exports.IfcRepresentationMap = exports.IfcRepresentationItem = exports.IfcRepresentationContext = exports.IfcRepresentation = exports.IfcReparametrisedCompositeCurveSegment = exports.IfcRelationship = exports.IfcRelVoidsElement = exports.IfcRelSpaceBoundary2ndLevel = exports.IfcRelSpaceBoundary1stLevel = exports.IfcRelSpaceBoundary = exports.IfcRelServicesBuildings = exports.IfcRelSequence = exports.IfcRelReferencedInSpatialStructure = exports.IfcRelProjectsElement = exports.IfcRelPositions = exports.IfcRelNests = exports.IfcRelInterferesElements = exports.IfcRelFlowControlElements = exports.IfcRelFillsElement = exports.IfcRelDefinesByType = exports.IfcRelDefinesByTemplate = exports.IfcRelDefinesByProperties = exports.IfcRelDefinesByObject = exports.IfcRelDefines = exports.IfcRelDecomposes = exports.IfcRelDeclares = exports.IfcRelCoversSpaces = exports.IfcRelCoversBldgElements = exports.IfcRelContainedInSpatialStructure = exports.IfcRelConnectsWithRealizingElements = exports.IfcRelConnectsWithEccentricity = exports.IfcRelConnectsStructuralMember = exports.IfcRelConnectsStructuralActivity = exports.IfcRelConnectsPorts = exports.IfcRelConnectsPortToElement = exports.IfcRelConnectsPathElements = exports.IfcRelConnectsElements = exports.IfcRelConnects = exports.IfcRelAssociatesMaterial = exports.IfcRelAssociatesLibrary = exports.IfcRelAssociatesDocument = exports.IfcRelAssociatesConstraint = exports.IfcRelAssociatesClassification = exports.IfcRelAssociatesApproval = exports.IfcRelAssociates = exports.IfcRelAssignsToResource = void 0
exports.IfcSphericalSurface = exports.IfcSphere = exports.IfcSpatialZoneType = exports.IfcSpatialZone = exports.IfcSpatialStructureElementType = exports.IfcSpatialStructureElement = exports.IfcSpatialElementType = exports.IfcSpatialElement = exports.IfcSpaceType = exports.IfcSpaceHeaterType = exports.IfcSpaceHeater = exports.IfcSpace = exports.IfcSolidModel = exports.IfcSolarDeviceType = exports.IfcSolarDevice = exports.IfcSlippageConnectionCondition = exports.IfcSlabType = exports.IfcSlabStandardCase = exports.IfcSlabElementedCase = exports.IfcSlab = exports.IfcSite = exports.IfcSimplePropertyTemplate = exports.IfcSimpleProperty = exports.IfcShellBasedSurfaceModel = exports.IfcShapeRepresentation = exports.IfcShapeModel = exports.IfcShapeAspect = exports.IfcShadingDeviceType = exports.IfcShadingDevice = exports.IfcSensorType = exports.IfcSensor = exports.IfcSectionedSpine = exports.IfcSectionedSolidHorizontal = exports.IfcSectionedSolid = exports.IfcSectionReinforcementProperties = exports.IfcSectionProperties = exports.IfcSeamCurve = exports.IfcSchedulingTime = exports.IfcSanitaryTerminalType = exports.IfcSanitaryTerminal = exports.IfcSIUnit = exports.IfcRoundedRectangleProfileDef = exports.IfcRoot = exports.IfcRoofType = exports.IfcRoof = exports.IfcRightCircularCylinder = exports.IfcRightCircularCone = exports.IfcRevolvedAreaSolidTapered = exports.IfcRevolvedAreaSolid = exports.IfcResourceTime = void 0
exports.IfcSurface = exports.IfcSubedge = exports.IfcSubContractResourceType = exports.IfcSubContractResource = exports.IfcStyledRepresentation = exports.IfcStyledItem = exports.IfcStyleModel = exports.IfcStructuralSurfaceReaction = exports.IfcStructuralSurfaceMemberVarying = exports.IfcStructuralSurfaceMember = exports.IfcStructuralSurfaceConnection = exports.IfcStructuralSurfaceAction = exports.IfcStructuralResultGroup = exports.IfcStructuralReaction = exports.IfcStructuralPointReaction = exports.IfcStructuralPointConnection = exports.IfcStructuralPointAction = exports.IfcStructuralPlanarAction = exports.IfcStructuralMember = exports.IfcStructuralLoadTemperature = exports.IfcStructuralLoadStatic = exports.IfcStructuralLoadSingleForceWarping = exports.IfcStructuralLoadSingleForce = exports.IfcStructuralLoadSingleDisplacementDistortion = exports.IfcStructuralLoadSingleDisplacement = exports.IfcStructuralLoadPlanarForce = exports.IfcStructuralLoadOrResult = exports.IfcStructuralLoadLinearForce = exports.IfcStructuralLoadGroup = exports.IfcStructuralLoadConfiguration = exports.IfcStructuralLoadCase = exports.IfcStructuralLoad = exports.IfcStructuralLinearAction = exports.IfcStructuralItem = exports.IfcStructuralCurveReaction = exports.IfcStructuralCurveMemberVarying = exports.IfcStructuralCurveMember = exports.IfcStructuralCurveConnection = exports.IfcStructuralCurveAction = exports.IfcStructuralConnectionCondition = exports.IfcStructuralConnection = exports.IfcStructuralAnalysisModel = exports.IfcStructuralActivity = exports.IfcStructuralAction = exports.IfcStairType = exports.IfcStairFlightType = exports.IfcStairFlight = exports.IfcStair = exports.IfcStackTerminalType = exports.IfcStackTerminal = void 0
exports.IfcTextureMap = exports.IfcTextureCoordinateGenerator = exports.IfcTextureCoordinate = exports.IfcTextStyleTextModel = exports.IfcTextStyleForDefinedFont = exports.IfcTextStyleFontModel = exports.IfcTextStyle = exports.IfcTextLiteralWithExtent = exports.IfcTextLiteral = exports.IfcTessellatedItem = exports.IfcTessellatedFaceSet = exports.IfcTendonType = exports.IfcTendonConduitType = exports.IfcTendonConduit = exports.IfcTendonAnchorType = exports.IfcTendonAnchor = exports.IfcTendon = exports.IfcTelecomAddress = exports.IfcTaskType = exports.IfcTaskTimeRecurring = exports.IfcTaskTime = exports.IfcTask = exports.IfcTankType = exports.IfcTank = exports.IfcTableRow = exports.IfcTableColumn = exports.IfcTable = exports.IfcTShapeProfileDef = exports.IfcSystemFurnitureElementType = exports.IfcSystemFurnitureElement = exports.IfcSystem = exports.IfcSwitchingDeviceType = exports.IfcSwitchingDevice = exports.IfcSweptSurface = exports.IfcSweptDiskSolidPolygonal = exports.IfcSweptDiskSolid = exports.IfcSweptAreaSolid = exports.IfcSurfaceTexture = exports.IfcSurfaceStyleWithTextures = exports.IfcSurfaceStyleShading = exports.IfcSurfaceStyleRendering = exports.IfcSurfaceStyleRefraction = exports.IfcSurfaceStyleLighting = exports.IfcSurfaceStyle = exports.IfcSurfaceReinforcementArea = exports.IfcSurfaceOfRevolution = exports.IfcSurfaceOfLinearExtrusion = exports.IfcSurfaceFeature = exports.IfcSurfaceCurveSweptAreaSolid = exports.IfcSurfaceCurve = void 0
exports.IfcWindowLiningProperties = exports.IfcWindow = exports.IfcWasteTerminalType = exports.IfcWasteTerminal = exports.IfcWallType = exports.IfcWallStandardCase = exports.IfcWallElementedCase = exports.IfcWall = exports.IfcVoidingFeature = exports.IfcVirtualGridIntersection = exports.IfcVirtualElement = exports.IfcVibrationIsolatorType = exports.IfcVibrationIsolator = exports.IfcVibrationDamperType = exports.IfcVibrationDamper = exports.IfcVertexPoint = exports.IfcVertexLoop = exports.IfcVertex = exports.IfcVector = exports.IfcValveType = exports.IfcValve = exports.IfcUnitaryEquipmentType = exports.IfcUnitaryEquipment = exports.IfcUnitaryControlElementType = exports.IfcUnitaryControlElement = exports.IfcUnitAssignment = exports.IfcUShapeProfileDef = exports.IfcTypeResource = exports.IfcTypeProduct = exports.IfcTypeProcess = exports.IfcTypeObject = exports.IfcTubeBundleType = exports.IfcTubeBundle = exports.IfcTrimmedCurve = exports.IfcTriangulatedIrregularNetwork = exports.IfcTriangulatedFaceSet = exports.IfcTrapeziumProfileDef = exports.IfcTransportElementType = exports.IfcTransportElement = exports.IfcTransitionCurveSegment2D = exports.IfcTransformerType = exports.IfcTransformer = exports.IfcToroidalSurface = exports.IfcTopologyRepresentation = exports.IfcTopologicalRepresentationItem = exports.IfcTimeSeriesValue = exports.IfcTimeSeries = exports.IfcTimePeriod = exports.IfcTextureVertexList = exports.IfcTextureVertex = void 0
exports.IfcZone = exports.IfcZShapeProfileDef = exports.IfcWorkTime = exports.IfcWorkSchedule = exports.IfcWorkPlan = exports.IfcWorkControl = exports.IfcWorkCalendar = exports.IfcWindowType = exports.IfcWindowStyle = exports.IfcWindowStandardCase = exports.IfcWindowPanelProperties = void 0
// This is a generated file, please see: gen_functional_types.js
const ifc2x4 = require('./ifc2x4')


exports.FromRawLineData = {}
exports.FromRawLineData[ifc2x4.IFCACTIONREQUEST] = function(d) {
  return IfcActionRequest.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCACTOR] = function(d) {
  return IfcActor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCACTORROLE] = function(d) {
  return IfcActorRole.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCACTUATOR] = function(d) {
  return IfcActuator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCACTUATORTYPE] = function(d) {
  return IfcActuatorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCADDRESS] = function(d) {
  return IfcAddress.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCADVANCEDBREP] = function(d) {
  return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCADVANCEDBREPWITHVOIDS] = function(d) {
  return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCADVANCEDFACE] = function(d) {
  return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTERMINAL] = function(d) {
  return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTERMINALBOX] = function(d) {
  return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTERMINALBOXTYPE] = function(d) {
  return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTERMINALTYPE] = function(d) {
  return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTOAIRHEATRECOVERY] = function(d) {
  return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAIRTOAIRHEATRECOVERYTYPE] = function(d) {
  return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALARM] = function(d) {
  return IfcAlarm.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALARMTYPE] = function(d) {
  return IfcAlarmType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT] = function(d) {
  return IfcAlignment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DHORIZONTAL] = function(d) {
  return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DHORIZONTALSEGMENT] = function(d) {
  return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DSEGMENT] = function(d) {
  return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DVERSEGCIRCULARARC] = function(d) {
  return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DVERSEGLINE] = function(d) {
  return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DVERSEGPARABOLICARC] = function(d) {
  return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DVERTICAL] = function(d) {
  return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENT2DVERTICALSEGMENT] = function(d) {
  return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCALIGNMENTCURVE] = function(d) {
  return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCANNOTATION] = function(d) {
  return IfcAnnotation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCANNOTATIONFILLAREA] = function(d) {
  return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAPPLICATION] = function(d) {
  return IfcApplication.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAPPLIEDVALUE] = function(d) {
  return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAPPROVAL] = function(d) {
  return IfcApproval.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAPPROVALRELATIONSHIP] = function(d) {
  return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCARBITRARYCLOSEDPROFILEDEF] = function(d) {
  return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCARBITRARYOPENPROFILEDEF] = function(d) {
  return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCARBITRARYPROFILEDEFWITHVOIDS] = function(d) {
  return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCASSET] = function(d) {
  return IfcAsset.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCASYMMETRICISHAPEPROFILEDEF] = function(d) {
  return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAUDIOVISUALAPPLIANCE] = function(d) {
  return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAUDIOVISUALAPPLIANCETYPE] = function(d) {
  return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAXIS1PLACEMENT] = function(d) {
  return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAXIS2PLACEMENT2D] = function(d) {
  return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCAXIS2PLACEMENT3D] = function(d) {
  return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBSPLINECURVE] = function(d) {
  return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBSPLINECURVEWITHKNOTS] = function(d) {
  return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBSPLINESURFACE] = function(d) {
  return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBSPLINESURFACEWITHKNOTS] = function(d) {
  return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBEAM] = function(d) {
  return IfcBeam.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBEAMSTANDARDCASE] = function(d) {
  return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBEAMTYPE] = function(d) {
  return IfcBeamType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBEARING] = function(d) {
  return IfcBearing.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBEARINGTYPE] = function(d) {
  return IfcBearingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBLOBTEXTURE] = function(d) {
  return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBLOCK] = function(d) {
  return IfcBlock.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOILER] = function(d) {
  return IfcBoiler.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOILERTYPE] = function(d) {
  return IfcBoilerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOOLEANCLIPPINGRESULT] = function(d) {
  return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOOLEANRESULT] = function(d) {
  return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYCONDITION] = function(d) {
  return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYCURVE] = function(d) {
  return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYEDGECONDITION] = function(d) {
  return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYFACECONDITION] = function(d) {
  return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYNODECONDITION] = function(d) {
  return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDARYNODECONDITIONWARPING] = function(d) {
  return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDEDCURVE] = function(d) {
  return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDEDSURFACE] = function(d) {
  return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOUNDINGBOX] = function(d) {
  return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBOXEDHALFSPACE] = function(d) {
  return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBRIDGE] = function(d) {
  return IfcBridge.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBRIDGEPART] = function(d) {
  return IfcBridgePart.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDING] = function(d) {
  return IfcBuilding.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENT] = function(d) {
  return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENTPART] = function(d) {
  return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENTPARTTYPE] = function(d) {
  return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENTPROXY] = function(d) {
  return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENTPROXYTYPE] = function(d) {
  return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGELEMENTTYPE] = function(d) {
  return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGSTOREY] = function(d) {
  return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBUILDINGSYSTEM] = function(d) {
  return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBURNER] = function(d) {
  return IfcBurner.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCBURNERTYPE] = function(d) {
  return IfcBurnerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCSHAPEPROFILEDEF] = function(d) {
  return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLECARRIERFITTING] = function(d) {
  return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLECARRIERFITTINGTYPE] = function(d) {
  return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLECARRIERSEGMENT] = function(d) {
  return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLECARRIERSEGMENTTYPE] = function(d) {
  return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLEFITTING] = function(d) {
  return IfcCableFitting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLEFITTINGTYPE] = function(d) {
  return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLESEGMENT] = function(d) {
  return IfcCableSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCABLESEGMENTTYPE] = function(d) {
  return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCAISSONFOUNDATION] = function(d) {
  return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCAISSONFOUNDATIONTYPE] = function(d) {
  return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANPOINT] = function(d) {
  return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANPOINTLIST] = function(d) {
  return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANPOINTLIST2D] = function(d) {
  return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANPOINTLIST3D] = function(d) {
  return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANTRANSFORMATIONOPERATOR] = function(d) {
  return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANTRANSFORMATIONOPERATOR2D] = function(d) {
  return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = function(d) {
  return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANTRANSFORMATIONOPERATOR3D] = function(d) {
  return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = function(d) {
  return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCENTERLINEPROFILEDEF] = function(d) {
  return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCHILLER] = function(d) {
  return IfcChiller.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCHILLERTYPE] = function(d) {
  return IfcChillerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCHIMNEY] = function(d) {
  return IfcChimney.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCHIMNEYTYPE] = function(d) {
  return IfcChimneyType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIRCLE] = function(d) {
  return IfcCircle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIRCLEHOLLOWPROFILEDEF] = function(d) {
  return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIRCLEPROFILEDEF] = function(d) {
  return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIRCULARARCSEGMENT2D] = function(d) {
  return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIVILELEMENT] = function(d) {
  return IfcCivilElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCIVILELEMENTTYPE] = function(d) {
  return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCLASSIFICATION] = function(d) {
  return IfcClassification.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCLASSIFICATIONREFERENCE] = function(d) {
  return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCLOSEDSHELL] = function(d) {
  return IfcClosedShell.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOIL] = function(d) {
  return IfcCoil.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOILTYPE] = function(d) {
  return IfcCoilType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLOURRGB] = function(d) {
  return IfcColourRgb.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLOURRGBLIST] = function(d) {
  return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLOURSPECIFICATION] = function(d) {
  return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLUMN] = function(d) {
  return IfcColumn.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLUMNSTANDARDCASE] = function(d) {
  return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOLUMNTYPE] = function(d) {
  return IfcColumnType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMMUNICATIONSAPPLIANCE] = function(d) {
  return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMMUNICATIONSAPPLIANCETYPE] = function(d) {
  return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPLEXPROPERTY] = function(d) {
  return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPLEXPROPERTYTEMPLATE] = function(d) {
  return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPOSITECURVE] = function(d) {
  return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPOSITECURVEONSURFACE] = function(d) {
  return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPOSITECURVESEGMENT] = function(d) {
  return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPOSITEPROFILEDEF] = function(d) {
  return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPRESSOR] = function(d) {
  return IfcCompressor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOMPRESSORTYPE] = function(d) {
  return IfcCompressorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONDENSER] = function(d) {
  return IfcCondenser.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONDENSERTYPE] = function(d) {
  return IfcCondenserType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONIC] = function(d) {
  return IfcConic.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTEDFACESET] = function(d) {
  return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONCURVEGEOMETRY] = function(d) {
  return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONGEOMETRY] = function(d) {
  return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONPOINTECCENTRICITY] = function(d) {
  return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONPOINTGEOMETRY] = function(d) {
  return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONSURFACEGEOMETRY] = function(d) {
  return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONNECTIONVOLUMEGEOMETRY] = function(d) {
  return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRAINT] = function(d) {
  return IfcConstraint.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONEQUIPMENTRESOURCE] = function(d) {
  return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = function(d) {
  return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONMATERIALRESOURCE] = function(d) {
  return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONMATERIALRESOURCETYPE] = function(d) {
  return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONPRODUCTRESOURCE] = function(d) {
  return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = function(d) {
  return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONRESOURCE] = function(d) {
  return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONSTRUCTIONRESOURCETYPE] = function(d) {
  return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONTEXT] = function(d) {
  return IfcContext.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONTEXTDEPENDENTUNIT] = function(d) {
  return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONTROL] = function(d) {
  return IfcControl.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONTROLLER] = function(d) {
  return IfcController.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONTROLLERTYPE] = function(d) {
  return IfcControllerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONVERSIONBASEDUNIT] = function(d) {
  return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCONVERSIONBASEDUNITWITHOFFSET] = function(d) {
  return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOOLEDBEAM] = function(d) {
  return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOOLEDBEAMTYPE] = function(d) {
  return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOOLINGTOWER] = function(d) {
  return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOOLINGTOWERTYPE] = function(d) {
  return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOORDINATEOPERATION] = function(d) {
  return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOORDINATEREFERENCESYSTEM] = function(d) {
  return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOSTITEM] = function(d) {
  return IfcCostItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOSTSCHEDULE] = function(d) {
  return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOSTVALUE] = function(d) {
  return IfcCostValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOVERING] = function(d) {
  return IfcCovering.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCOVERINGTYPE] = function(d) {
  return IfcCoveringType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCREWRESOURCE] = function(d) {
  return IfcCrewResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCREWRESOURCETYPE] = function(d) {
  return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCSGPRIMITIVE3D] = function(d) {
  return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCSGSOLID] = function(d) {
  return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURRENCYRELATIONSHIP] = function(d) {
  return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURTAINWALL] = function(d) {
  return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURTAINWALLTYPE] = function(d) {
  return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVE] = function(d) {
  return IfcCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVEBOUNDEDPLANE] = function(d) {
  return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVEBOUNDEDSURFACE] = function(d) {
  return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVESEGMENT2D] = function(d) {
  return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVESTYLE] = function(d) {
  return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVESTYLEFONT] = function(d) {
  return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVESTYLEFONTANDSCALING] = function(d) {
  return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCURVESTYLEFONTPATTERN] = function(d) {
  return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCCYLINDRICALSURFACE] = function(d) {
  return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDAMPER] = function(d) {
  return IfcDamper.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDAMPERTYPE] = function(d) {
  return IfcDamperType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDEEPFOUNDATION] = function(d) {
  return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDEEPFOUNDATIONTYPE] = function(d) {
  return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDERIVEDPROFILEDEF] = function(d) {
  return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDERIVEDUNIT] = function(d) {
  return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDERIVEDUNITELEMENT] = function(d) {
  return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDIMENSIONALEXPONENTS] = function(d) {
  return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDIRECTION] = function(d) {
  return IfcDirection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISCRETEACCESSORY] = function(d) {
  return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISCRETEACCESSORYTYPE] = function(d) {
  return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTANCEEXPRESSION] = function(d) {
  return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONCHAMBERELEMENT] = function(d) {
  return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = function(d) {
  return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONCIRCUIT] = function(d) {
  return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONCONTROLELEMENT] = function(d) {
  return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONCONTROLELEMENTTYPE] = function(d) {
  return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONELEMENT] = function(d) {
  return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONELEMENTTYPE] = function(d) {
  return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONFLOWELEMENT] = function(d) {
  return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONFLOWELEMENTTYPE] = function(d) {
  return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONPORT] = function(d) {
  return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDISTRIBUTIONSYSTEM] = function(d) {
  return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOCUMENTINFORMATION] = function(d) {
  return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOCUMENTINFORMATIONRELATIONSHIP] = function(d) {
  return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOCUMENTREFERENCE] = function(d) {
  return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOOR] = function(d) {
  return IfcDoor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOORLININGPROPERTIES] = function(d) {
  return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOORPANELPROPERTIES] = function(d) {
  return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOORSTANDARDCASE] = function(d) {
  return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOORSTYLE] = function(d) {
  return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDOORTYPE] = function(d) {
  return IfcDoorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDRAUGHTINGPREDEFINEDCOLOUR] = function(d) {
  return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDRAUGHTINGPREDEFINEDCURVEFONT] = function(d) {
  return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTFITTING] = function(d) {
  return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTFITTINGTYPE] = function(d) {
  return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTSEGMENT] = function(d) {
  return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTSEGMENTTYPE] = function(d) {
  return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTSILENCER] = function(d) {
  return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCDUCTSILENCERTYPE] = function(d) {
  return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEDGE] = function(d) {
  return IfcEdge.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEDGECURVE] = function(d) {
  return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEDGELOOP] = function(d) {
  return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICAPPLIANCE] = function(d) {
  return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICAPPLIANCETYPE] = function(d) {
  return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICDISTRIBUTIONBOARD] = function(d) {
  return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICDISTRIBUTIONBOARDTYPE] = function(d) {
  return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICFLOWSTORAGEDEVICE] = function(d) {
  return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICFLOWSTORAGEDEVICETYPE] = function(d) {
  return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICGENERATOR] = function(d) {
  return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICGENERATORTYPE] = function(d) {
  return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICMOTOR] = function(d) {
  return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICMOTORTYPE] = function(d) {
  return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICTIMECONTROL] = function(d) {
  return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELECTRICTIMECONTROLTYPE] = function(d) {
  return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENT] = function(d) {
  return IfcElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTASSEMBLY] = function(d) {
  return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTASSEMBLYTYPE] = function(d) {
  return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTCOMPONENT] = function(d) {
  return IfcElementComponent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTCOMPONENTTYPE] = function(d) {
  return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTQUANTITY] = function(d) {
  return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTTYPE] = function(d) {
  return IfcElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELEMENTARYSURFACE] = function(d) {
  return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELLIPSE] = function(d) {
  return IfcEllipse.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCELLIPSEPROFILEDEF] = function(d) {
  return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCENERGYCONVERSIONDEVICE] = function(d) {
  return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCENERGYCONVERSIONDEVICETYPE] = function(d) {
  return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCENGINE] = function(d) {
  return IfcEngine.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCENGINETYPE] = function(d) {
  return IfcEngineType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVAPORATIVECOOLER] = function(d) {
  return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVAPORATIVECOOLERTYPE] = function(d) {
  return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVAPORATOR] = function(d) {
  return IfcEvaporator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVAPORATORTYPE] = function(d) {
  return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVENT] = function(d) {
  return IfcEvent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVENTTIME] = function(d) {
  return IfcEventTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEVENTTYPE] = function(d) {
  return IfcEventType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTENDEDPROPERTIES] = function(d) {
  return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALINFORMATION] = function(d) {
  return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALREFERENCE] = function(d) {
  return IfcExternalReference.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALREFERENCERELATIONSHIP] = function(d) {
  return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALSPATIALELEMENT] = function(d) {
  return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALSPATIALSTRUCTUREELEMENT] = function(d) {
  return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALLYDEFINEDHATCHSTYLE] = function(d) {
  return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALLYDEFINEDSURFACESTYLE] = function(d) {
  return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTERNALLYDEFINEDTEXTFONT] = function(d) {
  return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTRUDEDAREASOLID] = function(d) {
  return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCEXTRUDEDAREASOLIDTAPERED] = function(d) {
  return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACE] = function(d) {
  return IfcFace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACEBASEDSURFACEMODEL] = function(d) {
  return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACEBOUND] = function(d) {
  return IfcFaceBound.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACEOUTERBOUND] = function(d) {
  return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACESURFACE] = function(d) {
  return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACETEDBREP] = function(d) {
  return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACETEDBREPWITHVOIDS] = function(d) {
  return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACILITY] = function(d) {
  return IfcFacility.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFACILITYPART] = function(d) {
  return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFAILURECONNECTIONCONDITION] = function(d) {
  return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFAN] = function(d) {
  return IfcFan.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFANTYPE] = function(d) {
  return IfcFanType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFASTENER] = function(d) {
  return IfcFastener.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFASTENERTYPE] = function(d) {
  return IfcFastenerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFEATUREELEMENT] = function(d) {
  return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFEATUREELEMENTADDITION] = function(d) {
  return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFEATUREELEMENTSUBTRACTION] = function(d) {
  return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFILLAREASTYLE] = function(d) {
  return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFILLAREASTYLEHATCHING] = function(d) {
  return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFILLAREASTYLETILES] = function(d) {
  return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFILTER] = function(d) {
  return IfcFilter.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFILTERTYPE] = function(d) {
  return IfcFilterType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFIRESUPPRESSIONTERMINAL] = function(d) {
  return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFIRESUPPRESSIONTERMINALTYPE] = function(d) {
  return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFIXEDREFERENCESWEPTAREASOLID] = function(d) {
  return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWCONTROLLER] = function(d) {
  return IfcFlowController.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWCONTROLLERTYPE] = function(d) {
  return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWFITTING] = function(d) {
  return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWFITTINGTYPE] = function(d) {
  return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWINSTRUMENT] = function(d) {
  return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWINSTRUMENTTYPE] = function(d) {
  return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWMETER] = function(d) {
  return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWMETERTYPE] = function(d) {
  return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWMOVINGDEVICE] = function(d) {
  return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWMOVINGDEVICETYPE] = function(d) {
  return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWSEGMENT] = function(d) {
  return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWSEGMENTTYPE] = function(d) {
  return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWSTORAGEDEVICE] = function(d) {
  return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWSTORAGEDEVICETYPE] = function(d) {
  return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWTERMINAL] = function(d) {
  return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWTERMINALTYPE] = function(d) {
  return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWTREATMENTDEVICE] = function(d) {
  return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFLOWTREATMENTDEVICETYPE] = function(d) {
  return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFOOTING] = function(d) {
  return IfcFooting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFOOTINGTYPE] = function(d) {
  return IfcFootingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFURNISHINGELEMENT] = function(d) {
  return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFURNISHINGELEMENTTYPE] = function(d) {
  return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFURNITURE] = function(d) {
  return IfcFurniture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCFURNITURETYPE] = function(d) {
  return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOGRAPHICELEMENT] = function(d) {
  return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOGRAPHICELEMENTTYPE] = function(d) {
  return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOMETRICCURVESET] = function(d) {
  return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOMETRICREPRESENTATIONCONTEXT] = function(d) {
  return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOMETRICREPRESENTATIONITEM] = function(d) {
  return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = function(d) {
  return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGEOMETRICSET] = function(d) {
  return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGRID] = function(d) {
  return IfcGrid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGRIDAXIS] = function(d) {
  return IfcGridAxis.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGRIDPLACEMENT] = function(d) {
  return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCGROUP] = function(d) {
  return IfcGroup.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCHALFSPACESOLID] = function(d) {
  return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCHEATEXCHANGER] = function(d) {
  return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCHEATEXCHANGERTYPE] = function(d) {
  return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCHUMIDIFIER] = function(d) {
  return IfcHumidifier.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCHUMIDIFIERTYPE] = function(d) {
  return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCISHAPEPROFILEDEF] = function(d) {
  return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCIMAGETEXTURE] = function(d) {
  return IfcImageTexture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDCOLOURMAP] = function(d) {
  return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDPOLYCURVE] = function(d) {
  return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDPOLYGONALFACE] = function(d) {
  return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDPOLYGONALFACEWITHVOIDS] = function(d) {
  return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDTEXTUREMAP] = function(d) {
  return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINDEXEDTRIANGLETEXTUREMAP] = function(d) {
  return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINTERCEPTOR] = function(d) {
  return IfcInterceptor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINTERCEPTORTYPE] = function(d) {
  return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINTERSECTIONCURVE] = function(d) {
  return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCINVENTORY] = function(d) {
  return IfcInventory.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCIRREGULARTIMESERIES] = function(d) {
  return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCIRREGULARTIMESERIESVALUE] = function(d) {
  return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCJUNCTIONBOX] = function(d) {
  return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCJUNCTIONBOXTYPE] = function(d) {
  return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLSHAPEPROFILEDEF] = function(d) {
  return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLABORRESOURCE] = function(d) {
  return IfcLaborResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLABORRESOURCETYPE] = function(d) {
  return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLAGTIME] = function(d) {
  return IfcLagTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLAMP] = function(d) {
  return IfcLamp.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLAMPTYPE] = function(d) {
  return IfcLampType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIBRARYINFORMATION] = function(d) {
  return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIBRARYREFERENCE] = function(d) {
  return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTDISTRIBUTIONDATA] = function(d) {
  return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTFIXTURE] = function(d) {
  return IfcLightFixture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTFIXTURETYPE] = function(d) {
  return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTINTENSITYDISTRIBUTION] = function(d) {
  return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCE] = function(d) {
  return IfcLightSource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCEAMBIENT] = function(d) {
  return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCEDIRECTIONAL] = function(d) {
  return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCEGONIOMETRIC] = function(d) {
  return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCEPOSITIONAL] = function(d) {
  return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLIGHTSOURCESPOT] = function(d) {
  return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLINE] = function(d) {
  return IfcLine.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLINESEGMENT2D] = function(d) {
  return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLINEARPLACEMENT] = function(d) {
  return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLINEARPOSITIONINGELEMENT] = function(d) {
  return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLOCALPLACEMENT] = function(d) {
  return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCLOOP] = function(d) {
  return IfcLoop.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMANIFOLDSOLIDBREP] = function(d) {
  return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMAPCONVERSION] = function(d) {
  return IfcMapConversion.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMAPPEDITEM] = function(d) {
  return IfcMappedItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIAL] = function(d) {
  return IfcMaterial.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALCLASSIFICATIONRELATIONSHIP] = function(d) {
  return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALCONSTITUENT] = function(d) {
  return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALCONSTITUENTSET] = function(d) {
  return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALDEFINITION] = function(d) {
  return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALDEFINITIONREPRESENTATION] = function(d) {
  return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALLAYER] = function(d) {
  return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALLAYERSET] = function(d) {
  return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALLAYERSETUSAGE] = function(d) {
  return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALLAYERWITHOFFSETS] = function(d) {
  return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALLIST] = function(d) {
  return IfcMaterialList.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROFILE] = function(d) {
  return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROFILESET] = function(d) {
  return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROFILESETUSAGE] = function(d) {
  return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROFILESETUSAGETAPERING] = function(d) {
  return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROFILEWITHOFFSETS] = function(d) {
  return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALPROPERTIES] = function(d) {
  return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALRELATIONSHIP] = function(d) {
  return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMATERIALUSAGEDEFINITION] = function(d) {
  return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEASUREWITHUNIT] = function(d) {
  return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMECHANICALFASTENER] = function(d) {
  return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMECHANICALFASTENERTYPE] = function(d) {
  return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEDICALDEVICE] = function(d) {
  return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEDICALDEVICETYPE] = function(d) {
  return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEMBER] = function(d) {
  return IfcMember.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEMBERSTANDARDCASE] = function(d) {
  return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMEMBERTYPE] = function(d) {
  return IfcMemberType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMETRIC] = function(d) {
  return IfcMetric.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMIRROREDPROFILEDEF] = function(d) {
  return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMONETARYUNIT] = function(d) {
  return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMOTORCONNECTION] = function(d) {
  return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCMOTORCONNECTIONTYPE] = function(d) {
  return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCNAMEDUNIT] = function(d) {
  return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOBJECT] = function(d) {
  return IfcObject.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOBJECTDEFINITION] = function(d) {
  return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOBJECTPLACEMENT] = function(d) {
  return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOBJECTIVE] = function(d) {
  return IfcObjective.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOCCUPANT] = function(d) {
  return IfcOccupant.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOFFSETCURVE] = function(d) {
  return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOFFSETCURVE2D] = function(d) {
  return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOFFSETCURVE3D] = function(d) {
  return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOFFSETCURVEBYDISTANCES] = function(d) {
  return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOPENSHELL] = function(d) {
  return IfcOpenShell.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOPENINGELEMENT] = function(d) {
  return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOPENINGSTANDARDCASE] = function(d) {
  return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCORGANIZATION] = function(d) {
  return IfcOrganization.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCORGANIZATIONRELATIONSHIP] = function(d) {
  return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCORIENTATIONEXPRESSION] = function(d) {
  return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCORIENTEDEDGE] = function(d) {
  return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOUTERBOUNDARYCURVE] = function(d) {
  return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOUTLET] = function(d) {
  return IfcOutlet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOUTLETTYPE] = function(d) {
  return IfcOutletType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCOWNERHISTORY] = function(d) {
  return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPARAMETERIZEDPROFILEDEF] = function(d) {
  return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPATH] = function(d) {
  return IfcPath.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPCURVE] = function(d) {
  return IfcPcurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPERFORMANCEHISTORY] = function(d) {
  return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPERMEABLECOVERINGPROPERTIES] = function(d) {
  return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPERMIT] = function(d) {
  return IfcPermit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPERSON] = function(d) {
  return IfcPerson.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPERSONANDORGANIZATION] = function(d) {
  return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPHYSICALCOMPLEXQUANTITY] = function(d) {
  return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPHYSICALQUANTITY] = function(d) {
  return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPHYSICALSIMPLEQUANTITY] = function(d) {
  return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPILE] = function(d) {
  return IfcPile.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPILETYPE] = function(d) {
  return IfcPileType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPIPEFITTING] = function(d) {
  return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPIPEFITTINGTYPE] = function(d) {
  return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPIPESEGMENT] = function(d) {
  return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPIPESEGMENTTYPE] = function(d) {
  return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPIXELTEXTURE] = function(d) {
  return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLACEMENT] = function(d) {
  return IfcPlacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLANARBOX] = function(d) {
  return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLANAREXTENT] = function(d) {
  return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLANE] = function(d) {
  return IfcPlane.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLATE] = function(d) {
  return IfcPlate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLATESTANDARDCASE] = function(d) {
  return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPLATETYPE] = function(d) {
  return IfcPlateType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOINT] = function(d) {
  return IfcPoint.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOINTONCURVE] = function(d) {
  return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOINTONSURFACE] = function(d) {
  return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOLYLOOP] = function(d) {
  return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOLYGONALBOUNDEDHALFSPACE] = function(d) {
  return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOLYGONALFACESET] = function(d) {
  return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOLYLINE] = function(d) {
  return IfcPolyline.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPORT] = function(d) {
  return IfcPort.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOSITIONINGELEMENT] = function(d) {
  return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPOSTALADDRESS] = function(d) {
  return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDCOLOUR] = function(d) {
  return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDCURVEFONT] = function(d) {
  return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDITEM] = function(d) {
  return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDPROPERTIES] = function(d) {
  return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDPROPERTYSET] = function(d) {
  return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPREDEFINEDTEXTFONT] = function(d) {
  return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRESENTATIONITEM] = function(d) {
  return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRESENTATIONLAYERASSIGNMENT] = function(d) {
  return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRESENTATIONLAYERWITHSTYLE] = function(d) {
  return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRESENTATIONSTYLE] = function(d) {
  return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRESENTATIONSTYLEASSIGNMENT] = function(d) {
  return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROCEDURE] = function(d) {
  return IfcProcedure.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROCEDURETYPE] = function(d) {
  return IfcProcedureType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROCESS] = function(d) {
  return IfcProcess.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRODUCT] = function(d) {
  return IfcProduct.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRODUCTDEFINITIONSHAPE] = function(d) {
  return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPRODUCTREPRESENTATION] = function(d) {
  return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROFILEDEF] = function(d) {
  return IfcProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROFILEPROPERTIES] = function(d) {
  return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROJECT] = function(d) {
  return IfcProject.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROJECTLIBRARY] = function(d) {
  return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROJECTORDER] = function(d) {
  return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROJECTEDCRS] = function(d) {
  return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROJECTIONELEMENT] = function(d) {
  return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTY] = function(d) {
  return IfcProperty.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYABSTRACTION] = function(d) {
  return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYBOUNDEDVALUE] = function(d) {
  return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYDEFINITION] = function(d) {
  return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYDEPENDENCYRELATIONSHIP] = function(d) {
  return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYENUMERATEDVALUE] = function(d) {
  return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYENUMERATION] = function(d) {
  return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYLISTVALUE] = function(d) {
  return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYREFERENCEVALUE] = function(d) {
  return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYSET] = function(d) {
  return IfcPropertySet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYSETDEFINITION] = function(d) {
  return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYSETTEMPLATE] = function(d) {
  return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYSINGLEVALUE] = function(d) {
  return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYTABLEVALUE] = function(d) {
  return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYTEMPLATE] = function(d) {
  return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROPERTYTEMPLATEDEFINITION] = function(d) {
  return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROTECTIVEDEVICE] = function(d) {
  return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROTECTIVEDEVICETRIPPINGUNIT] = function(d) {
  return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = function(d) {
  return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROTECTIVEDEVICETYPE] = function(d) {
  return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPROXY] = function(d) {
  return IfcProxy.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPUMP] = function(d) {
  return IfcPump.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCPUMPTYPE] = function(d) {
  return IfcPumpType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYAREA] = function(d) {
  return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYCOUNT] = function(d) {
  return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYLENGTH] = function(d) {
  return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYSET] = function(d) {
  return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYTIME] = function(d) {
  return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYVOLUME] = function(d) {
  return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCQUANTITYWEIGHT] = function(d) {
  return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAILING] = function(d) {
  return IfcRailing.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAILINGTYPE] = function(d) {
  return IfcRailingType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAMP] = function(d) {
  return IfcRamp.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAMPFLIGHT] = function(d) {
  return IfcRampFlight.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAMPFLIGHTTYPE] = function(d) {
  return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRAMPTYPE] = function(d) {
  return IfcRampType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRATIONALBSPLINECURVEWITHKNOTS] = function(d) {
  return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRATIONALBSPLINESURFACEWITHKNOTS] = function(d) {
  return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRECTANGLEHOLLOWPROFILEDEF] = function(d) {
  return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRECTANGLEPROFILEDEF] = function(d) {
  return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRECTANGULARPYRAMID] = function(d) {
  return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRECTANGULARTRIMMEDSURFACE] = function(d) {
  return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRECURRENCEPATTERN] = function(d) {
  return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREFERENCE] = function(d) {
  return IfcReference.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREFERENT] = function(d) {
  return IfcReferent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREGULARTIMESERIES] = function(d) {
  return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCEMENTBARPROPERTIES] = function(d) {
  return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCEMENTDEFINITIONPROPERTIES] = function(d) {
  return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGBAR] = function(d) {
  return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGBARTYPE] = function(d) {
  return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGELEMENT] = function(d) {
  return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGELEMENTTYPE] = function(d) {
  return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGMESH] = function(d) {
  return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREINFORCINGMESHTYPE] = function(d) {
  return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELAGGREGATES] = function(d) {
  return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNS] = function(d) {
  return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOACTOR] = function(d) {
  return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOCONTROL] = function(d) {
  return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOGROUP] = function(d) {
  return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOGROUPBYFACTOR] = function(d) {
  return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOPROCESS] = function(d) {
  return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTOPRODUCT] = function(d) {
  return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSIGNSTORESOURCE] = function(d) {
  return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATES] = function(d) {
  return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESAPPROVAL] = function(d) {
  return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESCLASSIFICATION] = function(d) {
  return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESCONSTRAINT] = function(d) {
  return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESDOCUMENT] = function(d) {
  return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESLIBRARY] = function(d) {
  return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELASSOCIATESMATERIAL] = function(d) {
  return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTS] = function(d) {
  return IfcRelConnects.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSELEMENTS] = function(d) {
  return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSPATHELEMENTS] = function(d) {
  return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSPORTTOELEMENT] = function(d) {
  return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSPORTS] = function(d) {
  return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSSTRUCTURALACTIVITY] = function(d) {
  return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSSTRUCTURALMEMBER] = function(d) {
  return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSWITHECCENTRICITY] = function(d) {
  return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONNECTSWITHREALIZINGELEMENTS] = function(d) {
  return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCONTAINEDINSPATIALSTRUCTURE] = function(d) {
  return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCOVERSBLDGELEMENTS] = function(d) {
  return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELCOVERSSPACES] = function(d) {
  return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDECLARES] = function(d) {
  return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDECOMPOSES] = function(d) {
  return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDEFINES] = function(d) {
  return IfcRelDefines.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDEFINESBYOBJECT] = function(d) {
  return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDEFINESBYPROPERTIES] = function(d) {
  return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDEFINESBYTEMPLATE] = function(d) {
  return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELDEFINESBYTYPE] = function(d) {
  return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELFILLSELEMENT] = function(d) {
  return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELFLOWCONTROLELEMENTS] = function(d) {
  return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELINTERFERESELEMENTS] = function(d) {
  return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELNESTS] = function(d) {
  return IfcRelNests.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELPOSITIONS] = function(d) {
  return IfcRelPositions.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELPROJECTSELEMENT] = function(d) {
  return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELREFERENCEDINSPATIALSTRUCTURE] = function(d) {
  return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELSEQUENCE] = function(d) {
  return IfcRelSequence.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELSERVICESBUILDINGS] = function(d) {
  return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELSPACEBOUNDARY] = function(d) {
  return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELSPACEBOUNDARY1STLEVEL] = function(d) {
  return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELSPACEBOUNDARY2NDLEVEL] = function(d) {
  return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELVOIDSELEMENT] = function(d) {
  return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRELATIONSHIP] = function(d) {
  return IfcRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = function(d) {
  return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREPRESENTATION] = function(d) {
  return IfcRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREPRESENTATIONCONTEXT] = function(d) {
  return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREPRESENTATIONITEM] = function(d) {
  return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREPRESENTATIONMAP] = function(d) {
  return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRESOURCE] = function(d) {
  return IfcResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRESOURCEAPPROVALRELATIONSHIP] = function(d) {
  return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRESOURCECONSTRAINTRELATIONSHIP] = function(d) {
  return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRESOURCELEVELRELATIONSHIP] = function(d) {
  return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRESOURCETIME] = function(d) {
  return IfcResourceTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREVOLVEDAREASOLID] = function(d) {
  return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCREVOLVEDAREASOLIDTAPERED] = function(d) {
  return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRIGHTCIRCULARCONE] = function(d) {
  return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCRIGHTCIRCULARCYLINDER] = function(d) {
  return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCROOF] = function(d) {
  return IfcRoof.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCROOFTYPE] = function(d) {
  return IfcRoofType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCROOT] = function(d) {
  return IfcRoot.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCROUNDEDRECTANGLEPROFILEDEF] = function(d) {
  return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSIUNIT] = function(d) {
  return IfcSIUnit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSANITARYTERMINAL] = function(d) {
  return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSANITARYTERMINALTYPE] = function(d) {
  return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSCHEDULINGTIME] = function(d) {
  return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSEAMCURVE] = function(d) {
  return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSECTIONPROPERTIES] = function(d) {
  return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSECTIONREINFORCEMENTPROPERTIES] = function(d) {
  return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSECTIONEDSOLID] = function(d) {
  return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSECTIONEDSOLIDHORIZONTAL] = function(d) {
  return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSECTIONEDSPINE] = function(d) {
  return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSENSOR] = function(d) {
  return IfcSensor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSENSORTYPE] = function(d) {
  return IfcSensorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHADINGDEVICE] = function(d) {
  return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHADINGDEVICETYPE] = function(d) {
  return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHAPEASPECT] = function(d) {
  return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHAPEMODEL] = function(d) {
  return IfcShapeModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHAPEREPRESENTATION] = function(d) {
  return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSHELLBASEDSURFACEMODEL] = function(d) {
  return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSIMPLEPROPERTY] = function(d) {
  return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSIMPLEPROPERTYTEMPLATE] = function(d) {
  return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSITE] = function(d) {
  return IfcSite.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSLAB] = function(d) {
  return IfcSlab.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSLABELEMENTEDCASE] = function(d) {
  return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSLABSTANDARDCASE] = function(d) {
  return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSLABTYPE] = function(d) {
  return IfcSlabType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSLIPPAGECONNECTIONCONDITION] = function(d) {
  return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSOLARDEVICE] = function(d) {
  return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSOLARDEVICETYPE] = function(d) {
  return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSOLIDMODEL] = function(d) {
  return IfcSolidModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPACE] = function(d) {
  return IfcSpace.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPACEHEATER] = function(d) {
  return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPACEHEATERTYPE] = function(d) {
  return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPACETYPE] = function(d) {
  return IfcSpaceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALELEMENT] = function(d) {
  return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALELEMENTTYPE] = function(d) {
  return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALSTRUCTUREELEMENT] = function(d) {
  return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALSTRUCTUREELEMENTTYPE] = function(d) {
  return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALZONE] = function(d) {
  return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPATIALZONETYPE] = function(d) {
  return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPHERE] = function(d) {
  return IfcSphere.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSPHERICALSURFACE] = function(d) {
  return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTACKTERMINAL] = function(d) {
  return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTACKTERMINALTYPE] = function(d) {
  return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTAIR] = function(d) {
  return IfcStair.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTAIRFLIGHT] = function(d) {
  return IfcStairFlight.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTAIRFLIGHTTYPE] = function(d) {
  return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTAIRTYPE] = function(d) {
  return IfcStairType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALACTION] = function(d) {
  return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALACTIVITY] = function(d) {
  return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALANALYSISMODEL] = function(d) {
  return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCONNECTION] = function(d) {
  return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCONNECTIONCONDITION] = function(d) {
  return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCURVEACTION] = function(d) {
  return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCURVECONNECTION] = function(d) {
  return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCURVEMEMBER] = function(d) {
  return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCURVEMEMBERVARYING] = function(d) {
  return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALCURVEREACTION] = function(d) {
  return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALITEM] = function(d) {
  return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLINEARACTION] = function(d) {
  return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOAD] = function(d) {
  return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADCASE] = function(d) {
  return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADCONFIGURATION] = function(d) {
  return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADGROUP] = function(d) {
  return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADLINEARFORCE] = function(d) {
  return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADORRESULT] = function(d) {
  return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADPLANARFORCE] = function(d) {
  return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = function(d) {
  return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = function(d) {
  return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADSINGLEFORCE] = function(d) {
  return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADSINGLEFORCEWARPING] = function(d) {
  return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADSTATIC] = function(d) {
  return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALLOADTEMPERATURE] = function(d) {
  return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALMEMBER] = function(d) {
  return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALPLANARACTION] = function(d) {
  return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALPOINTACTION] = function(d) {
  return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALPOINTCONNECTION] = function(d) {
  return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALPOINTREACTION] = function(d) {
  return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALREACTION] = function(d) {
  return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALRESULTGROUP] = function(d) {
  return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALSURFACEACTION] = function(d) {
  return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALSURFACECONNECTION] = function(d) {
  return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALSURFACEMEMBER] = function(d) {
  return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALSURFACEMEMBERVARYING] = function(d) {
  return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTRUCTURALSURFACEREACTION] = function(d) {
  return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTYLEMODEL] = function(d) {
  return IfcStyleModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTYLEDITEM] = function(d) {
  return IfcStyledItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSTYLEDREPRESENTATION] = function(d) {
  return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSUBCONTRACTRESOURCE] = function(d) {
  return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSUBCONTRACTRESOURCETYPE] = function(d) {
  return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSUBEDGE] = function(d) {
  return IfcSubedge.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACE] = function(d) {
  return IfcSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACECURVE] = function(d) {
  return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACECURVESWEPTAREASOLID] = function(d) {
  return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACEFEATURE] = function(d) {
  return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACEOFLINEAREXTRUSION] = function(d) {
  return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACEOFREVOLUTION] = function(d) {
  return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACEREINFORCEMENTAREA] = function(d) {
  return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLE] = function(d) {
  return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLELIGHTING] = function(d) {
  return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLEREFRACTION] = function(d) {
  return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLERENDERING] = function(d) {
  return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLESHADING] = function(d) {
  return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACESTYLEWITHTEXTURES] = function(d) {
  return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSURFACETEXTURE] = function(d) {
  return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWEPTAREASOLID] = function(d) {
  return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWEPTDISKSOLID] = function(d) {
  return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWEPTDISKSOLIDPOLYGONAL] = function(d) {
  return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWEPTSURFACE] = function(d) {
  return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWITCHINGDEVICE] = function(d) {
  return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSWITCHINGDEVICETYPE] = function(d) {
  return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSYSTEM] = function(d) {
  return IfcSystem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSYSTEMFURNITUREELEMENT] = function(d) {
  return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCSYSTEMFURNITUREELEMENTTYPE] = function(d) {
  return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTSHAPEPROFILEDEF] = function(d) {
  return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTABLE] = function(d) {
  return IfcTable.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTABLECOLUMN] = function(d) {
  return IfcTableColumn.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTABLEROW] = function(d) {
  return IfcTableRow.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTANK] = function(d) {
  return IfcTank.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTANKTYPE] = function(d) {
  return IfcTankType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTASK] = function(d) {
  return IfcTask.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTASKTIME] = function(d) {
  return IfcTaskTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTASKTIMERECURRING] = function(d) {
  return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTASKTYPE] = function(d) {
  return IfcTaskType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTELECOMADDRESS] = function(d) {
  return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDON] = function(d) {
  return IfcTendon.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDONANCHOR] = function(d) {
  return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDONANCHORTYPE] = function(d) {
  return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDONCONDUIT] = function(d) {
  return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDONCONDUITTYPE] = function(d) {
  return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTENDONTYPE] = function(d) {
  return IfcTendonType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTESSELLATEDFACESET] = function(d) {
  return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTESSELLATEDITEM] = function(d) {
  return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTLITERAL] = function(d) {
  return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTLITERALWITHEXTENT] = function(d) {
  return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTSTYLE] = function(d) {
  return IfcTextStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTSTYLEFONTMODEL] = function(d) {
  return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTSTYLEFORDEFINEDFONT] = function(d) {
  return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTSTYLETEXTMODEL] = function(d) {
  return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTURECOORDINATE] = function(d) {
  return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTURECOORDINATEGENERATOR] = function(d) {
  return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTUREMAP] = function(d) {
  return IfcTextureMap.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTUREVERTEX] = function(d) {
  return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTEXTUREVERTEXLIST] = function(d) {
  return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTIMEPERIOD] = function(d) {
  return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTIMESERIES] = function(d) {
  return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTIMESERIESVALUE] = function(d) {
  return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTOPOLOGICALREPRESENTATIONITEM] = function(d) {
  return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTOPOLOGYREPRESENTATION] = function(d) {
  return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTOROIDALSURFACE] = function(d) {
  return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRANSFORMER] = function(d) {
  return IfcTransformer.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRANSFORMERTYPE] = function(d) {
  return IfcTransformerType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRANSITIONCURVESEGMENT2D] = function(d) {
  return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRANSPORTELEMENT] = function(d) {
  return IfcTransportElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRANSPORTELEMENTTYPE] = function(d) {
  return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRAPEZIUMPROFILEDEF] = function(d) {
  return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRIANGULATEDFACESET] = function(d) {
  return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRIANGULATEDIRREGULARNETWORK] = function(d) {
  return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTRIMMEDCURVE] = function(d) {
  return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTUBEBUNDLE] = function(d) {
  return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTUBEBUNDLETYPE] = function(d) {
  return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTYPEOBJECT] = function(d) {
  return IfcTypeObject.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTYPEPROCESS] = function(d) {
  return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTYPEPRODUCT] = function(d) {
  return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCTYPERESOURCE] = function(d) {
  return IfcTypeResource.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUSHAPEPROFILEDEF] = function(d) {
  return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUNITASSIGNMENT] = function(d) {
  return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUNITARYCONTROLELEMENT] = function(d) {
  return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUNITARYCONTROLELEMENTTYPE] = function(d) {
  return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUNITARYEQUIPMENT] = function(d) {
  return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCUNITARYEQUIPMENTTYPE] = function(d) {
  return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVALVE] = function(d) {
  return IfcValve.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVALVETYPE] = function(d) {
  return IfcValveType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVECTOR] = function(d) {
  return IfcVector.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVERTEX] = function(d) {
  return IfcVertex.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVERTEXLOOP] = function(d) {
  return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVERTEXPOINT] = function(d) {
  return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIBRATIONDAMPER] = function(d) {
  return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIBRATIONDAMPERTYPE] = function(d) {
  return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIBRATIONISOLATOR] = function(d) {
  return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIBRATIONISOLATORTYPE] = function(d) {
  return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIRTUALELEMENT] = function(d) {
  return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVIRTUALGRIDINTERSECTION] = function(d) {
  return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCVOIDINGFEATURE] = function(d) {
  return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWALL] = function(d) {
  return IfcWall.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWALLELEMENTEDCASE] = function(d) {
  return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWALLSTANDARDCASE] = function(d) {
  return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWALLTYPE] = function(d) {
  return IfcWallType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWASTETERMINAL] = function(d) {
  return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWASTETERMINALTYPE] = function(d) {
  return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOW] = function(d) {
  return IfcWindow.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOWLININGPROPERTIES] = function(d) {
  return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOWPANELPROPERTIES] = function(d) {
  return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOWSTANDARDCASE] = function(d) {
  return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOWSTYLE] = function(d) {
  return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWINDOWTYPE] = function(d) {
  return IfcWindowType.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWORKCALENDAR] = function(d) {
  return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWORKCONTROL] = function(d) {
  return IfcWorkControl.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWORKPLAN] = function(d) {
  return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWORKSCHEDULE] = function(d) {
  return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCWORKTIME] = function(d) {
  return IfcWorkTime.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCZSHAPEPROFILEDEF] = function(d) {
  return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments)
}
exports.FromRawLineData[ifc2x4.IFCZONE] = function(d) {
  return IfcZone.FromTape(d.ID, d.type, d.arguments)
}
/**
 *
 */
function Write(obj) {
  return { expressID: 0 }
}
exports.Write = Write
/**
 *
 */
function Value(type, value) {
  return { t: type, v: value }
}
exports.Value = Value
const UNKNOWN = 0
const STRING = 1
const LABEL = 2
const ENUM = 3
const REAL = 4
const REF = 5
const EMPTY = 6
const SET_BEGIN = 7
const SET_END = 8
const LINE_END = 9
const IfcAbsorbedDoseMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAbsorbedDoseMeasure(v) {
    this.value = v
  }
  return IfcAbsorbedDoseMeasure
}())
exports.IfcAbsorbedDoseMeasure = IfcAbsorbedDoseMeasure

const IfcAccelerationMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAccelerationMeasure(v) {
    this.value = v
  }
  return IfcAccelerationMeasure
}())
exports.IfcAccelerationMeasure = IfcAccelerationMeasure

const IfcAmountOfSubstanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAmountOfSubstanceMeasure(v) {
    this.value = v
  }
  return IfcAmountOfSubstanceMeasure
}())
exports.IfcAmountOfSubstanceMeasure = IfcAmountOfSubstanceMeasure

const IfcAngularVelocityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAngularVelocityMeasure(v) {
    this.value = v
  }
  return IfcAngularVelocityMeasure
}())
exports.IfcAngularVelocityMeasure = IfcAngularVelocityMeasure

const IfcAreaDensityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAreaDensityMeasure(v) {
    this.value = v
  }
  return IfcAreaDensityMeasure
}())
exports.IfcAreaDensityMeasure = IfcAreaDensityMeasure

const IfcAreaMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcAreaMeasure(v) {
    this.value = v
  }
  return IfcAreaMeasure
}())
exports.IfcAreaMeasure = IfcAreaMeasure

const IfcBinary = /** @class */ (function() {
  /**
   *
   */
  function IfcBinary(v) {
    this.value = v
  }
  return IfcBinary
}())
exports.IfcBinary = IfcBinary

const IfcBoolean = /** @class */ (function() {
  /**
   *
   */
  function IfcBoolean(v) {
    this.value = v
  }
  return IfcBoolean
}())
exports.IfcBoolean = IfcBoolean

const IfcBoxAlignment = /** @class */ (function() {
  /**
   *
   */
  function IfcBoxAlignment(v) {
    this.value = v
  }
  return IfcBoxAlignment
}())
exports.IfcBoxAlignment = IfcBoxAlignment

const IfcCardinalPointReference = /** @class */ (function() {
  /**
   *
   */
  function IfcCardinalPointReference(v) {
    this.value = v
  }
  return IfcCardinalPointReference
}())
exports.IfcCardinalPointReference = IfcCardinalPointReference

const IfcContextDependentMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcContextDependentMeasure(v) {
    this.value = v
  }
  return IfcContextDependentMeasure
}())
exports.IfcContextDependentMeasure = IfcContextDependentMeasure

const IfcCountMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcCountMeasure(v) {
    this.value = v
  }
  return IfcCountMeasure
}())
exports.IfcCountMeasure = IfcCountMeasure

const IfcCurvatureMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcCurvatureMeasure(v) {
    this.value = v
  }
  return IfcCurvatureMeasure
}())
exports.IfcCurvatureMeasure = IfcCurvatureMeasure

const IfcDate = /** @class */ (function() {
  /**
   *
   */
  function IfcDate(v) {
    this.value = v
  }
  return IfcDate
}())
exports.IfcDate = IfcDate

const IfcDateTime = /** @class */ (function() {
  /**
   *
   */
  function IfcDateTime(v) {
    this.value = v
  }
  return IfcDateTime
}())
exports.IfcDateTime = IfcDateTime

const IfcDayInMonthNumber = /** @class */ (function() {
  /**
   *
   */
  function IfcDayInMonthNumber(v) {
    this.value = v
  }
  return IfcDayInMonthNumber
}())
exports.IfcDayInMonthNumber = IfcDayInMonthNumber

const IfcDayInWeekNumber = /** @class */ (function() {
  /**
   *
   */
  function IfcDayInWeekNumber(v) {
    this.value = v
  }
  return IfcDayInWeekNumber
}())
exports.IfcDayInWeekNumber = IfcDayInWeekNumber

const IfcDescriptiveMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcDescriptiveMeasure(v) {
    this.value = v
  }
  return IfcDescriptiveMeasure
}())
exports.IfcDescriptiveMeasure = IfcDescriptiveMeasure

const IfcDimensionCount = /** @class */ (function() {
  /**
   *
   */
  function IfcDimensionCount(v) {
    this.value = v
  }
  return IfcDimensionCount
}())
exports.IfcDimensionCount = IfcDimensionCount

const IfcDoseEquivalentMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcDoseEquivalentMeasure(v) {
    this.value = v
  }
  return IfcDoseEquivalentMeasure
}())
exports.IfcDoseEquivalentMeasure = IfcDoseEquivalentMeasure

const IfcDuration = /** @class */ (function() {
  /**
   *
   */
  function IfcDuration(v) {
    this.value = v
  }
  return IfcDuration
}())
exports.IfcDuration = IfcDuration

const IfcDynamicViscosityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcDynamicViscosityMeasure(v) {
    this.value = v
  }
  return IfcDynamicViscosityMeasure
}())
exports.IfcDynamicViscosityMeasure = IfcDynamicViscosityMeasure

const IfcElectricCapacitanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricCapacitanceMeasure(v) {
    this.value = v
  }
  return IfcElectricCapacitanceMeasure
}())
exports.IfcElectricCapacitanceMeasure = IfcElectricCapacitanceMeasure

const IfcElectricChargeMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricChargeMeasure(v) {
    this.value = v
  }
  return IfcElectricChargeMeasure
}())
exports.IfcElectricChargeMeasure = IfcElectricChargeMeasure

const IfcElectricConductanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricConductanceMeasure(v) {
    this.value = v
  }
  return IfcElectricConductanceMeasure
}())
exports.IfcElectricConductanceMeasure = IfcElectricConductanceMeasure

const IfcElectricCurrentMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricCurrentMeasure(v) {
    this.value = v
  }
  return IfcElectricCurrentMeasure
}())
exports.IfcElectricCurrentMeasure = IfcElectricCurrentMeasure

const IfcElectricResistanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricResistanceMeasure(v) {
    this.value = v
  }
  return IfcElectricResistanceMeasure
}())
exports.IfcElectricResistanceMeasure = IfcElectricResistanceMeasure

const IfcElectricVoltageMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricVoltageMeasure(v) {
    this.value = v
  }
  return IfcElectricVoltageMeasure
}())
exports.IfcElectricVoltageMeasure = IfcElectricVoltageMeasure

const IfcEnergyMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcEnergyMeasure(v) {
    this.value = v
  }
  return IfcEnergyMeasure
}())
exports.IfcEnergyMeasure = IfcEnergyMeasure

const IfcFontStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcFontStyle(v) {
    this.value = v
  }
  return IfcFontStyle
}())
exports.IfcFontStyle = IfcFontStyle

const IfcFontVariant = /** @class */ (function() {
  /**
   *
   */
  function IfcFontVariant(v) {
    this.value = v
  }
  return IfcFontVariant
}())
exports.IfcFontVariant = IfcFontVariant

const IfcFontWeight = /** @class */ (function() {
  /**
   *
   */
  function IfcFontWeight(v) {
    this.value = v
  }
  return IfcFontWeight
}())
exports.IfcFontWeight = IfcFontWeight

const IfcForceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcForceMeasure(v) {
    this.value = v
  }
  return IfcForceMeasure
}())
exports.IfcForceMeasure = IfcForceMeasure

const IfcFrequencyMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcFrequencyMeasure(v) {
    this.value = v
  }
  return IfcFrequencyMeasure
}())
exports.IfcFrequencyMeasure = IfcFrequencyMeasure

const IfcGloballyUniqueId = /** @class */ (function() {
  /**
   *
   */
  function IfcGloballyUniqueId(v) {
    this.value = v
  }
  return IfcGloballyUniqueId
}())
exports.IfcGloballyUniqueId = IfcGloballyUniqueId

const IfcHeatFluxDensityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcHeatFluxDensityMeasure(v) {
    this.value = v
  }
  return IfcHeatFluxDensityMeasure
}())
exports.IfcHeatFluxDensityMeasure = IfcHeatFluxDensityMeasure

const IfcHeatingValueMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcHeatingValueMeasure(v) {
    this.value = v
  }
  return IfcHeatingValueMeasure
}())
exports.IfcHeatingValueMeasure = IfcHeatingValueMeasure

const IfcIdentifier = /** @class */ (function() {
  /**
   *
   */
  function IfcIdentifier(v) {
    this.value = v
  }
  return IfcIdentifier
}())
exports.IfcIdentifier = IfcIdentifier

const IfcIlluminanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcIlluminanceMeasure(v) {
    this.value = v
  }
  return IfcIlluminanceMeasure
}())
exports.IfcIlluminanceMeasure = IfcIlluminanceMeasure

const IfcInductanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcInductanceMeasure(v) {
    this.value = v
  }
  return IfcInductanceMeasure
}())
exports.IfcInductanceMeasure = IfcInductanceMeasure

const IfcInteger = /** @class */ (function() {
  /**
   *
   */
  function IfcInteger(v) {
    this.value = v
  }
  return IfcInteger
}())
exports.IfcInteger = IfcInteger

const IfcIntegerCountRateMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcIntegerCountRateMeasure(v) {
    this.value = v
  }
  return IfcIntegerCountRateMeasure
}())
exports.IfcIntegerCountRateMeasure = IfcIntegerCountRateMeasure

const IfcIonConcentrationMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcIonConcentrationMeasure(v) {
    this.value = v
  }
  return IfcIonConcentrationMeasure
}())
exports.IfcIonConcentrationMeasure = IfcIonConcentrationMeasure

const IfcIsothermalMoistureCapacityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcIsothermalMoistureCapacityMeasure(v) {
    this.value = v
  }
  return IfcIsothermalMoistureCapacityMeasure
}())
exports.IfcIsothermalMoistureCapacityMeasure = IfcIsothermalMoistureCapacityMeasure

const IfcKinematicViscosityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcKinematicViscosityMeasure(v) {
    this.value = v
  }
  return IfcKinematicViscosityMeasure
}())
exports.IfcKinematicViscosityMeasure = IfcKinematicViscosityMeasure

const IfcLabel = /** @class */ (function() {
  /**
   *
   */
  function IfcLabel(v) {
    this.value = v
  }
  return IfcLabel
}())
exports.IfcLabel = IfcLabel

const IfcLanguageId = /** @class */ (function() {
  /**
   *
   */
  function IfcLanguageId(v) {
    this.value = v
  }
  return IfcLanguageId
}())
exports.IfcLanguageId = IfcLanguageId

const IfcLengthMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLengthMeasure(v) {
    this.value = v
  }
  return IfcLengthMeasure
}())
exports.IfcLengthMeasure = IfcLengthMeasure

const IfcLinearForceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearForceMeasure(v) {
    this.value = v
  }
  return IfcLinearForceMeasure
}())
exports.IfcLinearForceMeasure = IfcLinearForceMeasure

const IfcLinearMomentMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearMomentMeasure(v) {
    this.value = v
  }
  return IfcLinearMomentMeasure
}())
exports.IfcLinearMomentMeasure = IfcLinearMomentMeasure

const IfcLinearStiffnessMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearStiffnessMeasure(v) {
    this.value = v
  }
  return IfcLinearStiffnessMeasure
}())
exports.IfcLinearStiffnessMeasure = IfcLinearStiffnessMeasure

const IfcLinearVelocityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearVelocityMeasure(v) {
    this.value = v
  }
  return IfcLinearVelocityMeasure
}())
exports.IfcLinearVelocityMeasure = IfcLinearVelocityMeasure

const IfcLogical = /** @class */ (function() {
  /**
   *
   */
  function IfcLogical(v) {
    this.value = v
  }
  return IfcLogical
}())
exports.IfcLogical = IfcLogical

const IfcLuminousFluxMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLuminousFluxMeasure(v) {
    this.value = v
  }
  return IfcLuminousFluxMeasure
}())
exports.IfcLuminousFluxMeasure = IfcLuminousFluxMeasure

const IfcLuminousIntensityDistributionMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLuminousIntensityDistributionMeasure(v) {
    this.value = v
  }
  return IfcLuminousIntensityDistributionMeasure
}())
exports.IfcLuminousIntensityDistributionMeasure = IfcLuminousIntensityDistributionMeasure

const IfcLuminousIntensityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcLuminousIntensityMeasure(v) {
    this.value = v
  }
  return IfcLuminousIntensityMeasure
}())
exports.IfcLuminousIntensityMeasure = IfcLuminousIntensityMeasure

const IfcMagneticFluxDensityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMagneticFluxDensityMeasure(v) {
    this.value = v
  }
  return IfcMagneticFluxDensityMeasure
}())
exports.IfcMagneticFluxDensityMeasure = IfcMagneticFluxDensityMeasure

const IfcMagneticFluxMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMagneticFluxMeasure(v) {
    this.value = v
  }
  return IfcMagneticFluxMeasure
}())
exports.IfcMagneticFluxMeasure = IfcMagneticFluxMeasure

const IfcMassDensityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMassDensityMeasure(v) {
    this.value = v
  }
  return IfcMassDensityMeasure
}())
exports.IfcMassDensityMeasure = IfcMassDensityMeasure

const IfcMassFlowRateMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMassFlowRateMeasure(v) {
    this.value = v
  }
  return IfcMassFlowRateMeasure
}())
exports.IfcMassFlowRateMeasure = IfcMassFlowRateMeasure

const IfcMassMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMassMeasure(v) {
    this.value = v
  }
  return IfcMassMeasure
}())
exports.IfcMassMeasure = IfcMassMeasure

const IfcMassPerLengthMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMassPerLengthMeasure(v) {
    this.value = v
  }
  return IfcMassPerLengthMeasure
}())
exports.IfcMassPerLengthMeasure = IfcMassPerLengthMeasure

const IfcModulusOfElasticityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcModulusOfElasticityMeasure(v) {
    this.value = v
  }
  return IfcModulusOfElasticityMeasure
}())
exports.IfcModulusOfElasticityMeasure = IfcModulusOfElasticityMeasure

const IfcModulusOfLinearSubgradeReactionMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcModulusOfLinearSubgradeReactionMeasure(v) {
    this.value = v
  }
  return IfcModulusOfLinearSubgradeReactionMeasure
}())
exports.IfcModulusOfLinearSubgradeReactionMeasure = IfcModulusOfLinearSubgradeReactionMeasure

const IfcModulusOfRotationalSubgradeReactionMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcModulusOfRotationalSubgradeReactionMeasure(v) {
    this.value = v
  }
  return IfcModulusOfRotationalSubgradeReactionMeasure
}())
exports.IfcModulusOfRotationalSubgradeReactionMeasure = IfcModulusOfRotationalSubgradeReactionMeasure

const IfcModulusOfSubgradeReactionMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcModulusOfSubgradeReactionMeasure(v) {
    this.value = v
  }
  return IfcModulusOfSubgradeReactionMeasure
}())
exports.IfcModulusOfSubgradeReactionMeasure = IfcModulusOfSubgradeReactionMeasure

const IfcMoistureDiffusivityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMoistureDiffusivityMeasure(v) {
    this.value = v
  }
  return IfcMoistureDiffusivityMeasure
}())
exports.IfcMoistureDiffusivityMeasure = IfcMoistureDiffusivityMeasure

const IfcMolecularWeightMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMolecularWeightMeasure(v) {
    this.value = v
  }
  return IfcMolecularWeightMeasure
}())
exports.IfcMolecularWeightMeasure = IfcMolecularWeightMeasure

const IfcMomentOfInertiaMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMomentOfInertiaMeasure(v) {
    this.value = v
  }
  return IfcMomentOfInertiaMeasure
}())
exports.IfcMomentOfInertiaMeasure = IfcMomentOfInertiaMeasure

const IfcMonetaryMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcMonetaryMeasure(v) {
    this.value = v
  }
  return IfcMonetaryMeasure
}())
exports.IfcMonetaryMeasure = IfcMonetaryMeasure

const IfcMonthInYearNumber = /** @class */ (function() {
  /**
   *
   */
  function IfcMonthInYearNumber(v) {
    this.value = v
  }
  return IfcMonthInYearNumber
}())
exports.IfcMonthInYearNumber = IfcMonthInYearNumber

const IfcNonNegativeLengthMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcNonNegativeLengthMeasure(v) {
    this.value = v
  }
  return IfcNonNegativeLengthMeasure
}())
exports.IfcNonNegativeLengthMeasure = IfcNonNegativeLengthMeasure

const IfcNormalisedRatioMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcNormalisedRatioMeasure(v) {
    this.value = v
  }
  return IfcNormalisedRatioMeasure
}())
exports.IfcNormalisedRatioMeasure = IfcNormalisedRatioMeasure

const IfcNumericMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcNumericMeasure(v) {
    this.value = v
  }
  return IfcNumericMeasure
}())
exports.IfcNumericMeasure = IfcNumericMeasure

const IfcPHMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPHMeasure(v) {
    this.value = v
  }
  return IfcPHMeasure
}())
exports.IfcPHMeasure = IfcPHMeasure

const IfcParameterValue = /** @class */ (function() {
  /**
   *
   */
  function IfcParameterValue(v) {
    this.value = v
  }
  return IfcParameterValue
}())
exports.IfcParameterValue = IfcParameterValue

const IfcPlanarForceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPlanarForceMeasure(v) {
    this.value = v
  }
  return IfcPlanarForceMeasure
}())
exports.IfcPlanarForceMeasure = IfcPlanarForceMeasure

const IfcPlaneAngleMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPlaneAngleMeasure(v) {
    this.value = v
  }
  return IfcPlaneAngleMeasure
}())
exports.IfcPlaneAngleMeasure = IfcPlaneAngleMeasure

const IfcPositiveInteger = /** @class */ (function() {
  /**
   *
   */
  function IfcPositiveInteger(v) {
    this.value = v
  }
  return IfcPositiveInteger
}())
exports.IfcPositiveInteger = IfcPositiveInteger

const IfcPositiveLengthMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPositiveLengthMeasure(v) {
    this.value = v
  }
  return IfcPositiveLengthMeasure
}())
exports.IfcPositiveLengthMeasure = IfcPositiveLengthMeasure

const IfcPositivePlaneAngleMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPositivePlaneAngleMeasure(v) {
    this.value = v
  }
  return IfcPositivePlaneAngleMeasure
}())
exports.IfcPositivePlaneAngleMeasure = IfcPositivePlaneAngleMeasure

const IfcPositiveRatioMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPositiveRatioMeasure(v) {
    this.value = v
  }
  return IfcPositiveRatioMeasure
}())
exports.IfcPositiveRatioMeasure = IfcPositiveRatioMeasure

const IfcPowerMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPowerMeasure(v) {
    this.value = v
  }
  return IfcPowerMeasure
}())
exports.IfcPowerMeasure = IfcPowerMeasure

const IfcPresentableText = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentableText(v) {
    this.value = v
  }
  return IfcPresentableText
}())
exports.IfcPresentableText = IfcPresentableText

const IfcPressureMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcPressureMeasure(v) {
    this.value = v
  }
  return IfcPressureMeasure
}())
exports.IfcPressureMeasure = IfcPressureMeasure

const IfcRadioActivityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcRadioActivityMeasure(v) {
    this.value = v
  }
  return IfcRadioActivityMeasure
}())
exports.IfcRadioActivityMeasure = IfcRadioActivityMeasure

const IfcRatioMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcRatioMeasure(v) {
    this.value = v
  }
  return IfcRatioMeasure
}())
exports.IfcRatioMeasure = IfcRatioMeasure

const IfcReal = /** @class */ (function() {
  /**
   *
   */
  function IfcReal(v) {
    this.value = v
  }
  return IfcReal
}())
exports.IfcReal = IfcReal

const IfcRotationalFrequencyMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcRotationalFrequencyMeasure(v) {
    this.value = v
  }
  return IfcRotationalFrequencyMeasure
}())
exports.IfcRotationalFrequencyMeasure = IfcRotationalFrequencyMeasure

const IfcRotationalMassMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcRotationalMassMeasure(v) {
    this.value = v
  }
  return IfcRotationalMassMeasure
}())
exports.IfcRotationalMassMeasure = IfcRotationalMassMeasure

const IfcRotationalStiffnessMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcRotationalStiffnessMeasure(v) {
    this.value = v
  }
  return IfcRotationalStiffnessMeasure
}())
exports.IfcRotationalStiffnessMeasure = IfcRotationalStiffnessMeasure

const IfcSectionModulusMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionModulusMeasure(v) {
    this.value = v
  }
  return IfcSectionModulusMeasure
}())
exports.IfcSectionModulusMeasure = IfcSectionModulusMeasure

const IfcSectionalAreaIntegralMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionalAreaIntegralMeasure(v) {
    this.value = v
  }
  return IfcSectionalAreaIntegralMeasure
}())
exports.IfcSectionalAreaIntegralMeasure = IfcSectionalAreaIntegralMeasure

const IfcShearModulusMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcShearModulusMeasure(v) {
    this.value = v
  }
  return IfcShearModulusMeasure
}())
exports.IfcShearModulusMeasure = IfcShearModulusMeasure

const IfcSolidAngleMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSolidAngleMeasure(v) {
    this.value = v
  }
  return IfcSolidAngleMeasure
}())
exports.IfcSolidAngleMeasure = IfcSolidAngleMeasure

const IfcSoundPowerLevelMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSoundPowerLevelMeasure(v) {
    this.value = v
  }
  return IfcSoundPowerLevelMeasure
}())
exports.IfcSoundPowerLevelMeasure = IfcSoundPowerLevelMeasure

const IfcSoundPowerMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSoundPowerMeasure(v) {
    this.value = v
  }
  return IfcSoundPowerMeasure
}())
exports.IfcSoundPowerMeasure = IfcSoundPowerMeasure

const IfcSoundPressureLevelMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSoundPressureLevelMeasure(v) {
    this.value = v
  }
  return IfcSoundPressureLevelMeasure
}())
exports.IfcSoundPressureLevelMeasure = IfcSoundPressureLevelMeasure

const IfcSoundPressureMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSoundPressureMeasure(v) {
    this.value = v
  }
  return IfcSoundPressureMeasure
}())
exports.IfcSoundPressureMeasure = IfcSoundPressureMeasure

const IfcSpecificHeatCapacityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcSpecificHeatCapacityMeasure(v) {
    this.value = v
  }
  return IfcSpecificHeatCapacityMeasure
}())
exports.IfcSpecificHeatCapacityMeasure = IfcSpecificHeatCapacityMeasure

const IfcSpecularExponent = /** @class */ (function() {
  /**
   *
   */
  function IfcSpecularExponent(v) {
    this.value = v
  }
  return IfcSpecularExponent
}())
exports.IfcSpecularExponent = IfcSpecularExponent

const IfcSpecularRoughness = /** @class */ (function() {
  /**
   *
   */
  function IfcSpecularRoughness(v) {
    this.value = v
  }
  return IfcSpecularRoughness
}())
exports.IfcSpecularRoughness = IfcSpecularRoughness

const IfcTemperatureGradientMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcTemperatureGradientMeasure(v) {
    this.value = v
  }
  return IfcTemperatureGradientMeasure
}())
exports.IfcTemperatureGradientMeasure = IfcTemperatureGradientMeasure

const IfcTemperatureRateOfChangeMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcTemperatureRateOfChangeMeasure(v) {
    this.value = v
  }
  return IfcTemperatureRateOfChangeMeasure
}())
exports.IfcTemperatureRateOfChangeMeasure = IfcTemperatureRateOfChangeMeasure

const IfcText = /** @class */ (function() {
  /**
   *
   */
  function IfcText(v) {
    this.value = v
  }
  return IfcText
}())
exports.IfcText = IfcText

const IfcTextAlignment = /** @class */ (function() {
  /**
   *
   */
  function IfcTextAlignment(v) {
    this.value = v
  }
  return IfcTextAlignment
}())
exports.IfcTextAlignment = IfcTextAlignment

const IfcTextDecoration = /** @class */ (function() {
  /**
   *
   */
  function IfcTextDecoration(v) {
    this.value = v
  }
  return IfcTextDecoration
}())
exports.IfcTextDecoration = IfcTextDecoration

const IfcTextFontName = /** @class */ (function() {
  /**
   *
   */
  function IfcTextFontName(v) {
    this.value = v
  }
  return IfcTextFontName
}())
exports.IfcTextFontName = IfcTextFontName

const IfcTextTransformation = /** @class */ (function() {
  /**
   *
   */
  function IfcTextTransformation(v) {
    this.value = v
  }
  return IfcTextTransformation
}())
exports.IfcTextTransformation = IfcTextTransformation

const IfcThermalAdmittanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermalAdmittanceMeasure(v) {
    this.value = v
  }
  return IfcThermalAdmittanceMeasure
}())
exports.IfcThermalAdmittanceMeasure = IfcThermalAdmittanceMeasure

const IfcThermalConductivityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermalConductivityMeasure(v) {
    this.value = v
  }
  return IfcThermalConductivityMeasure
}())
exports.IfcThermalConductivityMeasure = IfcThermalConductivityMeasure

const IfcThermalExpansionCoefficientMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermalExpansionCoefficientMeasure(v) {
    this.value = v
  }
  return IfcThermalExpansionCoefficientMeasure
}())
exports.IfcThermalExpansionCoefficientMeasure = IfcThermalExpansionCoefficientMeasure

const IfcThermalResistanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermalResistanceMeasure(v) {
    this.value = v
  }
  return IfcThermalResistanceMeasure
}())
exports.IfcThermalResistanceMeasure = IfcThermalResistanceMeasure

const IfcThermalTransmittanceMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermalTransmittanceMeasure(v) {
    this.value = v
  }
  return IfcThermalTransmittanceMeasure
}())
exports.IfcThermalTransmittanceMeasure = IfcThermalTransmittanceMeasure

const IfcThermodynamicTemperatureMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcThermodynamicTemperatureMeasure(v) {
    this.value = v
  }
  return IfcThermodynamicTemperatureMeasure
}())
exports.IfcThermodynamicTemperatureMeasure = IfcThermodynamicTemperatureMeasure

const IfcTime = /** @class */ (function() {
  /**
   *
   */
  function IfcTime(v) {
    this.value = v
  }
  return IfcTime
}())
exports.IfcTime = IfcTime

const IfcTimeMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcTimeMeasure(v) {
    this.value = v
  }
  return IfcTimeMeasure
}())
exports.IfcTimeMeasure = IfcTimeMeasure

const IfcTimeStamp = /** @class */ (function() {
  /**
   *
   */
  function IfcTimeStamp(v) {
    this.value = v
  }
  return IfcTimeStamp
}())
exports.IfcTimeStamp = IfcTimeStamp

const IfcTorqueMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcTorqueMeasure(v) {
    this.value = v
  }
  return IfcTorqueMeasure
}())
exports.IfcTorqueMeasure = IfcTorqueMeasure

const IfcURIReference = /** @class */ (function() {
  /**
   *
   */
  function IfcURIReference(v) {
    this.value = v
  }
  return IfcURIReference
}())
exports.IfcURIReference = IfcURIReference

const IfcVaporPermeabilityMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcVaporPermeabilityMeasure(v) {
    this.value = v
  }
  return IfcVaporPermeabilityMeasure
}())
exports.IfcVaporPermeabilityMeasure = IfcVaporPermeabilityMeasure

const IfcVolumeMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcVolumeMeasure(v) {
    this.value = v
  }
  return IfcVolumeMeasure
}())
exports.IfcVolumeMeasure = IfcVolumeMeasure

const IfcVolumetricFlowRateMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcVolumetricFlowRateMeasure(v) {
    this.value = v
  }
  return IfcVolumetricFlowRateMeasure
}())
exports.IfcVolumetricFlowRateMeasure = IfcVolumetricFlowRateMeasure

const IfcWarpingConstantMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcWarpingConstantMeasure(v) {
    this.value = v
  }
  return IfcWarpingConstantMeasure
}())
exports.IfcWarpingConstantMeasure = IfcWarpingConstantMeasure

const IfcWarpingMomentMeasure = /** @class */ (function() {
  /**
   *
   */
  function IfcWarpingMomentMeasure(v) {
    this.value = v
  }
  return IfcWarpingMomentMeasure
}())
exports.IfcWarpingMomentMeasure = IfcWarpingMomentMeasure

const IfcActionRequestTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcActionRequestTypeEnum(v) {
    this.value = v
  }
  IfcActionRequestTypeEnum.EMAIL = 'EMAIL'
  IfcActionRequestTypeEnum.FAX = 'FAX'
  IfcActionRequestTypeEnum.PHONE = 'PHONE'
  IfcActionRequestTypeEnum.POST = 'POST'
  IfcActionRequestTypeEnum.VERBAL = 'VERBAL'
  IfcActionRequestTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcActionRequestTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcActionRequestTypeEnum
}())
exports.IfcActionRequestTypeEnum = IfcActionRequestTypeEnum

const IfcActionSourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcActionSourceTypeEnum(v) {
    this.value = v
  }
  IfcActionSourceTypeEnum.DEAD_LOAD_G = 'DEAD_LOAD_G'
  IfcActionSourceTypeEnum.COMPLETION_G1 = 'COMPLETION_G1'
  IfcActionSourceTypeEnum.LIVE_LOAD_Q = 'LIVE_LOAD_Q'
  IfcActionSourceTypeEnum.SNOW_S = 'SNOW_S'
  IfcActionSourceTypeEnum.WIND_W = 'WIND_W'
  IfcActionSourceTypeEnum.PRESTRESSING_P = 'PRESTRESSING_P'
  IfcActionSourceTypeEnum.SETTLEMENT_U = 'SETTLEMENT_U'
  IfcActionSourceTypeEnum.TEMPERATURE_T = 'TEMPERATURE_T'
  IfcActionSourceTypeEnum.EARTHQUAKE_E = 'EARTHQUAKE_E'
  IfcActionSourceTypeEnum.FIRE = 'FIRE'
  IfcActionSourceTypeEnum.IMPULSE = 'IMPULSE'
  IfcActionSourceTypeEnum.IMPACT = 'IMPACT'
  IfcActionSourceTypeEnum.TRANSPORT = 'TRANSPORT'
  IfcActionSourceTypeEnum.ERECTION = 'ERECTION'
  IfcActionSourceTypeEnum.PROPPING = 'PROPPING'
  IfcActionSourceTypeEnum.SYSTEM_IMPERFECTION = 'SYSTEM_IMPERFECTION'
  IfcActionSourceTypeEnum.SHRINKAGE = 'SHRINKAGE'
  IfcActionSourceTypeEnum.CREEP = 'CREEP'
  IfcActionSourceTypeEnum.LACK_OF_FIT = 'LACK_OF_FIT'
  IfcActionSourceTypeEnum.BUOYANCY = 'BUOYANCY'
  IfcActionSourceTypeEnum.ICE = 'ICE'
  IfcActionSourceTypeEnum.CURRENT = 'CURRENT'
  IfcActionSourceTypeEnum.WAVE = 'WAVE'
  IfcActionSourceTypeEnum.RAIN = 'RAIN'
  IfcActionSourceTypeEnum.BRAKES = 'BRAKES'
  IfcActionSourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcActionSourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcActionSourceTypeEnum
}())
exports.IfcActionSourceTypeEnum = IfcActionSourceTypeEnum

const IfcActionTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcActionTypeEnum(v) {
    this.value = v
  }
  IfcActionTypeEnum.PERMANENT_G = 'PERMANENT_G'
  IfcActionTypeEnum.VARIABLE_Q = 'VARIABLE_Q'
  IfcActionTypeEnum.EXTRAORDINARY_A = 'EXTRAORDINARY_A'
  IfcActionTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcActionTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcActionTypeEnum
}())
exports.IfcActionTypeEnum = IfcActionTypeEnum

const IfcActuatorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcActuatorTypeEnum(v) {
    this.value = v
  }
  IfcActuatorTypeEnum.ELECTRICACTUATOR = 'ELECTRICACTUATOR'
  IfcActuatorTypeEnum.HANDOPERATEDACTUATOR = 'HANDOPERATEDACTUATOR'
  IfcActuatorTypeEnum.HYDRAULICACTUATOR = 'HYDRAULICACTUATOR'
  IfcActuatorTypeEnum.PNEUMATICACTUATOR = 'PNEUMATICACTUATOR'
  IfcActuatorTypeEnum.THERMOSTATICACTUATOR = 'THERMOSTATICACTUATOR'
  IfcActuatorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcActuatorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcActuatorTypeEnum
}())
exports.IfcActuatorTypeEnum = IfcActuatorTypeEnum

const IfcAddressTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAddressTypeEnum(v) {
    this.value = v
  }
  IfcAddressTypeEnum.OFFICE = 'OFFICE'
  IfcAddressTypeEnum.SITE = 'SITE'
  IfcAddressTypeEnum.HOME = 'HOME'
  IfcAddressTypeEnum.DISTRIBUTIONPOINT = 'DISTRIBUTIONPOINT'
  IfcAddressTypeEnum.USERDEFINED = 'USERDEFINED'
  return IfcAddressTypeEnum
}())
exports.IfcAddressTypeEnum = IfcAddressTypeEnum

const IfcAirTerminalBoxTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminalBoxTypeEnum(v) {
    this.value = v
  }
  IfcAirTerminalBoxTypeEnum.CONSTANTFLOW = 'CONSTANTFLOW'
  IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREDEPENDANT = 'VARIABLEFLOWPRESSUREDEPENDANT'
  IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREINDEPENDANT = 'VARIABLEFLOWPRESSUREINDEPENDANT'
  IfcAirTerminalBoxTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAirTerminalBoxTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAirTerminalBoxTypeEnum
}())
exports.IfcAirTerminalBoxTypeEnum = IfcAirTerminalBoxTypeEnum

const IfcAirTerminalTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminalTypeEnum(v) {
    this.value = v
  }
  IfcAirTerminalTypeEnum.DIFFUSER = 'DIFFUSER'
  IfcAirTerminalTypeEnum.GRILLE = 'GRILLE'
  IfcAirTerminalTypeEnum.LOUVRE = 'LOUVRE'
  IfcAirTerminalTypeEnum.REGISTER = 'REGISTER'
  IfcAirTerminalTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAirTerminalTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAirTerminalTypeEnum
}())
exports.IfcAirTerminalTypeEnum = IfcAirTerminalTypeEnum

const IfcAirToAirHeatRecoveryTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAirToAirHeatRecoveryTypeEnum(v) {
    this.value = v
  }
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECOUNTERFLOWEXCHANGER = 'FIXEDPLATECOUNTERFLOWEXCHANGER'
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECROSSFLOWEXCHANGER = 'FIXEDPLATECROSSFLOWEXCHANGER'
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATEPARALLELFLOWEXCHANGER = 'FIXEDPLATEPARALLELFLOWEXCHANGER'
  IfcAirToAirHeatRecoveryTypeEnum.ROTARYWHEEL = 'ROTARYWHEEL'
  IfcAirToAirHeatRecoveryTypeEnum.RUNAROUNDCOILLOOP = 'RUNAROUNDCOILLOOP'
  IfcAirToAirHeatRecoveryTypeEnum.HEATPIPE = 'HEATPIPE'
  IfcAirToAirHeatRecoveryTypeEnum.TWINTOWERENTHALPYRECOVERYLOOPS = 'TWINTOWERENTHALPYRECOVERYLOOPS'
  IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONSEALEDTUBEHEATEXCHANGERS = 'THERMOSIPHONSEALEDTUBEHEATEXCHANGERS'
  IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONCOILTYPEHEATEXCHANGERS = 'THERMOSIPHONCOILTYPEHEATEXCHANGERS'
  IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAirToAirHeatRecoveryTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAirToAirHeatRecoveryTypeEnum
}())
exports.IfcAirToAirHeatRecoveryTypeEnum = IfcAirToAirHeatRecoveryTypeEnum

const IfcAlarmTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAlarmTypeEnum(v) {
    this.value = v
  }
  IfcAlarmTypeEnum.BELL = 'BELL'
  IfcAlarmTypeEnum.BREAKGLASSBUTTON = 'BREAKGLASSBUTTON'
  IfcAlarmTypeEnum.LIGHT = 'LIGHT'
  IfcAlarmTypeEnum.MANUALPULLBOX = 'MANUALPULLBOX'
  IfcAlarmTypeEnum.SIREN = 'SIREN'
  IfcAlarmTypeEnum.WHISTLE = 'WHISTLE'
  IfcAlarmTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAlarmTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAlarmTypeEnum
}())
exports.IfcAlarmTypeEnum = IfcAlarmTypeEnum

const IfcAlignmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignmentTypeEnum(v) {
    this.value = v
  }
  IfcAlignmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAlignmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAlignmentTypeEnum
}())
exports.IfcAlignmentTypeEnum = IfcAlignmentTypeEnum

const IfcAnalysisModelTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAnalysisModelTypeEnum(v) {
    this.value = v
  }
  IfcAnalysisModelTypeEnum.IN_PLANE_LOADING_2D = 'IN_PLANE_LOADING_2D'
  IfcAnalysisModelTypeEnum.OUT_PLANE_LOADING_2D = 'OUT_PLANE_LOADING_2D'
  IfcAnalysisModelTypeEnum.LOADING_3D = 'LOADING_3D'
  IfcAnalysisModelTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAnalysisModelTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAnalysisModelTypeEnum
}())
exports.IfcAnalysisModelTypeEnum = IfcAnalysisModelTypeEnum

const IfcAnalysisTheoryTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAnalysisTheoryTypeEnum(v) {
    this.value = v
  }
  IfcAnalysisTheoryTypeEnum.FIRST_ORDER_THEORY = 'FIRST_ORDER_THEORY'
  IfcAnalysisTheoryTypeEnum.SECOND_ORDER_THEORY = 'SECOND_ORDER_THEORY'
  IfcAnalysisTheoryTypeEnum.THIRD_ORDER_THEORY = 'THIRD_ORDER_THEORY'
  IfcAnalysisTheoryTypeEnum.FULL_NONLINEAR_THEORY = 'FULL_NONLINEAR_THEORY'
  IfcAnalysisTheoryTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAnalysisTheoryTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAnalysisTheoryTypeEnum
}())
exports.IfcAnalysisTheoryTypeEnum = IfcAnalysisTheoryTypeEnum

const IfcArithmeticOperatorEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcArithmeticOperatorEnum(v) {
    this.value = v
  }
  IfcArithmeticOperatorEnum.ADD = 'ADD'
  IfcArithmeticOperatorEnum.DIVIDE = 'DIVIDE'
  IfcArithmeticOperatorEnum.MULTIPLY = 'MULTIPLY'
  IfcArithmeticOperatorEnum.SUBTRACT = 'SUBTRACT'
  return IfcArithmeticOperatorEnum
}())
exports.IfcArithmeticOperatorEnum = IfcArithmeticOperatorEnum

const IfcAssemblyPlaceEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAssemblyPlaceEnum(v) {
    this.value = v
  }
  IfcAssemblyPlaceEnum.SITE = 'SITE'
  IfcAssemblyPlaceEnum.FACTORY = 'FACTORY'
  IfcAssemblyPlaceEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAssemblyPlaceEnum
}())
exports.IfcAssemblyPlaceEnum = IfcAssemblyPlaceEnum

const IfcAudioVisualApplianceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcAudioVisualApplianceTypeEnum(v) {
    this.value = v
  }
  IfcAudioVisualApplianceTypeEnum.AMPLIFIER = 'AMPLIFIER'
  IfcAudioVisualApplianceTypeEnum.CAMERA = 'CAMERA'
  IfcAudioVisualApplianceTypeEnum.DISPLAY = 'DISPLAY'
  IfcAudioVisualApplianceTypeEnum.MICROPHONE = 'MICROPHONE'
  IfcAudioVisualApplianceTypeEnum.PLAYER = 'PLAYER'
  IfcAudioVisualApplianceTypeEnum.PROJECTOR = 'PROJECTOR'
  IfcAudioVisualApplianceTypeEnum.RECEIVER = 'RECEIVER'
  IfcAudioVisualApplianceTypeEnum.SPEAKER = 'SPEAKER'
  IfcAudioVisualApplianceTypeEnum.SWITCHER = 'SWITCHER'
  IfcAudioVisualApplianceTypeEnum.TELEPHONE = 'TELEPHONE'
  IfcAudioVisualApplianceTypeEnum.TUNER = 'TUNER'
  IfcAudioVisualApplianceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcAudioVisualApplianceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcAudioVisualApplianceTypeEnum
}())
exports.IfcAudioVisualApplianceTypeEnum = IfcAudioVisualApplianceTypeEnum

const IfcBSplineCurveForm = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineCurveForm(v) {
    this.value = v
  }
  IfcBSplineCurveForm.POLYLINE_FORM = 'POLYLINE_FORM'
  IfcBSplineCurveForm.CIRCULAR_ARC = 'CIRCULAR_ARC'
  IfcBSplineCurveForm.ELLIPTIC_ARC = 'ELLIPTIC_ARC'
  IfcBSplineCurveForm.PARABOLIC_ARC = 'PARABOLIC_ARC'
  IfcBSplineCurveForm.HYPERBOLIC_ARC = 'HYPERBOLIC_ARC'
  IfcBSplineCurveForm.UNSPECIFIED = 'UNSPECIFIED'
  return IfcBSplineCurveForm
}())
exports.IfcBSplineCurveForm = IfcBSplineCurveForm

const IfcBSplineSurfaceForm = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineSurfaceForm(v) {
    this.value = v
  }
  IfcBSplineSurfaceForm.PLANE_SURF = 'PLANE_SURF'
  IfcBSplineSurfaceForm.CYLINDRICAL_SURF = 'CYLINDRICAL_SURF'
  IfcBSplineSurfaceForm.CONICAL_SURF = 'CONICAL_SURF'
  IfcBSplineSurfaceForm.SPHERICAL_SURF = 'SPHERICAL_SURF'
  IfcBSplineSurfaceForm.TOROIDAL_SURF = 'TOROIDAL_SURF'
  IfcBSplineSurfaceForm.SURF_OF_REVOLUTION = 'SURF_OF_REVOLUTION'
  IfcBSplineSurfaceForm.RULED_SURF = 'RULED_SURF'
  IfcBSplineSurfaceForm.GENERALISED_CONE = 'GENERALISED_CONE'
  IfcBSplineSurfaceForm.QUADRIC_SURF = 'QUADRIC_SURF'
  IfcBSplineSurfaceForm.SURF_OF_LINEAR_EXTRUSION = 'SURF_OF_LINEAR_EXTRUSION'
  IfcBSplineSurfaceForm.UNSPECIFIED = 'UNSPECIFIED'
  return IfcBSplineSurfaceForm
}())
exports.IfcBSplineSurfaceForm = IfcBSplineSurfaceForm

const IfcBeamTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBeamTypeEnum(v) {
    this.value = v
  }
  IfcBeamTypeEnum.BEAM = 'BEAM'
  IfcBeamTypeEnum.JOIST = 'JOIST'
  IfcBeamTypeEnum.HOLLOWCORE = 'HOLLOWCORE'
  IfcBeamTypeEnum.LINTEL = 'LINTEL'
  IfcBeamTypeEnum.SPANDREL = 'SPANDREL'
  IfcBeamTypeEnum.T_BEAM = 'T_BEAM'
  IfcBeamTypeEnum.GIRDER_SEGMENT = 'GIRDER_SEGMENT'
  IfcBeamTypeEnum.DIAPHRAGM = 'DIAPHRAGM'
  IfcBeamTypeEnum.PIERCAP = 'PIERCAP'
  IfcBeamTypeEnum.HATSTONE = 'HATSTONE'
  IfcBeamTypeEnum.CORNICE = 'CORNICE'
  IfcBeamTypeEnum.EDGEBEAM = 'EDGEBEAM'
  IfcBeamTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBeamTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBeamTypeEnum
}())
exports.IfcBeamTypeEnum = IfcBeamTypeEnum

const IfcBearingTypeDisplacementEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBearingTypeDisplacementEnum(v) {
    this.value = v
  }
  IfcBearingTypeDisplacementEnum.FIXED_MOVEMENT = 'FIXED_MOVEMENT'
  IfcBearingTypeDisplacementEnum.GUIDED_LONGITUDINAL = 'GUIDED_LONGITUDINAL'
  IfcBearingTypeDisplacementEnum.GUIDED_TRANSVERSAL = 'GUIDED_TRANSVERSAL'
  IfcBearingTypeDisplacementEnum.FREE_MOVEMENT = 'FREE_MOVEMENT'
  IfcBearingTypeDisplacementEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBearingTypeDisplacementEnum
}())
exports.IfcBearingTypeDisplacementEnum = IfcBearingTypeDisplacementEnum

const IfcBearingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBearingTypeEnum(v) {
    this.value = v
  }
  IfcBearingTypeEnum.CYLINDRICAL = 'CYLINDRICAL'
  IfcBearingTypeEnum.SPHERICAL = 'SPHERICAL'
  IfcBearingTypeEnum.ELASTOMERIC = 'ELASTOMERIC'
  IfcBearingTypeEnum.POT = 'POT'
  IfcBearingTypeEnum.GUIDE = 'GUIDE'
  IfcBearingTypeEnum.ROCKER = 'ROCKER'
  IfcBearingTypeEnum.ROLLER = 'ROLLER'
  IfcBearingTypeEnum.DISK = 'DISK'
  IfcBearingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBearingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBearingTypeEnum
}())
exports.IfcBearingTypeEnum = IfcBearingTypeEnum

const IfcBenchmarkEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBenchmarkEnum(v) {
    this.value = v
  }
  IfcBenchmarkEnum.GREATERTHAN = 'GREATERTHAN'
  IfcBenchmarkEnum.GREATERTHANOREQUALTO = 'GREATERTHANOREQUALTO'
  IfcBenchmarkEnum.LESSTHAN = 'LESSTHAN'
  IfcBenchmarkEnum.LESSTHANOREQUALTO = 'LESSTHANOREQUALTO'
  IfcBenchmarkEnum.EQUALTO = 'EQUALTO'
  IfcBenchmarkEnum.NOTEQUALTO = 'NOTEQUALTO'
  IfcBenchmarkEnum.INCLUDES = 'INCLUDES'
  IfcBenchmarkEnum.NOTINCLUDES = 'NOTINCLUDES'
  IfcBenchmarkEnum.INCLUDEDIN = 'INCLUDEDIN'
  IfcBenchmarkEnum.NOTINCLUDEDIN = 'NOTINCLUDEDIN'
  return IfcBenchmarkEnum
}())
exports.IfcBenchmarkEnum = IfcBenchmarkEnum

const IfcBoilerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBoilerTypeEnum(v) {
    this.value = v
  }
  IfcBoilerTypeEnum.WATER = 'WATER'
  IfcBoilerTypeEnum.STEAM = 'STEAM'
  IfcBoilerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBoilerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBoilerTypeEnum
}())
exports.IfcBoilerTypeEnum = IfcBoilerTypeEnum

const IfcBooleanOperator = /** @class */ (function() {
  /**
   *
   */
  function IfcBooleanOperator(v) {
    this.value = v
  }
  IfcBooleanOperator.UNION = 'UNION'
  IfcBooleanOperator.INTERSECTION = 'INTERSECTION'
  IfcBooleanOperator.DIFFERENCE = 'DIFFERENCE'
  return IfcBooleanOperator
}())
exports.IfcBooleanOperator = IfcBooleanOperator

const IfcBridgePartTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBridgePartTypeEnum(v) {
    this.value = v
  }
  IfcBridgePartTypeEnum.ABUTMENT = 'ABUTMENT'
  IfcBridgePartTypeEnum.DECK = 'DECK'
  IfcBridgePartTypeEnum.DECK_SEGMENT = 'DECK_SEGMENT'
  IfcBridgePartTypeEnum.FOUNDATION = 'FOUNDATION'
  IfcBridgePartTypeEnum.PIER = 'PIER'
  IfcBridgePartTypeEnum.PIER_SEGMENT = 'PIER_SEGMENT'
  IfcBridgePartTypeEnum.PYLON = 'PYLON'
  IfcBridgePartTypeEnum.SUBSTRUCTURE = 'SUBSTRUCTURE'
  IfcBridgePartTypeEnum.SUPERSTRUCTURE = 'SUPERSTRUCTURE'
  IfcBridgePartTypeEnum.SURFACESTRUCTURE = 'SURFACESTRUCTURE'
  IfcBridgePartTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBridgePartTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBridgePartTypeEnum
}())
exports.IfcBridgePartTypeEnum = IfcBridgePartTypeEnum

const IfcBridgeTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBridgeTypeEnum(v) {
    this.value = v
  }
  IfcBridgeTypeEnum.ARCHED = 'ARCHED'
  IfcBridgeTypeEnum.CABLE_STAYED = 'CABLE_STAYED'
  IfcBridgeTypeEnum.CANTILEVER = 'CANTILEVER'
  IfcBridgeTypeEnum.CULVERT = 'CULVERT'
  IfcBridgeTypeEnum.FRAMEWORK = 'FRAMEWORK'
  IfcBridgeTypeEnum.GIRDER = 'GIRDER'
  IfcBridgeTypeEnum.SUSPENSION = 'SUSPENSION'
  IfcBridgeTypeEnum.TRUSS = 'TRUSS'
  IfcBridgeTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBridgeTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBridgeTypeEnum
}())
exports.IfcBridgeTypeEnum = IfcBridgeTypeEnum

const IfcBuildingElementPartTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementPartTypeEnum(v) {
    this.value = v
  }
  IfcBuildingElementPartTypeEnum.INSULATION = 'INSULATION'
  IfcBuildingElementPartTypeEnum.PRECASTPANEL = 'PRECASTPANEL'
  IfcBuildingElementPartTypeEnum.APRON = 'APRON'
  IfcBuildingElementPartTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBuildingElementPartTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBuildingElementPartTypeEnum
}())
exports.IfcBuildingElementPartTypeEnum = IfcBuildingElementPartTypeEnum

const IfcBuildingElementProxyTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementProxyTypeEnum(v) {
    this.value = v
  }
  IfcBuildingElementProxyTypeEnum.COMPLEX = 'COMPLEX'
  IfcBuildingElementProxyTypeEnum.ELEMENT = 'ELEMENT'
  IfcBuildingElementProxyTypeEnum.PARTIAL = 'PARTIAL'
  IfcBuildingElementProxyTypeEnum.PROVISIONFORVOID = 'PROVISIONFORVOID'
  IfcBuildingElementProxyTypeEnum.PROVISIONFORSPACE = 'PROVISIONFORSPACE'
  IfcBuildingElementProxyTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBuildingElementProxyTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBuildingElementProxyTypeEnum
}())
exports.IfcBuildingElementProxyTypeEnum = IfcBuildingElementProxyTypeEnum

const IfcBuildingSystemTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingSystemTypeEnum(v) {
    this.value = v
  }
  IfcBuildingSystemTypeEnum.FENESTRATION = 'FENESTRATION'
  IfcBuildingSystemTypeEnum.FOUNDATION = 'FOUNDATION'
  IfcBuildingSystemTypeEnum.LOADBEARING = 'LOADBEARING'
  IfcBuildingSystemTypeEnum.OUTERSHELL = 'OUTERSHELL'
  IfcBuildingSystemTypeEnum.SHADING = 'SHADING'
  IfcBuildingSystemTypeEnum.TRANSPORT = 'TRANSPORT'
  IfcBuildingSystemTypeEnum.REINFORCING = 'REINFORCING'
  IfcBuildingSystemTypeEnum.PRESTRESSING = 'PRESTRESSING'
  IfcBuildingSystemTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBuildingSystemTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBuildingSystemTypeEnum
}())
exports.IfcBuildingSystemTypeEnum = IfcBuildingSystemTypeEnum

const IfcBurnerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcBurnerTypeEnum(v) {
    this.value = v
  }
  IfcBurnerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcBurnerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcBurnerTypeEnum
}())
exports.IfcBurnerTypeEnum = IfcBurnerTypeEnum

const IfcCableCarrierFittingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierFittingTypeEnum(v) {
    this.value = v
  }
  IfcCableCarrierFittingTypeEnum.BEND = 'BEND'
  IfcCableCarrierFittingTypeEnum.CROSS = 'CROSS'
  IfcCableCarrierFittingTypeEnum.REDUCER = 'REDUCER'
  IfcCableCarrierFittingTypeEnum.TEE = 'TEE'
  IfcCableCarrierFittingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCableCarrierFittingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCableCarrierFittingTypeEnum
}())
exports.IfcCableCarrierFittingTypeEnum = IfcCableCarrierFittingTypeEnum

const IfcCableCarrierSegmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierSegmentTypeEnum(v) {
    this.value = v
  }
  IfcCableCarrierSegmentTypeEnum.CABLELADDERSEGMENT = 'CABLELADDERSEGMENT'
  IfcCableCarrierSegmentTypeEnum.CABLETRAYSEGMENT = 'CABLETRAYSEGMENT'
  IfcCableCarrierSegmentTypeEnum.CABLETRUNKINGSEGMENT = 'CABLETRUNKINGSEGMENT'
  IfcCableCarrierSegmentTypeEnum.CONDUITSEGMENT = 'CONDUITSEGMENT'
  IfcCableCarrierSegmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCableCarrierSegmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCableCarrierSegmentTypeEnum
}())
exports.IfcCableCarrierSegmentTypeEnum = IfcCableCarrierSegmentTypeEnum

const IfcCableFittingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCableFittingTypeEnum(v) {
    this.value = v
  }
  IfcCableFittingTypeEnum.CONNECTOR = 'CONNECTOR'
  IfcCableFittingTypeEnum.ENTRY = 'ENTRY'
  IfcCableFittingTypeEnum.EXIT = 'EXIT'
  IfcCableFittingTypeEnum.JUNCTION = 'JUNCTION'
  IfcCableFittingTypeEnum.TRANSITION = 'TRANSITION'
  IfcCableFittingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCableFittingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCableFittingTypeEnum
}())
exports.IfcCableFittingTypeEnum = IfcCableFittingTypeEnum

const IfcCableSegmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCableSegmentTypeEnum(v) {
    this.value = v
  }
  IfcCableSegmentTypeEnum.BUSBARSEGMENT = 'BUSBARSEGMENT'
  IfcCableSegmentTypeEnum.CABLESEGMENT = 'CABLESEGMENT'
  IfcCableSegmentTypeEnum.CONDUCTORSEGMENT = 'CONDUCTORSEGMENT'
  IfcCableSegmentTypeEnum.CORESEGMENT = 'CORESEGMENT'
  IfcCableSegmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCableSegmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCableSegmentTypeEnum
}())
exports.IfcCableSegmentTypeEnum = IfcCableSegmentTypeEnum

const IfcCaissonFoundationTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCaissonFoundationTypeEnum(v) {
    this.value = v
  }
  IfcCaissonFoundationTypeEnum.WELL = 'WELL'
  IfcCaissonFoundationTypeEnum.CAISSON = 'CAISSON'
  IfcCaissonFoundationTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCaissonFoundationTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCaissonFoundationTypeEnum
}())
exports.IfcCaissonFoundationTypeEnum = IfcCaissonFoundationTypeEnum

const IfcChangeActionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcChangeActionEnum(v) {
    this.value = v
  }
  IfcChangeActionEnum.NOCHANGE = 'NOCHANGE'
  IfcChangeActionEnum.MODIFIED = 'MODIFIED'
  IfcChangeActionEnum.ADDED = 'ADDED'
  IfcChangeActionEnum.DELETED = 'DELETED'
  IfcChangeActionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcChangeActionEnum
}())
exports.IfcChangeActionEnum = IfcChangeActionEnum

const IfcChillerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcChillerTypeEnum(v) {
    this.value = v
  }
  IfcChillerTypeEnum.AIRCOOLED = 'AIRCOOLED'
  IfcChillerTypeEnum.WATERCOOLED = 'WATERCOOLED'
  IfcChillerTypeEnum.HEATRECOVERY = 'HEATRECOVERY'
  IfcChillerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcChillerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcChillerTypeEnum
}())
exports.IfcChillerTypeEnum = IfcChillerTypeEnum

const IfcChimneyTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcChimneyTypeEnum(v) {
    this.value = v
  }
  IfcChimneyTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcChimneyTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcChimneyTypeEnum
}())
exports.IfcChimneyTypeEnum = IfcChimneyTypeEnum

const IfcCoilTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCoilTypeEnum(v) {
    this.value = v
  }
  IfcCoilTypeEnum.DXCOOLINGCOIL = 'DXCOOLINGCOIL'
  IfcCoilTypeEnum.ELECTRICHEATINGCOIL = 'ELECTRICHEATINGCOIL'
  IfcCoilTypeEnum.GASHEATINGCOIL = 'GASHEATINGCOIL'
  IfcCoilTypeEnum.HYDRONICCOIL = 'HYDRONICCOIL'
  IfcCoilTypeEnum.STEAMHEATINGCOIL = 'STEAMHEATINGCOIL'
  IfcCoilTypeEnum.WATERCOOLINGCOIL = 'WATERCOOLINGCOIL'
  IfcCoilTypeEnum.WATERHEATINGCOIL = 'WATERHEATINGCOIL'
  IfcCoilTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCoilTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCoilTypeEnum
}())
exports.IfcCoilTypeEnum = IfcCoilTypeEnum

const IfcColumnTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcColumnTypeEnum(v) {
    this.value = v
  }
  IfcColumnTypeEnum.COLUMN = 'COLUMN'
  IfcColumnTypeEnum.PILASTER = 'PILASTER'
  IfcColumnTypeEnum.PIERSTEM = 'PIERSTEM'
  IfcColumnTypeEnum.PIERSTEM_SEGMENT = 'PIERSTEM_SEGMENT'
  IfcColumnTypeEnum.STANDCOLUMN = 'STANDCOLUMN'
  IfcColumnTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcColumnTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcColumnTypeEnum
}())
exports.IfcColumnTypeEnum = IfcColumnTypeEnum

const IfcCommunicationsApplianceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCommunicationsApplianceTypeEnum(v) {
    this.value = v
  }
  IfcCommunicationsApplianceTypeEnum.ANTENNA = 'ANTENNA'
  IfcCommunicationsApplianceTypeEnum.COMPUTER = 'COMPUTER'
  IfcCommunicationsApplianceTypeEnum.FAX = 'FAX'
  IfcCommunicationsApplianceTypeEnum.GATEWAY = 'GATEWAY'
  IfcCommunicationsApplianceTypeEnum.MODEM = 'MODEM'
  IfcCommunicationsApplianceTypeEnum.NETWORKAPPLIANCE = 'NETWORKAPPLIANCE'
  IfcCommunicationsApplianceTypeEnum.NETWORKBRIDGE = 'NETWORKBRIDGE'
  IfcCommunicationsApplianceTypeEnum.NETWORKHUB = 'NETWORKHUB'
  IfcCommunicationsApplianceTypeEnum.PRINTER = 'PRINTER'
  IfcCommunicationsApplianceTypeEnum.REPEATER = 'REPEATER'
  IfcCommunicationsApplianceTypeEnum.ROUTER = 'ROUTER'
  IfcCommunicationsApplianceTypeEnum.SCANNER = 'SCANNER'
  IfcCommunicationsApplianceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCommunicationsApplianceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCommunicationsApplianceTypeEnum
}())
exports.IfcCommunicationsApplianceTypeEnum = IfcCommunicationsApplianceTypeEnum

const IfcComplexPropertyTemplateTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcComplexPropertyTemplateTypeEnum(v) {
    this.value = v
  }
  IfcComplexPropertyTemplateTypeEnum.P_COMPLEX = 'P_COMPLEX'
  IfcComplexPropertyTemplateTypeEnum.Q_COMPLEX = 'Q_COMPLEX'
  return IfcComplexPropertyTemplateTypeEnum
}())
exports.IfcComplexPropertyTemplateTypeEnum = IfcComplexPropertyTemplateTypeEnum

const IfcCompressorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCompressorTypeEnum(v) {
    this.value = v
  }
  IfcCompressorTypeEnum.DYNAMIC = 'DYNAMIC'
  IfcCompressorTypeEnum.RECIPROCATING = 'RECIPROCATING'
  IfcCompressorTypeEnum.ROTARY = 'ROTARY'
  IfcCompressorTypeEnum.SCROLL = 'SCROLL'
  IfcCompressorTypeEnum.TROCHOIDAL = 'TROCHOIDAL'
  IfcCompressorTypeEnum.SINGLESTAGE = 'SINGLESTAGE'
  IfcCompressorTypeEnum.BOOSTER = 'BOOSTER'
  IfcCompressorTypeEnum.OPENTYPE = 'OPENTYPE'
  IfcCompressorTypeEnum.HERMETIC = 'HERMETIC'
  IfcCompressorTypeEnum.SEMIHERMETIC = 'SEMIHERMETIC'
  IfcCompressorTypeEnum.WELDEDSHELLHERMETIC = 'WELDEDSHELLHERMETIC'
  IfcCompressorTypeEnum.ROLLINGPISTON = 'ROLLINGPISTON'
  IfcCompressorTypeEnum.ROTARYVANE = 'ROTARYVANE'
  IfcCompressorTypeEnum.SINGLESCREW = 'SINGLESCREW'
  IfcCompressorTypeEnum.TWINSCREW = 'TWINSCREW'
  IfcCompressorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCompressorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCompressorTypeEnum
}())
exports.IfcCompressorTypeEnum = IfcCompressorTypeEnum

const IfcCondenserTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCondenserTypeEnum(v) {
    this.value = v
  }
  IfcCondenserTypeEnum.AIRCOOLED = 'AIRCOOLED'
  IfcCondenserTypeEnum.EVAPORATIVECOOLED = 'EVAPORATIVECOOLED'
  IfcCondenserTypeEnum.WATERCOOLED = 'WATERCOOLED'
  IfcCondenserTypeEnum.WATERCOOLEDBRAZEDPLATE = 'WATERCOOLEDBRAZEDPLATE'
  IfcCondenserTypeEnum.WATERCOOLEDSHELLCOIL = 'WATERCOOLEDSHELLCOIL'
  IfcCondenserTypeEnum.WATERCOOLEDSHELLTUBE = 'WATERCOOLEDSHELLTUBE'
  IfcCondenserTypeEnum.WATERCOOLEDTUBEINTUBE = 'WATERCOOLEDTUBEINTUBE'
  IfcCondenserTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCondenserTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCondenserTypeEnum
}())
exports.IfcCondenserTypeEnum = IfcCondenserTypeEnum

const IfcConnectionTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionTypeEnum(v) {
    this.value = v
  }
  IfcConnectionTypeEnum.ATPATH = 'ATPATH'
  IfcConnectionTypeEnum.ATSTART = 'ATSTART'
  IfcConnectionTypeEnum.ATEND = 'ATEND'
  IfcConnectionTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcConnectionTypeEnum
}())
exports.IfcConnectionTypeEnum = IfcConnectionTypeEnum

const IfcConstraintEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcConstraintEnum(v) {
    this.value = v
  }
  IfcConstraintEnum.HARD = 'HARD'
  IfcConstraintEnum.SOFT = 'SOFT'
  IfcConstraintEnum.ADVISORY = 'ADVISORY'
  IfcConstraintEnum.USERDEFINED = 'USERDEFINED'
  IfcConstraintEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcConstraintEnum
}())
exports.IfcConstraintEnum = IfcConstraintEnum

const IfcConstructionEquipmentResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionEquipmentResourceTypeEnum(v) {
    this.value = v
  }
  IfcConstructionEquipmentResourceTypeEnum.DEMOLISHING = 'DEMOLISHING'
  IfcConstructionEquipmentResourceTypeEnum.EARTHMOVING = 'EARTHMOVING'
  IfcConstructionEquipmentResourceTypeEnum.ERECTING = 'ERECTING'
  IfcConstructionEquipmentResourceTypeEnum.HEATING = 'HEATING'
  IfcConstructionEquipmentResourceTypeEnum.LIGHTING = 'LIGHTING'
  IfcConstructionEquipmentResourceTypeEnum.PAVING = 'PAVING'
  IfcConstructionEquipmentResourceTypeEnum.PUMPING = 'PUMPING'
  IfcConstructionEquipmentResourceTypeEnum.TRANSPORTING = 'TRANSPORTING'
  IfcConstructionEquipmentResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcConstructionEquipmentResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcConstructionEquipmentResourceTypeEnum
}())
exports.IfcConstructionEquipmentResourceTypeEnum = IfcConstructionEquipmentResourceTypeEnum

const IfcConstructionMaterialResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionMaterialResourceTypeEnum(v) {
    this.value = v
  }
  IfcConstructionMaterialResourceTypeEnum.AGGREGATES = 'AGGREGATES'
  IfcConstructionMaterialResourceTypeEnum.CONCRETE = 'CONCRETE'
  IfcConstructionMaterialResourceTypeEnum.DRYWALL = 'DRYWALL'
  IfcConstructionMaterialResourceTypeEnum.FUEL = 'FUEL'
  IfcConstructionMaterialResourceTypeEnum.GYPSUM = 'GYPSUM'
  IfcConstructionMaterialResourceTypeEnum.MASONRY = 'MASONRY'
  IfcConstructionMaterialResourceTypeEnum.METAL = 'METAL'
  IfcConstructionMaterialResourceTypeEnum.PLASTIC = 'PLASTIC'
  IfcConstructionMaterialResourceTypeEnum.WOOD = 'WOOD'
  IfcConstructionMaterialResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  IfcConstructionMaterialResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  return IfcConstructionMaterialResourceTypeEnum
}())
exports.IfcConstructionMaterialResourceTypeEnum = IfcConstructionMaterialResourceTypeEnum

const IfcConstructionProductResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionProductResourceTypeEnum(v) {
    this.value = v
  }
  IfcConstructionProductResourceTypeEnum.ASSEMBLY = 'ASSEMBLY'
  IfcConstructionProductResourceTypeEnum.FORMWORK = 'FORMWORK'
  IfcConstructionProductResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcConstructionProductResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcConstructionProductResourceTypeEnum
}())
exports.IfcConstructionProductResourceTypeEnum = IfcConstructionProductResourceTypeEnum

const IfcControllerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcControllerTypeEnum(v) {
    this.value = v
  }
  IfcControllerTypeEnum.FLOATING = 'FLOATING'
  IfcControllerTypeEnum.PROGRAMMABLE = 'PROGRAMMABLE'
  IfcControllerTypeEnum.PROPORTIONAL = 'PROPORTIONAL'
  IfcControllerTypeEnum.MULTIPOSITION = 'MULTIPOSITION'
  IfcControllerTypeEnum.TWOPOSITION = 'TWOPOSITION'
  IfcControllerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcControllerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcControllerTypeEnum
}())
exports.IfcControllerTypeEnum = IfcControllerTypeEnum

const IfcCooledBeamTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCooledBeamTypeEnum(v) {
    this.value = v
  }
  IfcCooledBeamTypeEnum.ACTIVE = 'ACTIVE'
  IfcCooledBeamTypeEnum.PASSIVE = 'PASSIVE'
  IfcCooledBeamTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCooledBeamTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCooledBeamTypeEnum
}())
exports.IfcCooledBeamTypeEnum = IfcCooledBeamTypeEnum

const IfcCoolingTowerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCoolingTowerTypeEnum(v) {
    this.value = v
  }
  IfcCoolingTowerTypeEnum.NATURALDRAFT = 'NATURALDRAFT'
  IfcCoolingTowerTypeEnum.MECHANICALINDUCEDDRAFT = 'MECHANICALINDUCEDDRAFT'
  IfcCoolingTowerTypeEnum.MECHANICALFORCEDDRAFT = 'MECHANICALFORCEDDRAFT'
  IfcCoolingTowerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCoolingTowerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCoolingTowerTypeEnum
}())
exports.IfcCoolingTowerTypeEnum = IfcCoolingTowerTypeEnum

const IfcCostItemTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCostItemTypeEnum(v) {
    this.value = v
  }
  IfcCostItemTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCostItemTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCostItemTypeEnum
}())
exports.IfcCostItemTypeEnum = IfcCostItemTypeEnum

const IfcCostScheduleTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCostScheduleTypeEnum(v) {
    this.value = v
  }
  IfcCostScheduleTypeEnum.BUDGET = 'BUDGET'
  IfcCostScheduleTypeEnum.COSTPLAN = 'COSTPLAN'
  IfcCostScheduleTypeEnum.ESTIMATE = 'ESTIMATE'
  IfcCostScheduleTypeEnum.TENDER = 'TENDER'
  IfcCostScheduleTypeEnum.PRICEDBILLOFQUANTITIES = 'PRICEDBILLOFQUANTITIES'
  IfcCostScheduleTypeEnum.UNPRICEDBILLOFQUANTITIES = 'UNPRICEDBILLOFQUANTITIES'
  IfcCostScheduleTypeEnum.SCHEDULEOFRATES = 'SCHEDULEOFRATES'
  IfcCostScheduleTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCostScheduleTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCostScheduleTypeEnum
}())
exports.IfcCostScheduleTypeEnum = IfcCostScheduleTypeEnum

const IfcCoveringTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCoveringTypeEnum(v) {
    this.value = v
  }
  IfcCoveringTypeEnum.CEILING = 'CEILING'
  IfcCoveringTypeEnum.FLOORING = 'FLOORING'
  IfcCoveringTypeEnum.CLADDING = 'CLADDING'
  IfcCoveringTypeEnum.ROOFING = 'ROOFING'
  IfcCoveringTypeEnum.MOLDING = 'MOLDING'
  IfcCoveringTypeEnum.SKIRTINGBOARD = 'SKIRTINGBOARD'
  IfcCoveringTypeEnum.INSULATION = 'INSULATION'
  IfcCoveringTypeEnum.MEMBRANE = 'MEMBRANE'
  IfcCoveringTypeEnum.SLEEVING = 'SLEEVING'
  IfcCoveringTypeEnum.WRAPPING = 'WRAPPING'
  IfcCoveringTypeEnum.COPING = 'COPING'
  IfcCoveringTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCoveringTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCoveringTypeEnum
}())
exports.IfcCoveringTypeEnum = IfcCoveringTypeEnum

const IfcCrewResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCrewResourceTypeEnum(v) {
    this.value = v
  }
  IfcCrewResourceTypeEnum.OFFICE = 'OFFICE'
  IfcCrewResourceTypeEnum.SITE = 'SITE'
  IfcCrewResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCrewResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCrewResourceTypeEnum
}())
exports.IfcCrewResourceTypeEnum = IfcCrewResourceTypeEnum

const IfcCurtainWallTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCurtainWallTypeEnum(v) {
    this.value = v
  }
  IfcCurtainWallTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcCurtainWallTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCurtainWallTypeEnum
}())
exports.IfcCurtainWallTypeEnum = IfcCurtainWallTypeEnum

const IfcCurveInterpolationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveInterpolationEnum(v) {
    this.value = v
  }
  IfcCurveInterpolationEnum.LINEAR = 'LINEAR'
  IfcCurveInterpolationEnum.LOG_LINEAR = 'LOG_LINEAR'
  IfcCurveInterpolationEnum.LOG_LOG = 'LOG_LOG'
  IfcCurveInterpolationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcCurveInterpolationEnum
}())
exports.IfcCurveInterpolationEnum = IfcCurveInterpolationEnum

const IfcDamperTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDamperTypeEnum(v) {
    this.value = v
  }
  IfcDamperTypeEnum.BACKDRAFTDAMPER = 'BACKDRAFTDAMPER'
  IfcDamperTypeEnum.BALANCINGDAMPER = 'BALANCINGDAMPER'
  IfcDamperTypeEnum.BLASTDAMPER = 'BLASTDAMPER'
  IfcDamperTypeEnum.CONTROLDAMPER = 'CONTROLDAMPER'
  IfcDamperTypeEnum.FIREDAMPER = 'FIREDAMPER'
  IfcDamperTypeEnum.FIRESMOKEDAMPER = 'FIRESMOKEDAMPER'
  IfcDamperTypeEnum.FUMEHOODEXHAUST = 'FUMEHOODEXHAUST'
  IfcDamperTypeEnum.GRAVITYDAMPER = 'GRAVITYDAMPER'
  IfcDamperTypeEnum.GRAVITYRELIEFDAMPER = 'GRAVITYRELIEFDAMPER'
  IfcDamperTypeEnum.RELIEFDAMPER = 'RELIEFDAMPER'
  IfcDamperTypeEnum.SMOKEDAMPER = 'SMOKEDAMPER'
  IfcDamperTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDamperTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDamperTypeEnum
}())
exports.IfcDamperTypeEnum = IfcDamperTypeEnum

const IfcDataOriginEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDataOriginEnum(v) {
    this.value = v
  }
  IfcDataOriginEnum.MEASURED = 'MEASURED'
  IfcDataOriginEnum.PREDICTED = 'PREDICTED'
  IfcDataOriginEnum.SIMULATED = 'SIMULATED'
  IfcDataOriginEnum.USERDEFINED = 'USERDEFINED'
  IfcDataOriginEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDataOriginEnum
}())
exports.IfcDataOriginEnum = IfcDataOriginEnum

const IfcDerivedUnitEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDerivedUnitEnum(v) {
    this.value = v
  }
  IfcDerivedUnitEnum.ANGULARVELOCITYUNIT = 'ANGULARVELOCITYUNIT'
  IfcDerivedUnitEnum.AREADENSITYUNIT = 'AREADENSITYUNIT'
  IfcDerivedUnitEnum.COMPOUNDPLANEANGLEUNIT = 'COMPOUNDPLANEANGLEUNIT'
  IfcDerivedUnitEnum.DYNAMICVISCOSITYUNIT = 'DYNAMICVISCOSITYUNIT'
  IfcDerivedUnitEnum.HEATFLUXDENSITYUNIT = 'HEATFLUXDENSITYUNIT'
  IfcDerivedUnitEnum.INTEGERCOUNTRATEUNIT = 'INTEGERCOUNTRATEUNIT'
  IfcDerivedUnitEnum.ISOTHERMALMOISTURECAPACITYUNIT = 'ISOTHERMALMOISTURECAPACITYUNIT'
  IfcDerivedUnitEnum.KINEMATICVISCOSITYUNIT = 'KINEMATICVISCOSITYUNIT'
  IfcDerivedUnitEnum.LINEARVELOCITYUNIT = 'LINEARVELOCITYUNIT'
  IfcDerivedUnitEnum.MASSDENSITYUNIT = 'MASSDENSITYUNIT'
  IfcDerivedUnitEnum.MASSFLOWRATEUNIT = 'MASSFLOWRATEUNIT'
  IfcDerivedUnitEnum.MOISTUREDIFFUSIVITYUNIT = 'MOISTUREDIFFUSIVITYUNIT'
  IfcDerivedUnitEnum.MOLECULARWEIGHTUNIT = 'MOLECULARWEIGHTUNIT'
  IfcDerivedUnitEnum.SPECIFICHEATCAPACITYUNIT = 'SPECIFICHEATCAPACITYUNIT'
  IfcDerivedUnitEnum.THERMALADMITTANCEUNIT = 'THERMALADMITTANCEUNIT'
  IfcDerivedUnitEnum.THERMALCONDUCTANCEUNIT = 'THERMALCONDUCTANCEUNIT'
  IfcDerivedUnitEnum.THERMALRESISTANCEUNIT = 'THERMALRESISTANCEUNIT'
  IfcDerivedUnitEnum.THERMALTRANSMITTANCEUNIT = 'THERMALTRANSMITTANCEUNIT'
  IfcDerivedUnitEnum.VAPORPERMEABILITYUNIT = 'VAPORPERMEABILITYUNIT'
  IfcDerivedUnitEnum.VOLUMETRICFLOWRATEUNIT = 'VOLUMETRICFLOWRATEUNIT'
  IfcDerivedUnitEnum.ROTATIONALFREQUENCYUNIT = 'ROTATIONALFREQUENCYUNIT'
  IfcDerivedUnitEnum.TORQUEUNIT = 'TORQUEUNIT'
  IfcDerivedUnitEnum.MOMENTOFINERTIAUNIT = 'MOMENTOFINERTIAUNIT'
  IfcDerivedUnitEnum.LINEARMOMENTUNIT = 'LINEARMOMENTUNIT'
  IfcDerivedUnitEnum.LINEARFORCEUNIT = 'LINEARFORCEUNIT'
  IfcDerivedUnitEnum.PLANARFORCEUNIT = 'PLANARFORCEUNIT'
  IfcDerivedUnitEnum.MODULUSOFELASTICITYUNIT = 'MODULUSOFELASTICITYUNIT'
  IfcDerivedUnitEnum.SHEARMODULUSUNIT = 'SHEARMODULUSUNIT'
  IfcDerivedUnitEnum.LINEARSTIFFNESSUNIT = 'LINEARSTIFFNESSUNIT'
  IfcDerivedUnitEnum.ROTATIONALSTIFFNESSUNIT = 'ROTATIONALSTIFFNESSUNIT'
  IfcDerivedUnitEnum.MODULUSOFSUBGRADEREACTIONUNIT = 'MODULUSOFSUBGRADEREACTIONUNIT'
  IfcDerivedUnitEnum.ACCELERATIONUNIT = 'ACCELERATIONUNIT'
  IfcDerivedUnitEnum.CURVATUREUNIT = 'CURVATUREUNIT'
  IfcDerivedUnitEnum.HEATINGVALUEUNIT = 'HEATINGVALUEUNIT'
  IfcDerivedUnitEnum.IONCONCENTRATIONUNIT = 'IONCONCENTRATIONUNIT'
  IfcDerivedUnitEnum.LUMINOUSINTENSITYDISTRIBUTIONUNIT = 'LUMINOUSINTENSITYDISTRIBUTIONUNIT'
  IfcDerivedUnitEnum.MASSPERLENGTHUNIT = 'MASSPERLENGTHUNIT'
  IfcDerivedUnitEnum.MODULUSOFLINEARSUBGRADEREACTIONUNIT = 'MODULUSOFLINEARSUBGRADEREACTIONUNIT'
  IfcDerivedUnitEnum.MODULUSOFROTATIONALSUBGRADEREACTIONUNIT = 'MODULUSOFROTATIONALSUBGRADEREACTIONUNIT'
  IfcDerivedUnitEnum.PHUNIT = 'PHUNIT'
  IfcDerivedUnitEnum.ROTATIONALMASSUNIT = 'ROTATIONALMASSUNIT'
  IfcDerivedUnitEnum.SECTIONAREAINTEGRALUNIT = 'SECTIONAREAINTEGRALUNIT'
  IfcDerivedUnitEnum.SECTIONMODULUSUNIT = 'SECTIONMODULUSUNIT'
  IfcDerivedUnitEnum.SOUNDPOWERLEVELUNIT = 'SOUNDPOWERLEVELUNIT'
  IfcDerivedUnitEnum.SOUNDPOWERUNIT = 'SOUNDPOWERUNIT'
  IfcDerivedUnitEnum.SOUNDPRESSURELEVELUNIT = 'SOUNDPRESSURELEVELUNIT'
  IfcDerivedUnitEnum.SOUNDPRESSUREUNIT = 'SOUNDPRESSUREUNIT'
  IfcDerivedUnitEnum.TEMPERATUREGRADIENTUNIT = 'TEMPERATUREGRADIENTUNIT'
  IfcDerivedUnitEnum.TEMPERATURERATEOFCHANGEUNIT = 'TEMPERATURERATEOFCHANGEUNIT'
  IfcDerivedUnitEnum.THERMALEXPANSIONCOEFFICIENTUNIT = 'THERMALEXPANSIONCOEFFICIENTUNIT'
  IfcDerivedUnitEnum.WARPINGCONSTANTUNIT = 'WARPINGCONSTANTUNIT'
  IfcDerivedUnitEnum.WARPINGMOMENTUNIT = 'WARPINGMOMENTUNIT'
  IfcDerivedUnitEnum.USERDEFINED = 'USERDEFINED'
  return IfcDerivedUnitEnum
}())
exports.IfcDerivedUnitEnum = IfcDerivedUnitEnum

const IfcDirectionSenseEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDirectionSenseEnum(v) {
    this.value = v
  }
  IfcDirectionSenseEnum.POSITIVE = 'POSITIVE'
  IfcDirectionSenseEnum.NEGATIVE = 'NEGATIVE'
  return IfcDirectionSenseEnum
}())
exports.IfcDirectionSenseEnum = IfcDirectionSenseEnum

const IfcDiscreteAccessoryTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDiscreteAccessoryTypeEnum(v) {
    this.value = v
  }
  IfcDiscreteAccessoryTypeEnum.ANCHORPLATE = 'ANCHORPLATE'
  IfcDiscreteAccessoryTypeEnum.BRACKET = 'BRACKET'
  IfcDiscreteAccessoryTypeEnum.SHOE = 'SHOE'
  IfcDiscreteAccessoryTypeEnum.EXPANSION_JOINT_DEVICE = 'EXPANSION_JOINT_DEVICE'
  IfcDiscreteAccessoryTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDiscreteAccessoryTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDiscreteAccessoryTypeEnum
}())
exports.IfcDiscreteAccessoryTypeEnum = IfcDiscreteAccessoryTypeEnum

const IfcDistributionChamberElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionChamberElementTypeEnum(v) {
    this.value = v
  }
  IfcDistributionChamberElementTypeEnum.FORMEDDUCT = 'FORMEDDUCT'
  IfcDistributionChamberElementTypeEnum.INSPECTIONCHAMBER = 'INSPECTIONCHAMBER'
  IfcDistributionChamberElementTypeEnum.INSPECTIONPIT = 'INSPECTIONPIT'
  IfcDistributionChamberElementTypeEnum.MANHOLE = 'MANHOLE'
  IfcDistributionChamberElementTypeEnum.METERCHAMBER = 'METERCHAMBER'
  IfcDistributionChamberElementTypeEnum.SUMP = 'SUMP'
  IfcDistributionChamberElementTypeEnum.TRENCH = 'TRENCH'
  IfcDistributionChamberElementTypeEnum.VALVECHAMBER = 'VALVECHAMBER'
  IfcDistributionChamberElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDistributionChamberElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDistributionChamberElementTypeEnum
}())
exports.IfcDistributionChamberElementTypeEnum = IfcDistributionChamberElementTypeEnum

const IfcDistributionPortTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionPortTypeEnum(v) {
    this.value = v
  }
  IfcDistributionPortTypeEnum.CABLE = 'CABLE'
  IfcDistributionPortTypeEnum.CABLECARRIER = 'CABLECARRIER'
  IfcDistributionPortTypeEnum.DUCT = 'DUCT'
  IfcDistributionPortTypeEnum.PIPE = 'PIPE'
  IfcDistributionPortTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDistributionPortTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDistributionPortTypeEnum
}())
exports.IfcDistributionPortTypeEnum = IfcDistributionPortTypeEnum

const IfcDistributionSystemEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionSystemEnum(v) {
    this.value = v
  }
  IfcDistributionSystemEnum.AIRCONDITIONING = 'AIRCONDITIONING'
  IfcDistributionSystemEnum.AUDIOVISUAL = 'AUDIOVISUAL'
  IfcDistributionSystemEnum.CHEMICAL = 'CHEMICAL'
  IfcDistributionSystemEnum.CHILLEDWATER = 'CHILLEDWATER'
  IfcDistributionSystemEnum.COMMUNICATION = 'COMMUNICATION'
  IfcDistributionSystemEnum.COMPRESSEDAIR = 'COMPRESSEDAIR'
  IfcDistributionSystemEnum.CONDENSERWATER = 'CONDENSERWATER'
  IfcDistributionSystemEnum.CONTROL = 'CONTROL'
  IfcDistributionSystemEnum.CONVEYING = 'CONVEYING'
  IfcDistributionSystemEnum.DATA = 'DATA'
  IfcDistributionSystemEnum.DISPOSAL = 'DISPOSAL'
  IfcDistributionSystemEnum.DOMESTICCOLDWATER = 'DOMESTICCOLDWATER'
  IfcDistributionSystemEnum.DOMESTICHOTWATER = 'DOMESTICHOTWATER'
  IfcDistributionSystemEnum.DRAINAGE = 'DRAINAGE'
  IfcDistributionSystemEnum.EARTHING = 'EARTHING'
  IfcDistributionSystemEnum.ELECTRICAL = 'ELECTRICAL'
  IfcDistributionSystemEnum.ELECTROACOUSTIC = 'ELECTROACOUSTIC'
  IfcDistributionSystemEnum.EXHAUST = 'EXHAUST'
  IfcDistributionSystemEnum.FIREPROTECTION = 'FIREPROTECTION'
  IfcDistributionSystemEnum.FUEL = 'FUEL'
  IfcDistributionSystemEnum.GAS = 'GAS'
  IfcDistributionSystemEnum.HAZARDOUS = 'HAZARDOUS'
  IfcDistributionSystemEnum.HEATING = 'HEATING'
  IfcDistributionSystemEnum.LIGHTING = 'LIGHTING'
  IfcDistributionSystemEnum.LIGHTNINGPROTECTION = 'LIGHTNINGPROTECTION'
  IfcDistributionSystemEnum.MUNICIPALSOLIDWASTE = 'MUNICIPALSOLIDWASTE'
  IfcDistributionSystemEnum.OIL = 'OIL'
  IfcDistributionSystemEnum.OPERATIONAL = 'OPERATIONAL'
  IfcDistributionSystemEnum.POWERGENERATION = 'POWERGENERATION'
  IfcDistributionSystemEnum.RAINWATER = 'RAINWATER'
  IfcDistributionSystemEnum.REFRIGERATION = 'REFRIGERATION'
  IfcDistributionSystemEnum.SECURITY = 'SECURITY'
  IfcDistributionSystemEnum.SEWAGE = 'SEWAGE'
  IfcDistributionSystemEnum.SIGNAL = 'SIGNAL'
  IfcDistributionSystemEnum.STORMWATER = 'STORMWATER'
  IfcDistributionSystemEnum.TELEPHONE = 'TELEPHONE'
  IfcDistributionSystemEnum.TV = 'TV'
  IfcDistributionSystemEnum.VACUUM = 'VACUUM'
  IfcDistributionSystemEnum.VENT = 'VENT'
  IfcDistributionSystemEnum.VENTILATION = 'VENTILATION'
  IfcDistributionSystemEnum.WASTEWATER = 'WASTEWATER'
  IfcDistributionSystemEnum.WATERSUPPLY = 'WATERSUPPLY'
  IfcDistributionSystemEnum.USERDEFINED = 'USERDEFINED'
  IfcDistributionSystemEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDistributionSystemEnum
}())
exports.IfcDistributionSystemEnum = IfcDistributionSystemEnum

const IfcDocumentConfidentialityEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDocumentConfidentialityEnum(v) {
    this.value = v
  }
  IfcDocumentConfidentialityEnum.PUBLIC = 'PUBLIC'
  IfcDocumentConfidentialityEnum.RESTRICTED = 'RESTRICTED'
  IfcDocumentConfidentialityEnum.CONFIDENTIAL = 'CONFIDENTIAL'
  IfcDocumentConfidentialityEnum.PERSONAL = 'PERSONAL'
  IfcDocumentConfidentialityEnum.USERDEFINED = 'USERDEFINED'
  IfcDocumentConfidentialityEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDocumentConfidentialityEnum
}())
exports.IfcDocumentConfidentialityEnum = IfcDocumentConfidentialityEnum

const IfcDocumentStatusEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDocumentStatusEnum(v) {
    this.value = v
  }
  IfcDocumentStatusEnum.DRAFT = 'DRAFT'
  IfcDocumentStatusEnum.FINALDRAFT = 'FINALDRAFT'
  IfcDocumentStatusEnum.FINAL = 'FINAL'
  IfcDocumentStatusEnum.REVISION = 'REVISION'
  IfcDocumentStatusEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDocumentStatusEnum
}())
exports.IfcDocumentStatusEnum = IfcDocumentStatusEnum

const IfcDoorPanelOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorPanelOperationEnum(v) {
    this.value = v
  }
  IfcDoorPanelOperationEnum.SWINGING = 'SWINGING'
  IfcDoorPanelOperationEnum.DOUBLE_ACTING = 'DOUBLE_ACTING'
  IfcDoorPanelOperationEnum.SLIDING = 'SLIDING'
  IfcDoorPanelOperationEnum.FOLDING = 'FOLDING'
  IfcDoorPanelOperationEnum.REVOLVING = 'REVOLVING'
  IfcDoorPanelOperationEnum.ROLLINGUP = 'ROLLINGUP'
  IfcDoorPanelOperationEnum.FIXEDPANEL = 'FIXEDPANEL'
  IfcDoorPanelOperationEnum.USERDEFINED = 'USERDEFINED'
  IfcDoorPanelOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorPanelOperationEnum
}())
exports.IfcDoorPanelOperationEnum = IfcDoorPanelOperationEnum

const IfcDoorPanelPositionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorPanelPositionEnum(v) {
    this.value = v
  }
  IfcDoorPanelPositionEnum.LEFT = 'LEFT'
  IfcDoorPanelPositionEnum.MIDDLE = 'MIDDLE'
  IfcDoorPanelPositionEnum.RIGHT = 'RIGHT'
  IfcDoorPanelPositionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorPanelPositionEnum
}())
exports.IfcDoorPanelPositionEnum = IfcDoorPanelPositionEnum

const IfcDoorStyleConstructionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorStyleConstructionEnum(v) {
    this.value = v
  }
  IfcDoorStyleConstructionEnum.ALUMINIUM = 'ALUMINIUM'
  IfcDoorStyleConstructionEnum.HIGH_GRADE_STEEL = 'HIGH_GRADE_STEEL'
  IfcDoorStyleConstructionEnum.STEEL = 'STEEL'
  IfcDoorStyleConstructionEnum.WOOD = 'WOOD'
  IfcDoorStyleConstructionEnum.ALUMINIUM_WOOD = 'ALUMINIUM_WOOD'
  IfcDoorStyleConstructionEnum.ALUMINIUM_PLASTIC = 'ALUMINIUM_PLASTIC'
  IfcDoorStyleConstructionEnum.PLASTIC = 'PLASTIC'
  IfcDoorStyleConstructionEnum.USERDEFINED = 'USERDEFINED'
  IfcDoorStyleConstructionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorStyleConstructionEnum
}())
exports.IfcDoorStyleConstructionEnum = IfcDoorStyleConstructionEnum

const IfcDoorStyleOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorStyleOperationEnum(v) {
    this.value = v
  }
  IfcDoorStyleOperationEnum.SINGLE_SWING_LEFT = 'SINGLE_SWING_LEFT'
  IfcDoorStyleOperationEnum.SINGLE_SWING_RIGHT = 'SINGLE_SWING_RIGHT'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING = 'DOUBLE_DOOR_SINGLE_SWING'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = 'DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = 'DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT'
  IfcDoorStyleOperationEnum.DOUBLE_SWING_LEFT = 'DOUBLE_SWING_LEFT'
  IfcDoorStyleOperationEnum.DOUBLE_SWING_RIGHT = 'DOUBLE_SWING_RIGHT'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = 'DOUBLE_DOOR_DOUBLE_SWING'
  IfcDoorStyleOperationEnum.SLIDING_TO_LEFT = 'SLIDING_TO_LEFT'
  IfcDoorStyleOperationEnum.SLIDING_TO_RIGHT = 'SLIDING_TO_RIGHT'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SLIDING = 'DOUBLE_DOOR_SLIDING'
  IfcDoorStyleOperationEnum.FOLDING_TO_LEFT = 'FOLDING_TO_LEFT'
  IfcDoorStyleOperationEnum.FOLDING_TO_RIGHT = 'FOLDING_TO_RIGHT'
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_FOLDING = 'DOUBLE_DOOR_FOLDING'
  IfcDoorStyleOperationEnum.REVOLVING = 'REVOLVING'
  IfcDoorStyleOperationEnum.ROLLINGUP = 'ROLLINGUP'
  IfcDoorStyleOperationEnum.USERDEFINED = 'USERDEFINED'
  IfcDoorStyleOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorStyleOperationEnum
}())
exports.IfcDoorStyleOperationEnum = IfcDoorStyleOperationEnum

const IfcDoorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorTypeEnum(v) {
    this.value = v
  }
  IfcDoorTypeEnum.DOOR = 'DOOR'
  IfcDoorTypeEnum.GATE = 'GATE'
  IfcDoorTypeEnum.TRAPDOOR = 'TRAPDOOR'
  IfcDoorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDoorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorTypeEnum
}())
exports.IfcDoorTypeEnum = IfcDoorTypeEnum

const IfcDoorTypeOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorTypeOperationEnum(v) {
    this.value = v
  }
  IfcDoorTypeOperationEnum.SINGLE_SWING_LEFT = 'SINGLE_SWING_LEFT'
  IfcDoorTypeOperationEnum.SINGLE_SWING_RIGHT = 'SINGLE_SWING_RIGHT'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING = 'DOUBLE_DOOR_SINGLE_SWING'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = 'DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = 'DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT'
  IfcDoorTypeOperationEnum.DOUBLE_SWING_LEFT = 'DOUBLE_SWING_LEFT'
  IfcDoorTypeOperationEnum.DOUBLE_SWING_RIGHT = 'DOUBLE_SWING_RIGHT'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = 'DOUBLE_DOOR_DOUBLE_SWING'
  IfcDoorTypeOperationEnum.SLIDING_TO_LEFT = 'SLIDING_TO_LEFT'
  IfcDoorTypeOperationEnum.SLIDING_TO_RIGHT = 'SLIDING_TO_RIGHT'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SLIDING = 'DOUBLE_DOOR_SLIDING'
  IfcDoorTypeOperationEnum.FOLDING_TO_LEFT = 'FOLDING_TO_LEFT'
  IfcDoorTypeOperationEnum.FOLDING_TO_RIGHT = 'FOLDING_TO_RIGHT'
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_FOLDING = 'DOUBLE_DOOR_FOLDING'
  IfcDoorTypeOperationEnum.REVOLVING = 'REVOLVING'
  IfcDoorTypeOperationEnum.ROLLINGUP = 'ROLLINGUP'
  IfcDoorTypeOperationEnum.SWING_FIXED_LEFT = 'SWING_FIXED_LEFT'
  IfcDoorTypeOperationEnum.SWING_FIXED_RIGHT = 'SWING_FIXED_RIGHT'
  IfcDoorTypeOperationEnum.USERDEFINED = 'USERDEFINED'
  IfcDoorTypeOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDoorTypeOperationEnum
}())
exports.IfcDoorTypeOperationEnum = IfcDoorTypeOperationEnum

const IfcDuctFittingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctFittingTypeEnum(v) {
    this.value = v
  }
  IfcDuctFittingTypeEnum.BEND = 'BEND'
  IfcDuctFittingTypeEnum.CONNECTOR = 'CONNECTOR'
  IfcDuctFittingTypeEnum.ENTRY = 'ENTRY'
  IfcDuctFittingTypeEnum.EXIT = 'EXIT'
  IfcDuctFittingTypeEnum.JUNCTION = 'JUNCTION'
  IfcDuctFittingTypeEnum.OBSTRUCTION = 'OBSTRUCTION'
  IfcDuctFittingTypeEnum.TRANSITION = 'TRANSITION'
  IfcDuctFittingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDuctFittingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDuctFittingTypeEnum
}())
exports.IfcDuctFittingTypeEnum = IfcDuctFittingTypeEnum

const IfcDuctSegmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSegmentTypeEnum(v) {
    this.value = v
  }
  IfcDuctSegmentTypeEnum.RIGIDSEGMENT = 'RIGIDSEGMENT'
  IfcDuctSegmentTypeEnum.FLEXIBLESEGMENT = 'FLEXIBLESEGMENT'
  IfcDuctSegmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDuctSegmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDuctSegmentTypeEnum
}())
exports.IfcDuctSegmentTypeEnum = IfcDuctSegmentTypeEnum

const IfcDuctSilencerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSilencerTypeEnum(v) {
    this.value = v
  }
  IfcDuctSilencerTypeEnum.FLATOVAL = 'FLATOVAL'
  IfcDuctSilencerTypeEnum.RECTANGULAR = 'RECTANGULAR'
  IfcDuctSilencerTypeEnum.ROUND = 'ROUND'
  IfcDuctSilencerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcDuctSilencerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcDuctSilencerTypeEnum
}())
exports.IfcDuctSilencerTypeEnum = IfcDuctSilencerTypeEnum

const IfcElectricApplianceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricApplianceTypeEnum(v) {
    this.value = v
  }
  IfcElectricApplianceTypeEnum.DISHWASHER = 'DISHWASHER'
  IfcElectricApplianceTypeEnum.ELECTRICCOOKER = 'ELECTRICCOOKER'
  IfcElectricApplianceTypeEnum.FREESTANDINGELECTRICHEATER = 'FREESTANDINGELECTRICHEATER'
  IfcElectricApplianceTypeEnum.FREESTANDINGFAN = 'FREESTANDINGFAN'
  IfcElectricApplianceTypeEnum.FREESTANDINGWATERHEATER = 'FREESTANDINGWATERHEATER'
  IfcElectricApplianceTypeEnum.FREESTANDINGWATERCOOLER = 'FREESTANDINGWATERCOOLER'
  IfcElectricApplianceTypeEnum.FREEZER = 'FREEZER'
  IfcElectricApplianceTypeEnum.FRIDGE_FREEZER = 'FRIDGE_FREEZER'
  IfcElectricApplianceTypeEnum.HANDDRYER = 'HANDDRYER'
  IfcElectricApplianceTypeEnum.KITCHENMACHINE = 'KITCHENMACHINE'
  IfcElectricApplianceTypeEnum.MICROWAVE = 'MICROWAVE'
  IfcElectricApplianceTypeEnum.PHOTOCOPIER = 'PHOTOCOPIER'
  IfcElectricApplianceTypeEnum.REFRIGERATOR = 'REFRIGERATOR'
  IfcElectricApplianceTypeEnum.TUMBLEDRYER = 'TUMBLEDRYER'
  IfcElectricApplianceTypeEnum.VENDINGMACHINE = 'VENDINGMACHINE'
  IfcElectricApplianceTypeEnum.WASHINGMACHINE = 'WASHINGMACHINE'
  IfcElectricApplianceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricApplianceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricApplianceTypeEnum
}())
exports.IfcElectricApplianceTypeEnum = IfcElectricApplianceTypeEnum

const IfcElectricDistributionBoardTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricDistributionBoardTypeEnum(v) {
    this.value = v
  }
  IfcElectricDistributionBoardTypeEnum.CONSUMERUNIT = 'CONSUMERUNIT'
  IfcElectricDistributionBoardTypeEnum.DISTRIBUTIONBOARD = 'DISTRIBUTIONBOARD'
  IfcElectricDistributionBoardTypeEnum.MOTORCONTROLCENTRE = 'MOTORCONTROLCENTRE'
  IfcElectricDistributionBoardTypeEnum.SWITCHBOARD = 'SWITCHBOARD'
  IfcElectricDistributionBoardTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricDistributionBoardTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricDistributionBoardTypeEnum
}())
exports.IfcElectricDistributionBoardTypeEnum = IfcElectricDistributionBoardTypeEnum

const IfcElectricFlowStorageDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricFlowStorageDeviceTypeEnum(v) {
    this.value = v
  }
  IfcElectricFlowStorageDeviceTypeEnum.BATTERY = 'BATTERY'
  IfcElectricFlowStorageDeviceTypeEnum.CAPACITORBANK = 'CAPACITORBANK'
  IfcElectricFlowStorageDeviceTypeEnum.HARMONICFILTER = 'HARMONICFILTER'
  IfcElectricFlowStorageDeviceTypeEnum.INDUCTORBANK = 'INDUCTORBANK'
  IfcElectricFlowStorageDeviceTypeEnum.UPS = 'UPS'
  IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricFlowStorageDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricFlowStorageDeviceTypeEnum
}())
exports.IfcElectricFlowStorageDeviceTypeEnum = IfcElectricFlowStorageDeviceTypeEnum

const IfcElectricGeneratorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricGeneratorTypeEnum(v) {
    this.value = v
  }
  IfcElectricGeneratorTypeEnum.CHP = 'CHP'
  IfcElectricGeneratorTypeEnum.ENGINEGENERATOR = 'ENGINEGENERATOR'
  IfcElectricGeneratorTypeEnum.STANDALONE = 'STANDALONE'
  IfcElectricGeneratorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricGeneratorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricGeneratorTypeEnum
}())
exports.IfcElectricGeneratorTypeEnum = IfcElectricGeneratorTypeEnum

const IfcElectricMotorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricMotorTypeEnum(v) {
    this.value = v
  }
  IfcElectricMotorTypeEnum.DC = 'DC'
  IfcElectricMotorTypeEnum.INDUCTION = 'INDUCTION'
  IfcElectricMotorTypeEnum.POLYPHASE = 'POLYPHASE'
  IfcElectricMotorTypeEnum.RELUCTANCESYNCHRONOUS = 'RELUCTANCESYNCHRONOUS'
  IfcElectricMotorTypeEnum.SYNCHRONOUS = 'SYNCHRONOUS'
  IfcElectricMotorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricMotorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricMotorTypeEnum
}())
exports.IfcElectricMotorTypeEnum = IfcElectricMotorTypeEnum

const IfcElectricTimeControlTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricTimeControlTypeEnum(v) {
    this.value = v
  }
  IfcElectricTimeControlTypeEnum.TIMECLOCK = 'TIMECLOCK'
  IfcElectricTimeControlTypeEnum.TIMEDELAY = 'TIMEDELAY'
  IfcElectricTimeControlTypeEnum.RELAY = 'RELAY'
  IfcElectricTimeControlTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElectricTimeControlTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElectricTimeControlTypeEnum
}())
exports.IfcElectricTimeControlTypeEnum = IfcElectricTimeControlTypeEnum

const IfcElementAssemblyTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElementAssemblyTypeEnum(v) {
    this.value = v
  }
  IfcElementAssemblyTypeEnum.ACCESSORY_ASSEMBLY = 'ACCESSORY_ASSEMBLY'
  IfcElementAssemblyTypeEnum.ARCH = 'ARCH'
  IfcElementAssemblyTypeEnum.BEAM_GRID = 'BEAM_GRID'
  IfcElementAssemblyTypeEnum.BRACED_FRAME = 'BRACED_FRAME'
  IfcElementAssemblyTypeEnum.GIRDER = 'GIRDER'
  IfcElementAssemblyTypeEnum.REINFORCEMENT_UNIT = 'REINFORCEMENT_UNIT'
  IfcElementAssemblyTypeEnum.RIGID_FRAME = 'RIGID_FRAME'
  IfcElementAssemblyTypeEnum.SLAB_FIELD = 'SLAB_FIELD'
  IfcElementAssemblyTypeEnum.TRUSS = 'TRUSS'
  IfcElementAssemblyTypeEnum.ABUTMENT = 'ABUTMENT'
  IfcElementAssemblyTypeEnum.PIER = 'PIER'
  IfcElementAssemblyTypeEnum.PYLON = 'PYLON'
  IfcElementAssemblyTypeEnum.CROSS_BRACING = 'CROSS_BRACING'
  IfcElementAssemblyTypeEnum.DECK = 'DECK'
  IfcElementAssemblyTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcElementAssemblyTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcElementAssemblyTypeEnum
}())
exports.IfcElementAssemblyTypeEnum = IfcElementAssemblyTypeEnum

const IfcElementCompositionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcElementCompositionEnum(v) {
    this.value = v
  }
  IfcElementCompositionEnum.COMPLEX = 'COMPLEX'
  IfcElementCompositionEnum.ELEMENT = 'ELEMENT'
  IfcElementCompositionEnum.PARTIAL = 'PARTIAL'
  return IfcElementCompositionEnum
}())
exports.IfcElementCompositionEnum = IfcElementCompositionEnum

const IfcEngineTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcEngineTypeEnum(v) {
    this.value = v
  }
  IfcEngineTypeEnum.EXTERNALCOMBUSTION = 'EXTERNALCOMBUSTION'
  IfcEngineTypeEnum.INTERNALCOMBUSTION = 'INTERNALCOMBUSTION'
  IfcEngineTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcEngineTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcEngineTypeEnum
}())
exports.IfcEngineTypeEnum = IfcEngineTypeEnum

const IfcEvaporativeCoolerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporativeCoolerTypeEnum(v) {
    this.value = v
  }
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER = 'DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER'
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER = 'DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER'
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER = 'DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER'
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER = 'DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER'
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEAIRWASHER = 'DIRECTEVAPORATIVEAIRWASHER'
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEPACKAGEAIRCOOLER = 'INDIRECTEVAPORATIVEPACKAGEAIRCOOLER'
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEWETCOIL = 'INDIRECTEVAPORATIVEWETCOIL'
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER = 'INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER'
  IfcEvaporativeCoolerTypeEnum.INDIRECTDIRECTCOMBINATION = 'INDIRECTDIRECTCOMBINATION'
  IfcEvaporativeCoolerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcEvaporativeCoolerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcEvaporativeCoolerTypeEnum
}())
exports.IfcEvaporativeCoolerTypeEnum = IfcEvaporativeCoolerTypeEnum

const IfcEvaporatorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporatorTypeEnum(v) {
    this.value = v
  }
  IfcEvaporatorTypeEnum.DIRECTEXPANSION = 'DIRECTEXPANSION'
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONSHELLANDTUBE = 'DIRECTEXPANSIONSHELLANDTUBE'
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONTUBEINTUBE = 'DIRECTEXPANSIONTUBEINTUBE'
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONBRAZEDPLATE = 'DIRECTEXPANSIONBRAZEDPLATE'
  IfcEvaporatorTypeEnum.FLOODEDSHELLANDTUBE = 'FLOODEDSHELLANDTUBE'
  IfcEvaporatorTypeEnum.SHELLANDCOIL = 'SHELLANDCOIL'
  IfcEvaporatorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcEvaporatorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcEvaporatorTypeEnum
}())
exports.IfcEvaporatorTypeEnum = IfcEvaporatorTypeEnum

const IfcEventTriggerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcEventTriggerTypeEnum(v) {
    this.value = v
  }
  IfcEventTriggerTypeEnum.EVENTRULE = 'EVENTRULE'
  IfcEventTriggerTypeEnum.EVENTMESSAGE = 'EVENTMESSAGE'
  IfcEventTriggerTypeEnum.EVENTTIME = 'EVENTTIME'
  IfcEventTriggerTypeEnum.EVENTCOMPLEX = 'EVENTCOMPLEX'
  IfcEventTriggerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcEventTriggerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcEventTriggerTypeEnum
}())
exports.IfcEventTriggerTypeEnum = IfcEventTriggerTypeEnum

const IfcEventTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcEventTypeEnum(v) {
    this.value = v
  }
  IfcEventTypeEnum.STARTEVENT = 'STARTEVENT'
  IfcEventTypeEnum.ENDEVENT = 'ENDEVENT'
  IfcEventTypeEnum.INTERMEDIATEEVENT = 'INTERMEDIATEEVENT'
  IfcEventTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcEventTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcEventTypeEnum
}())
exports.IfcEventTypeEnum = IfcEventTypeEnum

const IfcExternalSpatialElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalSpatialElementTypeEnum(v) {
    this.value = v
  }
  IfcExternalSpatialElementTypeEnum.EXTERNAL = 'EXTERNAL'
  IfcExternalSpatialElementTypeEnum.EXTERNAL_EARTH = 'EXTERNAL_EARTH'
  IfcExternalSpatialElementTypeEnum.EXTERNAL_WATER = 'EXTERNAL_WATER'
  IfcExternalSpatialElementTypeEnum.EXTERNAL_FIRE = 'EXTERNAL_FIRE'
  IfcExternalSpatialElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcExternalSpatialElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcExternalSpatialElementTypeEnum
}())
exports.IfcExternalSpatialElementTypeEnum = IfcExternalSpatialElementTypeEnum

const IfcFanTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFanTypeEnum(v) {
    this.value = v
  }
  IfcFanTypeEnum.CENTRIFUGALFORWARDCURVED = 'CENTRIFUGALFORWARDCURVED'
  IfcFanTypeEnum.CENTRIFUGALRADIAL = 'CENTRIFUGALRADIAL'
  IfcFanTypeEnum.CENTRIFUGALBACKWARDINCLINEDCURVED = 'CENTRIFUGALBACKWARDINCLINEDCURVED'
  IfcFanTypeEnum.CENTRIFUGALAIRFOIL = 'CENTRIFUGALAIRFOIL'
  IfcFanTypeEnum.TUBEAXIAL = 'TUBEAXIAL'
  IfcFanTypeEnum.VANEAXIAL = 'VANEAXIAL'
  IfcFanTypeEnum.PROPELLORAXIAL = 'PROPELLORAXIAL'
  IfcFanTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFanTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFanTypeEnum
}())
exports.IfcFanTypeEnum = IfcFanTypeEnum

const IfcFastenerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFastenerTypeEnum(v) {
    this.value = v
  }
  IfcFastenerTypeEnum.GLUE = 'GLUE'
  IfcFastenerTypeEnum.MORTAR = 'MORTAR'
  IfcFastenerTypeEnum.WELD = 'WELD'
  IfcFastenerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFastenerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFastenerTypeEnum
}())
exports.IfcFastenerTypeEnum = IfcFastenerTypeEnum

const IfcFilterTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFilterTypeEnum(v) {
    this.value = v
  }
  IfcFilterTypeEnum.AIRPARTICLEFILTER = 'AIRPARTICLEFILTER'
  IfcFilterTypeEnum.COMPRESSEDAIRFILTER = 'COMPRESSEDAIRFILTER'
  IfcFilterTypeEnum.ODORFILTER = 'ODORFILTER'
  IfcFilterTypeEnum.OILFILTER = 'OILFILTER'
  IfcFilterTypeEnum.STRAINER = 'STRAINER'
  IfcFilterTypeEnum.WATERFILTER = 'WATERFILTER'
  IfcFilterTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFilterTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFilterTypeEnum
}())
exports.IfcFilterTypeEnum = IfcFilterTypeEnum

const IfcFireSuppressionTerminalTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFireSuppressionTerminalTypeEnum(v) {
    this.value = v
  }
  IfcFireSuppressionTerminalTypeEnum.BREECHINGINLET = 'BREECHINGINLET'
  IfcFireSuppressionTerminalTypeEnum.FIREHYDRANT = 'FIREHYDRANT'
  IfcFireSuppressionTerminalTypeEnum.HOSEREEL = 'HOSEREEL'
  IfcFireSuppressionTerminalTypeEnum.SPRINKLER = 'SPRINKLER'
  IfcFireSuppressionTerminalTypeEnum.SPRINKLERDEFLECTOR = 'SPRINKLERDEFLECTOR'
  IfcFireSuppressionTerminalTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFireSuppressionTerminalTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFireSuppressionTerminalTypeEnum
}())
exports.IfcFireSuppressionTerminalTypeEnum = IfcFireSuppressionTerminalTypeEnum

const IfcFlowDirectionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowDirectionEnum(v) {
    this.value = v
  }
  IfcFlowDirectionEnum.SOURCE = 'SOURCE'
  IfcFlowDirectionEnum.SINK = 'SINK'
  IfcFlowDirectionEnum.SOURCEANDSINK = 'SOURCEANDSINK'
  IfcFlowDirectionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFlowDirectionEnum
}())
exports.IfcFlowDirectionEnum = IfcFlowDirectionEnum

const IfcFlowInstrumentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowInstrumentTypeEnum(v) {
    this.value = v
  }
  IfcFlowInstrumentTypeEnum.PRESSUREGAUGE = 'PRESSUREGAUGE'
  IfcFlowInstrumentTypeEnum.THERMOMETER = 'THERMOMETER'
  IfcFlowInstrumentTypeEnum.AMMETER = 'AMMETER'
  IfcFlowInstrumentTypeEnum.FREQUENCYMETER = 'FREQUENCYMETER'
  IfcFlowInstrumentTypeEnum.POWERFACTORMETER = 'POWERFACTORMETER'
  IfcFlowInstrumentTypeEnum.PHASEANGLEMETER = 'PHASEANGLEMETER'
  IfcFlowInstrumentTypeEnum.VOLTMETER_PEAK = 'VOLTMETER_PEAK'
  IfcFlowInstrumentTypeEnum.VOLTMETER_RMS = 'VOLTMETER_RMS'
  IfcFlowInstrumentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFlowInstrumentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFlowInstrumentTypeEnum
}())
exports.IfcFlowInstrumentTypeEnum = IfcFlowInstrumentTypeEnum

const IfcFlowMeterTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowMeterTypeEnum(v) {
    this.value = v
  }
  IfcFlowMeterTypeEnum.ENERGYMETER = 'ENERGYMETER'
  IfcFlowMeterTypeEnum.GASMETER = 'GASMETER'
  IfcFlowMeterTypeEnum.OILMETER = 'OILMETER'
  IfcFlowMeterTypeEnum.WATERMETER = 'WATERMETER'
  IfcFlowMeterTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFlowMeterTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFlowMeterTypeEnum
}())
exports.IfcFlowMeterTypeEnum = IfcFlowMeterTypeEnum

const IfcFootingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFootingTypeEnum(v) {
    this.value = v
  }
  IfcFootingTypeEnum.CAISSON_FOUNDATION = 'CAISSON_FOUNDATION'
  IfcFootingTypeEnum.FOOTING_BEAM = 'FOOTING_BEAM'
  IfcFootingTypeEnum.PAD_FOOTING = 'PAD_FOOTING'
  IfcFootingTypeEnum.PILE_CAP = 'PILE_CAP'
  IfcFootingTypeEnum.STRIP_FOOTING = 'STRIP_FOOTING'
  IfcFootingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFootingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFootingTypeEnum
}())
exports.IfcFootingTypeEnum = IfcFootingTypeEnum

const IfcFurnitureTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcFurnitureTypeEnum(v) {
    this.value = v
  }
  IfcFurnitureTypeEnum.CHAIR = 'CHAIR'
  IfcFurnitureTypeEnum.TABLE = 'TABLE'
  IfcFurnitureTypeEnum.DESK = 'DESK'
  IfcFurnitureTypeEnum.BED = 'BED'
  IfcFurnitureTypeEnum.FILECABINET = 'FILECABINET'
  IfcFurnitureTypeEnum.SHELF = 'SHELF'
  IfcFurnitureTypeEnum.SOFA = 'SOFA'
  IfcFurnitureTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcFurnitureTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcFurnitureTypeEnum
}())
exports.IfcFurnitureTypeEnum = IfcFurnitureTypeEnum

const IfcGeographicElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcGeographicElementTypeEnum(v) {
    this.value = v
  }
  IfcGeographicElementTypeEnum.TERRAIN = 'TERRAIN'
  IfcGeographicElementTypeEnum.SOIL_BORING_POINT = 'SOIL_BORING_POINT'
  IfcGeographicElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcGeographicElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcGeographicElementTypeEnum
}())
exports.IfcGeographicElementTypeEnum = IfcGeographicElementTypeEnum

const IfcGeometricProjectionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricProjectionEnum(v) {
    this.value = v
  }
  IfcGeometricProjectionEnum.GRAPH_VIEW = 'GRAPH_VIEW'
  IfcGeometricProjectionEnum.SKETCH_VIEW = 'SKETCH_VIEW'
  IfcGeometricProjectionEnum.MODEL_VIEW = 'MODEL_VIEW'
  IfcGeometricProjectionEnum.PLAN_VIEW = 'PLAN_VIEW'
  IfcGeometricProjectionEnum.REFLECTED_PLAN_VIEW = 'REFLECTED_PLAN_VIEW'
  IfcGeometricProjectionEnum.SECTION_VIEW = 'SECTION_VIEW'
  IfcGeometricProjectionEnum.ELEVATION_VIEW = 'ELEVATION_VIEW'
  IfcGeometricProjectionEnum.USERDEFINED = 'USERDEFINED'
  IfcGeometricProjectionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcGeometricProjectionEnum
}())
exports.IfcGeometricProjectionEnum = IfcGeometricProjectionEnum

const IfcGlobalOrLocalEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcGlobalOrLocalEnum(v) {
    this.value = v
  }
  IfcGlobalOrLocalEnum.GLOBAL_COORDS = 'GLOBAL_COORDS'
  IfcGlobalOrLocalEnum.LOCAL_COORDS = 'LOCAL_COORDS'
  return IfcGlobalOrLocalEnum
}())
exports.IfcGlobalOrLocalEnum = IfcGlobalOrLocalEnum

const IfcGridTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcGridTypeEnum(v) {
    this.value = v
  }
  IfcGridTypeEnum.RECTANGULAR = 'RECTANGULAR'
  IfcGridTypeEnum.RADIAL = 'RADIAL'
  IfcGridTypeEnum.TRIANGULAR = 'TRIANGULAR'
  IfcGridTypeEnum.IRREGULAR = 'IRREGULAR'
  IfcGridTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcGridTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcGridTypeEnum
}())
exports.IfcGridTypeEnum = IfcGridTypeEnum

const IfcHeatExchangerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcHeatExchangerTypeEnum(v) {
    this.value = v
  }
  IfcHeatExchangerTypeEnum.PLATE = 'PLATE'
  IfcHeatExchangerTypeEnum.SHELLANDTUBE = 'SHELLANDTUBE'
  IfcHeatExchangerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcHeatExchangerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcHeatExchangerTypeEnum
}())
exports.IfcHeatExchangerTypeEnum = IfcHeatExchangerTypeEnum

const IfcHumidifierTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcHumidifierTypeEnum(v) {
    this.value = v
  }
  IfcHumidifierTypeEnum.STEAMINJECTION = 'STEAMINJECTION'
  IfcHumidifierTypeEnum.ADIABATICAIRWASHER = 'ADIABATICAIRWASHER'
  IfcHumidifierTypeEnum.ADIABATICPAN = 'ADIABATICPAN'
  IfcHumidifierTypeEnum.ADIABATICWETTEDELEMENT = 'ADIABATICWETTEDELEMENT'
  IfcHumidifierTypeEnum.ADIABATICATOMIZING = 'ADIABATICATOMIZING'
  IfcHumidifierTypeEnum.ADIABATICULTRASONIC = 'ADIABATICULTRASONIC'
  IfcHumidifierTypeEnum.ADIABATICRIGIDMEDIA = 'ADIABATICRIGIDMEDIA'
  IfcHumidifierTypeEnum.ADIABATICCOMPRESSEDAIRNOZZLE = 'ADIABATICCOMPRESSEDAIRNOZZLE'
  IfcHumidifierTypeEnum.ASSISTEDELECTRIC = 'ASSISTEDELECTRIC'
  IfcHumidifierTypeEnum.ASSISTEDNATURALGAS = 'ASSISTEDNATURALGAS'
  IfcHumidifierTypeEnum.ASSISTEDPROPANE = 'ASSISTEDPROPANE'
  IfcHumidifierTypeEnum.ASSISTEDBUTANE = 'ASSISTEDBUTANE'
  IfcHumidifierTypeEnum.ASSISTEDSTEAM = 'ASSISTEDSTEAM'
  IfcHumidifierTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcHumidifierTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcHumidifierTypeEnum
}())
exports.IfcHumidifierTypeEnum = IfcHumidifierTypeEnum

const IfcInterceptorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcInterceptorTypeEnum(v) {
    this.value = v
  }
  IfcInterceptorTypeEnum.CYCLONIC = 'CYCLONIC'
  IfcInterceptorTypeEnum.GREASE = 'GREASE'
  IfcInterceptorTypeEnum.OIL = 'OIL'
  IfcInterceptorTypeEnum.PETROL = 'PETROL'
  IfcInterceptorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcInterceptorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcInterceptorTypeEnum
}())
exports.IfcInterceptorTypeEnum = IfcInterceptorTypeEnum

const IfcInternalOrExternalEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcInternalOrExternalEnum(v) {
    this.value = v
  }
  IfcInternalOrExternalEnum.INTERNAL = 'INTERNAL'
  IfcInternalOrExternalEnum.EXTERNAL = 'EXTERNAL'
  IfcInternalOrExternalEnum.EXTERNAL_EARTH = 'EXTERNAL_EARTH'
  IfcInternalOrExternalEnum.EXTERNAL_WATER = 'EXTERNAL_WATER'
  IfcInternalOrExternalEnum.EXTERNAL_FIRE = 'EXTERNAL_FIRE'
  IfcInternalOrExternalEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcInternalOrExternalEnum
}())
exports.IfcInternalOrExternalEnum = IfcInternalOrExternalEnum

const IfcInventoryTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcInventoryTypeEnum(v) {
    this.value = v
  }
  IfcInventoryTypeEnum.ASSETINVENTORY = 'ASSETINVENTORY'
  IfcInventoryTypeEnum.SPACEINVENTORY = 'SPACEINVENTORY'
  IfcInventoryTypeEnum.FURNITUREINVENTORY = 'FURNITUREINVENTORY'
  IfcInventoryTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcInventoryTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcInventoryTypeEnum
}())
exports.IfcInventoryTypeEnum = IfcInventoryTypeEnum

const IfcJunctionBoxTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcJunctionBoxTypeEnum(v) {
    this.value = v
  }
  IfcJunctionBoxTypeEnum.DATA = 'DATA'
  IfcJunctionBoxTypeEnum.POWER = 'POWER'
  IfcJunctionBoxTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcJunctionBoxTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcJunctionBoxTypeEnum
}())
exports.IfcJunctionBoxTypeEnum = IfcJunctionBoxTypeEnum

const IfcKnotType = /** @class */ (function() {
  /**
   *
   */
  function IfcKnotType(v) {
    this.value = v
  }
  IfcKnotType.UNIFORM_KNOTS = 'UNIFORM_KNOTS'
  IfcKnotType.QUASI_UNIFORM_KNOTS = 'QUASI_UNIFORM_KNOTS'
  IfcKnotType.PIECEWISE_BEZIER_KNOTS = 'PIECEWISE_BEZIER_KNOTS'
  IfcKnotType.UNSPECIFIED = 'UNSPECIFIED'
  return IfcKnotType
}())
exports.IfcKnotType = IfcKnotType

const IfcLaborResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLaborResourceTypeEnum(v) {
    this.value = v
  }
  IfcLaborResourceTypeEnum.ADMINISTRATION = 'ADMINISTRATION'
  IfcLaborResourceTypeEnum.CARPENTRY = 'CARPENTRY'
  IfcLaborResourceTypeEnum.CLEANING = 'CLEANING'
  IfcLaborResourceTypeEnum.CONCRETE = 'CONCRETE'
  IfcLaborResourceTypeEnum.DRYWALL = 'DRYWALL'
  IfcLaborResourceTypeEnum.ELECTRIC = 'ELECTRIC'
  IfcLaborResourceTypeEnum.FINISHING = 'FINISHING'
  IfcLaborResourceTypeEnum.FLOORING = 'FLOORING'
  IfcLaborResourceTypeEnum.GENERAL = 'GENERAL'
  IfcLaborResourceTypeEnum.HVAC = 'HVAC'
  IfcLaborResourceTypeEnum.LANDSCAPING = 'LANDSCAPING'
  IfcLaborResourceTypeEnum.MASONRY = 'MASONRY'
  IfcLaborResourceTypeEnum.PAINTING = 'PAINTING'
  IfcLaborResourceTypeEnum.PAVING = 'PAVING'
  IfcLaborResourceTypeEnum.PLUMBING = 'PLUMBING'
  IfcLaborResourceTypeEnum.ROOFING = 'ROOFING'
  IfcLaborResourceTypeEnum.SITEGRADING = 'SITEGRADING'
  IfcLaborResourceTypeEnum.STEELWORK = 'STEELWORK'
  IfcLaborResourceTypeEnum.SURVEYING = 'SURVEYING'
  IfcLaborResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcLaborResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLaborResourceTypeEnum
}())
exports.IfcLaborResourceTypeEnum = IfcLaborResourceTypeEnum

const IfcLampTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLampTypeEnum(v) {
    this.value = v
  }
  IfcLampTypeEnum.COMPACTFLUORESCENT = 'COMPACTFLUORESCENT'
  IfcLampTypeEnum.FLUORESCENT = 'FLUORESCENT'
  IfcLampTypeEnum.HALOGEN = 'HALOGEN'
  IfcLampTypeEnum.HIGHPRESSUREMERCURY = 'HIGHPRESSUREMERCURY'
  IfcLampTypeEnum.HIGHPRESSURESODIUM = 'HIGHPRESSURESODIUM'
  IfcLampTypeEnum.LED = 'LED'
  IfcLampTypeEnum.METALHALIDE = 'METALHALIDE'
  IfcLampTypeEnum.OLED = 'OLED'
  IfcLampTypeEnum.TUNGSTENFILAMENT = 'TUNGSTENFILAMENT'
  IfcLampTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcLampTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLampTypeEnum
}())
exports.IfcLampTypeEnum = IfcLampTypeEnum

const IfcLayerSetDirectionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLayerSetDirectionEnum(v) {
    this.value = v
  }
  IfcLayerSetDirectionEnum.AXIS1 = 'AXIS1'
  IfcLayerSetDirectionEnum.AXIS2 = 'AXIS2'
  IfcLayerSetDirectionEnum.AXIS3 = 'AXIS3'
  return IfcLayerSetDirectionEnum
}())
exports.IfcLayerSetDirectionEnum = IfcLayerSetDirectionEnum

const IfcLightDistributionCurveEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLightDistributionCurveEnum(v) {
    this.value = v
  }
  IfcLightDistributionCurveEnum.TYPE_A = 'TYPE_A'
  IfcLightDistributionCurveEnum.TYPE_B = 'TYPE_B'
  IfcLightDistributionCurveEnum.TYPE_C = 'TYPE_C'
  IfcLightDistributionCurveEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLightDistributionCurveEnum
}())
exports.IfcLightDistributionCurveEnum = IfcLightDistributionCurveEnum

const IfcLightEmissionSourceEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLightEmissionSourceEnum(v) {
    this.value = v
  }
  IfcLightEmissionSourceEnum.COMPACTFLUORESCENT = 'COMPACTFLUORESCENT'
  IfcLightEmissionSourceEnum.FLUORESCENT = 'FLUORESCENT'
  IfcLightEmissionSourceEnum.HIGHPRESSUREMERCURY = 'HIGHPRESSUREMERCURY'
  IfcLightEmissionSourceEnum.HIGHPRESSURESODIUM = 'HIGHPRESSURESODIUM'
  IfcLightEmissionSourceEnum.LIGHTEMITTINGDIODE = 'LIGHTEMITTINGDIODE'
  IfcLightEmissionSourceEnum.LOWPRESSURESODIUM = 'LOWPRESSURESODIUM'
  IfcLightEmissionSourceEnum.LOWVOLTAGEHALOGEN = 'LOWVOLTAGEHALOGEN'
  IfcLightEmissionSourceEnum.MAINVOLTAGEHALOGEN = 'MAINVOLTAGEHALOGEN'
  IfcLightEmissionSourceEnum.METALHALIDE = 'METALHALIDE'
  IfcLightEmissionSourceEnum.TUNGSTENFILAMENT = 'TUNGSTENFILAMENT'
  IfcLightEmissionSourceEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLightEmissionSourceEnum
}())
exports.IfcLightEmissionSourceEnum = IfcLightEmissionSourceEnum

const IfcLightFixtureTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLightFixtureTypeEnum(v) {
    this.value = v
  }
  IfcLightFixtureTypeEnum.POINTSOURCE = 'POINTSOURCE'
  IfcLightFixtureTypeEnum.DIRECTIONSOURCE = 'DIRECTIONSOURCE'
  IfcLightFixtureTypeEnum.SECURITYLIGHTING = 'SECURITYLIGHTING'
  IfcLightFixtureTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcLightFixtureTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLightFixtureTypeEnum
}())
exports.IfcLightFixtureTypeEnum = IfcLightFixtureTypeEnum

const IfcLoadGroupTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLoadGroupTypeEnum(v) {
    this.value = v
  }
  IfcLoadGroupTypeEnum.LOAD_GROUP = 'LOAD_GROUP'
  IfcLoadGroupTypeEnum.LOAD_CASE = 'LOAD_CASE'
  IfcLoadGroupTypeEnum.LOAD_COMBINATION = 'LOAD_COMBINATION'
  IfcLoadGroupTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcLoadGroupTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcLoadGroupTypeEnum
}())
exports.IfcLoadGroupTypeEnum = IfcLoadGroupTypeEnum

const IfcLogicalOperatorEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcLogicalOperatorEnum(v) {
    this.value = v
  }
  IfcLogicalOperatorEnum.LOGICALAND = 'LOGICALAND'
  IfcLogicalOperatorEnum.LOGICALOR = 'LOGICALOR'
  IfcLogicalOperatorEnum.LOGICALXOR = 'LOGICALXOR'
  IfcLogicalOperatorEnum.LOGICALNOTAND = 'LOGICALNOTAND'
  IfcLogicalOperatorEnum.LOGICALNOTOR = 'LOGICALNOTOR'
  return IfcLogicalOperatorEnum
}())
exports.IfcLogicalOperatorEnum = IfcLogicalOperatorEnum

const IfcMechanicalFastenerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcMechanicalFastenerTypeEnum(v) {
    this.value = v
  }
  IfcMechanicalFastenerTypeEnum.ANCHORBOLT = 'ANCHORBOLT'
  IfcMechanicalFastenerTypeEnum.BOLT = 'BOLT'
  IfcMechanicalFastenerTypeEnum.DOWEL = 'DOWEL'
  IfcMechanicalFastenerTypeEnum.NAIL = 'NAIL'
  IfcMechanicalFastenerTypeEnum.NAILPLATE = 'NAILPLATE'
  IfcMechanicalFastenerTypeEnum.RIVET = 'RIVET'
  IfcMechanicalFastenerTypeEnum.SCREW = 'SCREW'
  IfcMechanicalFastenerTypeEnum.SHEARCONNECTOR = 'SHEARCONNECTOR'
  IfcMechanicalFastenerTypeEnum.STAPLE = 'STAPLE'
  IfcMechanicalFastenerTypeEnum.STUDSHEARCONNECTOR = 'STUDSHEARCONNECTOR'
  IfcMechanicalFastenerTypeEnum.COUPLER = 'COUPLER'
  IfcMechanicalFastenerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcMechanicalFastenerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcMechanicalFastenerTypeEnum
}())
exports.IfcMechanicalFastenerTypeEnum = IfcMechanicalFastenerTypeEnum

const IfcMedicalDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcMedicalDeviceTypeEnum(v) {
    this.value = v
  }
  IfcMedicalDeviceTypeEnum.AIRSTATION = 'AIRSTATION'
  IfcMedicalDeviceTypeEnum.FEEDAIRUNIT = 'FEEDAIRUNIT'
  IfcMedicalDeviceTypeEnum.OXYGENGENERATOR = 'OXYGENGENERATOR'
  IfcMedicalDeviceTypeEnum.OXYGENPLANT = 'OXYGENPLANT'
  IfcMedicalDeviceTypeEnum.VACUUMSTATION = 'VACUUMSTATION'
  IfcMedicalDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcMedicalDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcMedicalDeviceTypeEnum
}())
exports.IfcMedicalDeviceTypeEnum = IfcMedicalDeviceTypeEnum

const IfcMemberTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcMemberTypeEnum(v) {
    this.value = v
  }
  IfcMemberTypeEnum.BRACE = 'BRACE'
  IfcMemberTypeEnum.CHORD = 'CHORD'
  IfcMemberTypeEnum.COLLAR = 'COLLAR'
  IfcMemberTypeEnum.MEMBER = 'MEMBER'
  IfcMemberTypeEnum.MULLION = 'MULLION'
  IfcMemberTypeEnum.PLATE = 'PLATE'
  IfcMemberTypeEnum.POST = 'POST'
  IfcMemberTypeEnum.PURLIN = 'PURLIN'
  IfcMemberTypeEnum.RAFTER = 'RAFTER'
  IfcMemberTypeEnum.STRINGER = 'STRINGER'
  IfcMemberTypeEnum.STRUT = 'STRUT'
  IfcMemberTypeEnum.STUD = 'STUD'
  IfcMemberTypeEnum.STIFFENING_RIB = 'STIFFENING_RIB'
  IfcMemberTypeEnum.ARCH_SEGMENT = 'ARCH_SEGMENT'
  IfcMemberTypeEnum.SUSPENSION_CABLE = 'SUSPENSION_CABLE'
  IfcMemberTypeEnum.SUSPENDER = 'SUSPENDER'
  IfcMemberTypeEnum.STAY_CABLE = 'STAY_CABLE'
  IfcMemberTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcMemberTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcMemberTypeEnum
}())
exports.IfcMemberTypeEnum = IfcMemberTypeEnum

const IfcMotorConnectionTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcMotorConnectionTypeEnum(v) {
    this.value = v
  }
  IfcMotorConnectionTypeEnum.BELTDRIVE = 'BELTDRIVE'
  IfcMotorConnectionTypeEnum.COUPLING = 'COUPLING'
  IfcMotorConnectionTypeEnum.DIRECTDRIVE = 'DIRECTDRIVE'
  IfcMotorConnectionTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcMotorConnectionTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcMotorConnectionTypeEnum
}())
exports.IfcMotorConnectionTypeEnum = IfcMotorConnectionTypeEnum

const IfcNullStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcNullStyle(v) {
    this.value = v
  }
  IfcNullStyle.NULL = 'NULL'
  return IfcNullStyle
}())
exports.IfcNullStyle = IfcNullStyle

const IfcObjectTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcObjectTypeEnum(v) {
    this.value = v
  }
  IfcObjectTypeEnum.PRODUCT = 'PRODUCT'
  IfcObjectTypeEnum.PROCESS = 'PROCESS'
  IfcObjectTypeEnum.CONTROL = 'CONTROL'
  IfcObjectTypeEnum.RESOURCE = 'RESOURCE'
  IfcObjectTypeEnum.ACTOR = 'ACTOR'
  IfcObjectTypeEnum.GROUP = 'GROUP'
  IfcObjectTypeEnum.PROJECT = 'PROJECT'
  IfcObjectTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcObjectTypeEnum
}())
exports.IfcObjectTypeEnum = IfcObjectTypeEnum

const IfcObjectiveEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcObjectiveEnum(v) {
    this.value = v
  }
  IfcObjectiveEnum.CODECOMPLIANCE = 'CODECOMPLIANCE'
  IfcObjectiveEnum.CODEWAIVER = 'CODEWAIVER'
  IfcObjectiveEnum.DESIGNINTENT = 'DESIGNINTENT'
  IfcObjectiveEnum.EXTERNAL = 'EXTERNAL'
  IfcObjectiveEnum.HEALTHANDSAFETY = 'HEALTHANDSAFETY'
  IfcObjectiveEnum.MERGECONFLICT = 'MERGECONFLICT'
  IfcObjectiveEnum.MODELVIEW = 'MODELVIEW'
  IfcObjectiveEnum.PARAMETER = 'PARAMETER'
  IfcObjectiveEnum.REQUIREMENT = 'REQUIREMENT'
  IfcObjectiveEnum.SPECIFICATION = 'SPECIFICATION'
  IfcObjectiveEnum.TRIGGERCONDITION = 'TRIGGERCONDITION'
  IfcObjectiveEnum.USERDEFINED = 'USERDEFINED'
  IfcObjectiveEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcObjectiveEnum
}())
exports.IfcObjectiveEnum = IfcObjectiveEnum

const IfcOccupantTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcOccupantTypeEnum(v) {
    this.value = v
  }
  IfcOccupantTypeEnum.ASSIGNEE = 'ASSIGNEE'
  IfcOccupantTypeEnum.ASSIGNOR = 'ASSIGNOR'
  IfcOccupantTypeEnum.LESSEE = 'LESSEE'
  IfcOccupantTypeEnum.LESSOR = 'LESSOR'
  IfcOccupantTypeEnum.LETTINGAGENT = 'LETTINGAGENT'
  IfcOccupantTypeEnum.OWNER = 'OWNER'
  IfcOccupantTypeEnum.TENANT = 'TENANT'
  IfcOccupantTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcOccupantTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcOccupantTypeEnum
}())
exports.IfcOccupantTypeEnum = IfcOccupantTypeEnum

const IfcOpeningElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcOpeningElementTypeEnum(v) {
    this.value = v
  }
  IfcOpeningElementTypeEnum.OPENING = 'OPENING'
  IfcOpeningElementTypeEnum.RECESS = 'RECESS'
  IfcOpeningElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcOpeningElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcOpeningElementTypeEnum
}())
exports.IfcOpeningElementTypeEnum = IfcOpeningElementTypeEnum

const IfcOutletTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcOutletTypeEnum(v) {
    this.value = v
  }
  IfcOutletTypeEnum.AUDIOVISUALOUTLET = 'AUDIOVISUALOUTLET'
  IfcOutletTypeEnum.COMMUNICATIONSOUTLET = 'COMMUNICATIONSOUTLET'
  IfcOutletTypeEnum.POWEROUTLET = 'POWEROUTLET'
  IfcOutletTypeEnum.DATAOUTLET = 'DATAOUTLET'
  IfcOutletTypeEnum.TELEPHONEOUTLET = 'TELEPHONEOUTLET'
  IfcOutletTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcOutletTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcOutletTypeEnum
}())
exports.IfcOutletTypeEnum = IfcOutletTypeEnum

const IfcPerformanceHistoryTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPerformanceHistoryTypeEnum(v) {
    this.value = v
  }
  IfcPerformanceHistoryTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPerformanceHistoryTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPerformanceHistoryTypeEnum
}())
exports.IfcPerformanceHistoryTypeEnum = IfcPerformanceHistoryTypeEnum

const IfcPermeableCoveringOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPermeableCoveringOperationEnum(v) {
    this.value = v
  }
  IfcPermeableCoveringOperationEnum.GRILL = 'GRILL'
  IfcPermeableCoveringOperationEnum.LOUVER = 'LOUVER'
  IfcPermeableCoveringOperationEnum.SCREEN = 'SCREEN'
  IfcPermeableCoveringOperationEnum.USERDEFINED = 'USERDEFINED'
  IfcPermeableCoveringOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPermeableCoveringOperationEnum
}())
exports.IfcPermeableCoveringOperationEnum = IfcPermeableCoveringOperationEnum

const IfcPermitTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPermitTypeEnum(v) {
    this.value = v
  }
  IfcPermitTypeEnum.ACCESS = 'ACCESS'
  IfcPermitTypeEnum.BUILDING = 'BUILDING'
  IfcPermitTypeEnum.WORK = 'WORK'
  IfcPermitTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPermitTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPermitTypeEnum
}())
exports.IfcPermitTypeEnum = IfcPermitTypeEnum

const IfcPhysicalOrVirtualEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPhysicalOrVirtualEnum(v) {
    this.value = v
  }
  IfcPhysicalOrVirtualEnum.PHYSICAL = 'PHYSICAL'
  IfcPhysicalOrVirtualEnum.VIRTUAL = 'VIRTUAL'
  IfcPhysicalOrVirtualEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPhysicalOrVirtualEnum
}())
exports.IfcPhysicalOrVirtualEnum = IfcPhysicalOrVirtualEnum

const IfcPileConstructionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPileConstructionEnum(v) {
    this.value = v
  }
  IfcPileConstructionEnum.CAST_IN_PLACE = 'CAST_IN_PLACE'
  IfcPileConstructionEnum.COMPOSITE = 'COMPOSITE'
  IfcPileConstructionEnum.PRECAST_CONCRETE = 'PRECAST_CONCRETE'
  IfcPileConstructionEnum.PREFAB_STEEL = 'PREFAB_STEEL'
  IfcPileConstructionEnum.USERDEFINED = 'USERDEFINED'
  IfcPileConstructionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPileConstructionEnum
}())
exports.IfcPileConstructionEnum = IfcPileConstructionEnum

const IfcPileTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPileTypeEnum(v) {
    this.value = v
  }
  IfcPileTypeEnum.BORED = 'BORED'
  IfcPileTypeEnum.DRIVEN = 'DRIVEN'
  IfcPileTypeEnum.JETGROUTING = 'JETGROUTING'
  IfcPileTypeEnum.COHESION = 'COHESION'
  IfcPileTypeEnum.FRICTION = 'FRICTION'
  IfcPileTypeEnum.SUPPORT = 'SUPPORT'
  IfcPileTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPileTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPileTypeEnum
}())
exports.IfcPileTypeEnum = IfcPileTypeEnum

const IfcPipeFittingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeFittingTypeEnum(v) {
    this.value = v
  }
  IfcPipeFittingTypeEnum.BEND = 'BEND'
  IfcPipeFittingTypeEnum.CONNECTOR = 'CONNECTOR'
  IfcPipeFittingTypeEnum.ENTRY = 'ENTRY'
  IfcPipeFittingTypeEnum.EXIT = 'EXIT'
  IfcPipeFittingTypeEnum.JUNCTION = 'JUNCTION'
  IfcPipeFittingTypeEnum.OBSTRUCTION = 'OBSTRUCTION'
  IfcPipeFittingTypeEnum.TRANSITION = 'TRANSITION'
  IfcPipeFittingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPipeFittingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPipeFittingTypeEnum
}())
exports.IfcPipeFittingTypeEnum = IfcPipeFittingTypeEnum

const IfcPipeSegmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeSegmentTypeEnum(v) {
    this.value = v
  }
  IfcPipeSegmentTypeEnum.CULVERT = 'CULVERT'
  IfcPipeSegmentTypeEnum.FLEXIBLESEGMENT = 'FLEXIBLESEGMENT'
  IfcPipeSegmentTypeEnum.RIGIDSEGMENT = 'RIGIDSEGMENT'
  IfcPipeSegmentTypeEnum.GUTTER = 'GUTTER'
  IfcPipeSegmentTypeEnum.SPOOL = 'SPOOL'
  IfcPipeSegmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPipeSegmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPipeSegmentTypeEnum
}())
exports.IfcPipeSegmentTypeEnum = IfcPipeSegmentTypeEnum

const IfcPlateTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPlateTypeEnum(v) {
    this.value = v
  }
  IfcPlateTypeEnum.CURTAIN_PANEL = 'CURTAIN_PANEL'
  IfcPlateTypeEnum.SHEET = 'SHEET'
  IfcPlateTypeEnum.FLANGE_PLATE = 'FLANGE_PLATE'
  IfcPlateTypeEnum.WEB_PLATE = 'WEB_PLATE'
  IfcPlateTypeEnum.STIFFENER_PLATE = 'STIFFENER_PLATE'
  IfcPlateTypeEnum.GUSSET_PLATE = 'GUSSET_PLATE'
  IfcPlateTypeEnum.COVER_PLATE = 'COVER_PLATE'
  IfcPlateTypeEnum.SPLICE_PLATE = 'SPLICE_PLATE'
  IfcPlateTypeEnum.BASE_PLATE = 'BASE_PLATE'
  IfcPlateTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPlateTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPlateTypeEnum
}())
exports.IfcPlateTypeEnum = IfcPlateTypeEnum

const IfcPreferredSurfaceCurveRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcPreferredSurfaceCurveRepresentation(v) {
    this.value = v
  }
  IfcPreferredSurfaceCurveRepresentation.CURVE3D = 'CURVE3D'
  IfcPreferredSurfaceCurveRepresentation.PCURVE_S1 = 'PCURVE_S1'
  IfcPreferredSurfaceCurveRepresentation.PCURVE_S2 = 'PCURVE_S2'
  return IfcPreferredSurfaceCurveRepresentation
}())
exports.IfcPreferredSurfaceCurveRepresentation = IfcPreferredSurfaceCurveRepresentation

const IfcProcedureTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProcedureTypeEnum(v) {
    this.value = v
  }
  IfcProcedureTypeEnum.ADVICE_CAUTION = 'ADVICE_CAUTION'
  IfcProcedureTypeEnum.ADVICE_NOTE = 'ADVICE_NOTE'
  IfcProcedureTypeEnum.ADVICE_WARNING = 'ADVICE_WARNING'
  IfcProcedureTypeEnum.CALIBRATION = 'CALIBRATION'
  IfcProcedureTypeEnum.DIAGNOSTIC = 'DIAGNOSTIC'
  IfcProcedureTypeEnum.SHUTDOWN = 'SHUTDOWN'
  IfcProcedureTypeEnum.STARTUP = 'STARTUP'
  IfcProcedureTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcProcedureTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcProcedureTypeEnum
}())
exports.IfcProcedureTypeEnum = IfcProcedureTypeEnum

const IfcProfileTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProfileTypeEnum(v) {
    this.value = v
  }
  IfcProfileTypeEnum.CURVE = 'CURVE'
  IfcProfileTypeEnum.AREA = 'AREA'
  return IfcProfileTypeEnum
}())
exports.IfcProfileTypeEnum = IfcProfileTypeEnum

const IfcProjectOrderTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectOrderTypeEnum(v) {
    this.value = v
  }
  IfcProjectOrderTypeEnum.CHANGEORDER = 'CHANGEORDER'
  IfcProjectOrderTypeEnum.MAINTENANCEWORKORDER = 'MAINTENANCEWORKORDER'
  IfcProjectOrderTypeEnum.MOVEORDER = 'MOVEORDER'
  IfcProjectOrderTypeEnum.PURCHASEORDER = 'PURCHASEORDER'
  IfcProjectOrderTypeEnum.WORKORDER = 'WORKORDER'
  IfcProjectOrderTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcProjectOrderTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcProjectOrderTypeEnum
}())
exports.IfcProjectOrderTypeEnum = IfcProjectOrderTypeEnum

const IfcProjectedOrTrueLengthEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectedOrTrueLengthEnum(v) {
    this.value = v
  }
  IfcProjectedOrTrueLengthEnum.PROJECTED_LENGTH = 'PROJECTED_LENGTH'
  IfcProjectedOrTrueLengthEnum.TRUE_LENGTH = 'TRUE_LENGTH'
  return IfcProjectedOrTrueLengthEnum
}())
exports.IfcProjectedOrTrueLengthEnum = IfcProjectedOrTrueLengthEnum

const IfcProjectionElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectionElementTypeEnum(v) {
    this.value = v
  }
  IfcProjectionElementTypeEnum.BLISTER = 'BLISTER'
  IfcProjectionElementTypeEnum.DEVIATOR = 'DEVIATOR'
  IfcProjectionElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcProjectionElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcProjectionElementTypeEnum
}())
exports.IfcProjectionElementTypeEnum = IfcProjectionElementTypeEnum

const IfcPropertySetTemplateTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertySetTemplateTypeEnum(v) {
    this.value = v
  }
  IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENONLY = 'PSET_TYPEDRIVENONLY'
  IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENOVERRIDE = 'PSET_TYPEDRIVENOVERRIDE'
  IfcPropertySetTemplateTypeEnum.PSET_OCCURRENCEDRIVEN = 'PSET_OCCURRENCEDRIVEN'
  IfcPropertySetTemplateTypeEnum.PSET_PERFORMANCEDRIVEN = 'PSET_PERFORMANCEDRIVEN'
  IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENONLY = 'QTO_TYPEDRIVENONLY'
  IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENOVERRIDE = 'QTO_TYPEDRIVENOVERRIDE'
  IfcPropertySetTemplateTypeEnum.QTO_OCCURRENCEDRIVEN = 'QTO_OCCURRENCEDRIVEN'
  IfcPropertySetTemplateTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPropertySetTemplateTypeEnum
}())
exports.IfcPropertySetTemplateTypeEnum = IfcPropertySetTemplateTypeEnum

const IfcProtectiveDeviceTrippingUnitTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDeviceTrippingUnitTypeEnum(v) {
    this.value = v
  }
  IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTRONIC = 'ELECTRONIC'
  IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTROMAGNETIC = 'ELECTROMAGNETIC'
  IfcProtectiveDeviceTrippingUnitTypeEnum.RESIDUALCURRENT = 'RESIDUALCURRENT'
  IfcProtectiveDeviceTrippingUnitTypeEnum.THERMAL = 'THERMAL'
  IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcProtectiveDeviceTrippingUnitTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcProtectiveDeviceTrippingUnitTypeEnum
}())
exports.IfcProtectiveDeviceTrippingUnitTypeEnum = IfcProtectiveDeviceTrippingUnitTypeEnum

const IfcProtectiveDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDeviceTypeEnum(v) {
    this.value = v
  }
  IfcProtectiveDeviceTypeEnum.CIRCUITBREAKER = 'CIRCUITBREAKER'
  IfcProtectiveDeviceTypeEnum.EARTHLEAKAGECIRCUITBREAKER = 'EARTHLEAKAGECIRCUITBREAKER'
  IfcProtectiveDeviceTypeEnum.EARTHINGSWITCH = 'EARTHINGSWITCH'
  IfcProtectiveDeviceTypeEnum.FUSEDISCONNECTOR = 'FUSEDISCONNECTOR'
  IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTCIRCUITBREAKER = 'RESIDUALCURRENTCIRCUITBREAKER'
  IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTSWITCH = 'RESIDUALCURRENTSWITCH'
  IfcProtectiveDeviceTypeEnum.VARISTOR = 'VARISTOR'
  IfcProtectiveDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcProtectiveDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcProtectiveDeviceTypeEnum
}())
exports.IfcProtectiveDeviceTypeEnum = IfcProtectiveDeviceTypeEnum

const IfcPumpTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcPumpTypeEnum(v) {
    this.value = v
  }
  IfcPumpTypeEnum.CIRCULATOR = 'CIRCULATOR'
  IfcPumpTypeEnum.ENDSUCTION = 'ENDSUCTION'
  IfcPumpTypeEnum.SPLITCASE = 'SPLITCASE'
  IfcPumpTypeEnum.SUBMERSIBLEPUMP = 'SUBMERSIBLEPUMP'
  IfcPumpTypeEnum.SUMPPUMP = 'SUMPPUMP'
  IfcPumpTypeEnum.VERTICALINLINE = 'VERTICALINLINE'
  IfcPumpTypeEnum.VERTICALTURBINE = 'VERTICALTURBINE'
  IfcPumpTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcPumpTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcPumpTypeEnum
}())
exports.IfcPumpTypeEnum = IfcPumpTypeEnum

const IfcRailingTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRailingTypeEnum(v) {
    this.value = v
  }
  IfcRailingTypeEnum.HANDRAIL = 'HANDRAIL'
  IfcRailingTypeEnum.GUARDRAIL = 'GUARDRAIL'
  IfcRailingTypeEnum.BALUSTRADE = 'BALUSTRADE'
  IfcRailingTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcRailingTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcRailingTypeEnum
}())
exports.IfcRailingTypeEnum = IfcRailingTypeEnum

const IfcRampFlightTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRampFlightTypeEnum(v) {
    this.value = v
  }
  IfcRampFlightTypeEnum.STRAIGHT = 'STRAIGHT'
  IfcRampFlightTypeEnum.SPIRAL = 'SPIRAL'
  IfcRampFlightTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcRampFlightTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcRampFlightTypeEnum
}())
exports.IfcRampFlightTypeEnum = IfcRampFlightTypeEnum

const IfcRampTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRampTypeEnum(v) {
    this.value = v
  }
  IfcRampTypeEnum.STRAIGHT_RUN_RAMP = 'STRAIGHT_RUN_RAMP'
  IfcRampTypeEnum.TWO_STRAIGHT_RUN_RAMP = 'TWO_STRAIGHT_RUN_RAMP'
  IfcRampTypeEnum.QUARTER_TURN_RAMP = 'QUARTER_TURN_RAMP'
  IfcRampTypeEnum.TWO_QUARTER_TURN_RAMP = 'TWO_QUARTER_TURN_RAMP'
  IfcRampTypeEnum.HALF_TURN_RAMP = 'HALF_TURN_RAMP'
  IfcRampTypeEnum.SPIRAL_RAMP = 'SPIRAL_RAMP'
  IfcRampTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcRampTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcRampTypeEnum
}())
exports.IfcRampTypeEnum = IfcRampTypeEnum

const IfcRecurrenceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRecurrenceTypeEnum(v) {
    this.value = v
  }
  IfcRecurrenceTypeEnum.DAILY = 'DAILY'
  IfcRecurrenceTypeEnum.WEEKLY = 'WEEKLY'
  IfcRecurrenceTypeEnum.MONTHLY_BY_DAY_OF_MONTH = 'MONTHLY_BY_DAY_OF_MONTH'
  IfcRecurrenceTypeEnum.MONTHLY_BY_POSITION = 'MONTHLY_BY_POSITION'
  IfcRecurrenceTypeEnum.BY_DAY_COUNT = 'BY_DAY_COUNT'
  IfcRecurrenceTypeEnum.BY_WEEKDAY_COUNT = 'BY_WEEKDAY_COUNT'
  IfcRecurrenceTypeEnum.YEARLY_BY_DAY_OF_MONTH = 'YEARLY_BY_DAY_OF_MONTH'
  IfcRecurrenceTypeEnum.YEARLY_BY_POSITION = 'YEARLY_BY_POSITION'
  return IfcRecurrenceTypeEnum
}())
exports.IfcRecurrenceTypeEnum = IfcRecurrenceTypeEnum

const IfcReferentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReferentTypeEnum(v) {
    this.value = v
  }
  IfcReferentTypeEnum.KILOPOINT = 'KILOPOINT'
  IfcReferentTypeEnum.MILEPOINT = 'MILEPOINT'
  IfcReferentTypeEnum.STATION = 'STATION'
  IfcReferentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcReferentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcReferentTypeEnum
}())
exports.IfcReferentTypeEnum = IfcReferentTypeEnum

const IfcReflectanceMethodEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReflectanceMethodEnum(v) {
    this.value = v
  }
  IfcReflectanceMethodEnum.BLINN = 'BLINN'
  IfcReflectanceMethodEnum.FLAT = 'FLAT'
  IfcReflectanceMethodEnum.GLASS = 'GLASS'
  IfcReflectanceMethodEnum.MATT = 'MATT'
  IfcReflectanceMethodEnum.METAL = 'METAL'
  IfcReflectanceMethodEnum.MIRROR = 'MIRROR'
  IfcReflectanceMethodEnum.PHONG = 'PHONG'
  IfcReflectanceMethodEnum.PLASTIC = 'PLASTIC'
  IfcReflectanceMethodEnum.STRAUSS = 'STRAUSS'
  IfcReflectanceMethodEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcReflectanceMethodEnum
}())
exports.IfcReflectanceMethodEnum = IfcReflectanceMethodEnum

const IfcReinforcingBarRoleEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingBarRoleEnum(v) {
    this.value = v
  }
  IfcReinforcingBarRoleEnum.MAIN = 'MAIN'
  IfcReinforcingBarRoleEnum.SHEAR = 'SHEAR'
  IfcReinforcingBarRoleEnum.LIGATURE = 'LIGATURE'
  IfcReinforcingBarRoleEnum.STUD = 'STUD'
  IfcReinforcingBarRoleEnum.PUNCHING = 'PUNCHING'
  IfcReinforcingBarRoleEnum.EDGE = 'EDGE'
  IfcReinforcingBarRoleEnum.RING = 'RING'
  IfcReinforcingBarRoleEnum.ANCHORING = 'ANCHORING'
  IfcReinforcingBarRoleEnum.USERDEFINED = 'USERDEFINED'
  IfcReinforcingBarRoleEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcReinforcingBarRoleEnum
}())
exports.IfcReinforcingBarRoleEnum = IfcReinforcingBarRoleEnum

const IfcReinforcingBarSurfaceEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingBarSurfaceEnum(v) {
    this.value = v
  }
  IfcReinforcingBarSurfaceEnum.PLAIN = 'PLAIN'
  IfcReinforcingBarSurfaceEnum.TEXTURED = 'TEXTURED'
  return IfcReinforcingBarSurfaceEnum
}())
exports.IfcReinforcingBarSurfaceEnum = IfcReinforcingBarSurfaceEnum

const IfcReinforcingBarTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingBarTypeEnum(v) {
    this.value = v
  }
  IfcReinforcingBarTypeEnum.ANCHORING = 'ANCHORING'
  IfcReinforcingBarTypeEnum.EDGE = 'EDGE'
  IfcReinforcingBarTypeEnum.LIGATURE = 'LIGATURE'
  IfcReinforcingBarTypeEnum.MAIN = 'MAIN'
  IfcReinforcingBarTypeEnum.PUNCHING = 'PUNCHING'
  IfcReinforcingBarTypeEnum.RING = 'RING'
  IfcReinforcingBarTypeEnum.SHEAR = 'SHEAR'
  IfcReinforcingBarTypeEnum.STUD = 'STUD'
  IfcReinforcingBarTypeEnum.SPACEBAR = 'SPACEBAR'
  IfcReinforcingBarTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcReinforcingBarTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcReinforcingBarTypeEnum
}())
exports.IfcReinforcingBarTypeEnum = IfcReinforcingBarTypeEnum

const IfcReinforcingMeshTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingMeshTypeEnum(v) {
    this.value = v
  }
  IfcReinforcingMeshTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcReinforcingMeshTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcReinforcingMeshTypeEnum
}())
exports.IfcReinforcingMeshTypeEnum = IfcReinforcingMeshTypeEnum

const IfcRoleEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRoleEnum(v) {
    this.value = v
  }
  IfcRoleEnum.SUPPLIER = 'SUPPLIER'
  IfcRoleEnum.MANUFACTURER = 'MANUFACTURER'
  IfcRoleEnum.CONTRACTOR = 'CONTRACTOR'
  IfcRoleEnum.SUBCONTRACTOR = 'SUBCONTRACTOR'
  IfcRoleEnum.ARCHITECT = 'ARCHITECT'
  IfcRoleEnum.STRUCTURALENGINEER = 'STRUCTURALENGINEER'
  IfcRoleEnum.COSTENGINEER = 'COSTENGINEER'
  IfcRoleEnum.CLIENT = 'CLIENT'
  IfcRoleEnum.BUILDINGOWNER = 'BUILDINGOWNER'
  IfcRoleEnum.BUILDINGOPERATOR = 'BUILDINGOPERATOR'
  IfcRoleEnum.MECHANICALENGINEER = 'MECHANICALENGINEER'
  IfcRoleEnum.ELECTRICALENGINEER = 'ELECTRICALENGINEER'
  IfcRoleEnum.PROJECTMANAGER = 'PROJECTMANAGER'
  IfcRoleEnum.FACILITIESMANAGER = 'FACILITIESMANAGER'
  IfcRoleEnum.CIVILENGINEER = 'CIVILENGINEER'
  IfcRoleEnum.COMMISSIONINGENGINEER = 'COMMISSIONINGENGINEER'
  IfcRoleEnum.ENGINEER = 'ENGINEER'
  IfcRoleEnum.OWNER = 'OWNER'
  IfcRoleEnum.CONSULTANT = 'CONSULTANT'
  IfcRoleEnum.CONSTRUCTIONMANAGER = 'CONSTRUCTIONMANAGER'
  IfcRoleEnum.FIELDCONSTRUCTIONMANAGER = 'FIELDCONSTRUCTIONMANAGER'
  IfcRoleEnum.RESELLER = 'RESELLER'
  IfcRoleEnum.USERDEFINED = 'USERDEFINED'
  return IfcRoleEnum
}())
exports.IfcRoleEnum = IfcRoleEnum

const IfcRoofTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcRoofTypeEnum(v) {
    this.value = v
  }
  IfcRoofTypeEnum.FLAT_ROOF = 'FLAT_ROOF'
  IfcRoofTypeEnum.SHED_ROOF = 'SHED_ROOF'
  IfcRoofTypeEnum.GABLE_ROOF = 'GABLE_ROOF'
  IfcRoofTypeEnum.HIP_ROOF = 'HIP_ROOF'
  IfcRoofTypeEnum.HIPPED_GABLE_ROOF = 'HIPPED_GABLE_ROOF'
  IfcRoofTypeEnum.GAMBREL_ROOF = 'GAMBREL_ROOF'
  IfcRoofTypeEnum.MANSARD_ROOF = 'MANSARD_ROOF'
  IfcRoofTypeEnum.BARREL_ROOF = 'BARREL_ROOF'
  IfcRoofTypeEnum.RAINBOW_ROOF = 'RAINBOW_ROOF'
  IfcRoofTypeEnum.BUTTERFLY_ROOF = 'BUTTERFLY_ROOF'
  IfcRoofTypeEnum.PAVILION_ROOF = 'PAVILION_ROOF'
  IfcRoofTypeEnum.DOME_ROOF = 'DOME_ROOF'
  IfcRoofTypeEnum.FREEFORM = 'FREEFORM'
  IfcRoofTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcRoofTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcRoofTypeEnum
}())
exports.IfcRoofTypeEnum = IfcRoofTypeEnum

const IfcSIPrefix = /** @class */ (function() {
  /**
   *
   */
  function IfcSIPrefix(v) {
    this.value = v
  }
  IfcSIPrefix.EXA = 'EXA'
  IfcSIPrefix.PETA = 'PETA'
  IfcSIPrefix.TERA = 'TERA'
  IfcSIPrefix.GIGA = 'GIGA'
  IfcSIPrefix.MEGA = 'MEGA'
  IfcSIPrefix.KILO = 'KILO'
  IfcSIPrefix.HECTO = 'HECTO'
  IfcSIPrefix.DECA = 'DECA'
  IfcSIPrefix.DECI = 'DECI'
  IfcSIPrefix.CENTI = 'CENTI'
  IfcSIPrefix.MILLI = 'MILLI'
  IfcSIPrefix.MICRO = 'MICRO'
  IfcSIPrefix.NANO = 'NANO'
  IfcSIPrefix.PICO = 'PICO'
  IfcSIPrefix.FEMTO = 'FEMTO'
  IfcSIPrefix.ATTO = 'ATTO'
  return IfcSIPrefix
}())
exports.IfcSIPrefix = IfcSIPrefix

const IfcSIUnitName = /** @class */ (function() {
  /**
   *
   */
  function IfcSIUnitName(v) {
    this.value = v
  }
  IfcSIUnitName.AMPERE = 'AMPERE'
  IfcSIUnitName.BECQUEREL = 'BECQUEREL'
  IfcSIUnitName.CANDELA = 'CANDELA'
  IfcSIUnitName.COULOMB = 'COULOMB'
  IfcSIUnitName.CUBIC_METRE = 'CUBIC_METRE'
  IfcSIUnitName.DEGREE_CELSIUS = 'DEGREE_CELSIUS'
  IfcSIUnitName.FARAD = 'FARAD'
  IfcSIUnitName.GRAM = 'GRAM'
  IfcSIUnitName.GRAY = 'GRAY'
  IfcSIUnitName.HENRY = 'HENRY'
  IfcSIUnitName.HERTZ = 'HERTZ'
  IfcSIUnitName.JOULE = 'JOULE'
  IfcSIUnitName.KELVIN = 'KELVIN'
  IfcSIUnitName.LUMEN = 'LUMEN'
  IfcSIUnitName.LUX = 'LUX'
  IfcSIUnitName.METRE = 'METRE'
  IfcSIUnitName.MOLE = 'MOLE'
  IfcSIUnitName.NEWTON = 'NEWTON'
  IfcSIUnitName.OHM = 'OHM'
  IfcSIUnitName.PASCAL = 'PASCAL'
  IfcSIUnitName.RADIAN = 'RADIAN'
  IfcSIUnitName.SECOND = 'SECOND'
  IfcSIUnitName.SIEMENS = 'SIEMENS'
  IfcSIUnitName.SIEVERT = 'SIEVERT'
  IfcSIUnitName.SQUARE_METRE = 'SQUARE_METRE'
  IfcSIUnitName.STERADIAN = 'STERADIAN'
  IfcSIUnitName.TESLA = 'TESLA'
  IfcSIUnitName.VOLT = 'VOLT'
  IfcSIUnitName.WATT = 'WATT'
  IfcSIUnitName.WEBER = 'WEBER'
  return IfcSIUnitName
}())
exports.IfcSIUnitName = IfcSIUnitName

const IfcSanitaryTerminalTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSanitaryTerminalTypeEnum(v) {
    this.value = v
  }
  IfcSanitaryTerminalTypeEnum.BATH = 'BATH'
  IfcSanitaryTerminalTypeEnum.BIDET = 'BIDET'
  IfcSanitaryTerminalTypeEnum.CISTERN = 'CISTERN'
  IfcSanitaryTerminalTypeEnum.SHOWER = 'SHOWER'
  IfcSanitaryTerminalTypeEnum.SINK = 'SINK'
  IfcSanitaryTerminalTypeEnum.SANITARYFOUNTAIN = 'SANITARYFOUNTAIN'
  IfcSanitaryTerminalTypeEnum.TOILETPAN = 'TOILETPAN'
  IfcSanitaryTerminalTypeEnum.URINAL = 'URINAL'
  IfcSanitaryTerminalTypeEnum.WASHHANDBASIN = 'WASHHANDBASIN'
  IfcSanitaryTerminalTypeEnum.WCSEAT = 'WCSEAT'
  IfcSanitaryTerminalTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSanitaryTerminalTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSanitaryTerminalTypeEnum
}())
exports.IfcSanitaryTerminalTypeEnum = IfcSanitaryTerminalTypeEnum

const IfcSectionTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionTypeEnum(v) {
    this.value = v
  }
  IfcSectionTypeEnum.UNIFORM = 'UNIFORM'
  IfcSectionTypeEnum.TAPERED = 'TAPERED'
  return IfcSectionTypeEnum
}())
exports.IfcSectionTypeEnum = IfcSectionTypeEnum

const IfcSensorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSensorTypeEnum(v) {
    this.value = v
  }
  IfcSensorTypeEnum.COSENSOR = 'COSENSOR'
  IfcSensorTypeEnum.CO2SENSOR = 'CO2SENSOR'
  IfcSensorTypeEnum.CONDUCTANCESENSOR = 'CONDUCTANCESENSOR'
  IfcSensorTypeEnum.CONTACTSENSOR = 'CONTACTSENSOR'
  IfcSensorTypeEnum.FIRESENSOR = 'FIRESENSOR'
  IfcSensorTypeEnum.FLOWSENSOR = 'FLOWSENSOR'
  IfcSensorTypeEnum.FROSTSENSOR = 'FROSTSENSOR'
  IfcSensorTypeEnum.GASSENSOR = 'GASSENSOR'
  IfcSensorTypeEnum.HEATSENSOR = 'HEATSENSOR'
  IfcSensorTypeEnum.HUMIDITYSENSOR = 'HUMIDITYSENSOR'
  IfcSensorTypeEnum.IDENTIFIERSENSOR = 'IDENTIFIERSENSOR'
  IfcSensorTypeEnum.IONCONCENTRATIONSENSOR = 'IONCONCENTRATIONSENSOR'
  IfcSensorTypeEnum.LEVELSENSOR = 'LEVELSENSOR'
  IfcSensorTypeEnum.LIGHTSENSOR = 'LIGHTSENSOR'
  IfcSensorTypeEnum.MOISTURESENSOR = 'MOISTURESENSOR'
  IfcSensorTypeEnum.MOVEMENTSENSOR = 'MOVEMENTSENSOR'
  IfcSensorTypeEnum.PHSENSOR = 'PHSENSOR'
  IfcSensorTypeEnum.PRESSURESENSOR = 'PRESSURESENSOR'
  IfcSensorTypeEnum.RADIATIONSENSOR = 'RADIATIONSENSOR'
  IfcSensorTypeEnum.RADIOACTIVITYSENSOR = 'RADIOACTIVITYSENSOR'
  IfcSensorTypeEnum.SMOKESENSOR = 'SMOKESENSOR'
  IfcSensorTypeEnum.SOUNDSENSOR = 'SOUNDSENSOR'
  IfcSensorTypeEnum.TEMPERATURESENSOR = 'TEMPERATURESENSOR'
  IfcSensorTypeEnum.WINDSENSOR = 'WINDSENSOR'
  IfcSensorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSensorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSensorTypeEnum
}())
exports.IfcSensorTypeEnum = IfcSensorTypeEnum

const IfcSequenceEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSequenceEnum(v) {
    this.value = v
  }
  IfcSequenceEnum.START_START = 'START_START'
  IfcSequenceEnum.START_FINISH = 'START_FINISH'
  IfcSequenceEnum.FINISH_START = 'FINISH_START'
  IfcSequenceEnum.FINISH_FINISH = 'FINISH_FINISH'
  IfcSequenceEnum.USERDEFINED = 'USERDEFINED'
  IfcSequenceEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSequenceEnum
}())
exports.IfcSequenceEnum = IfcSequenceEnum

const IfcShadingDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcShadingDeviceTypeEnum(v) {
    this.value = v
  }
  IfcShadingDeviceTypeEnum.JALOUSIE = 'JALOUSIE'
  IfcShadingDeviceTypeEnum.SHUTTER = 'SHUTTER'
  IfcShadingDeviceTypeEnum.AWNING = 'AWNING'
  IfcShadingDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcShadingDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcShadingDeviceTypeEnum
}())
exports.IfcShadingDeviceTypeEnum = IfcShadingDeviceTypeEnum

const IfcSimplePropertyTemplateTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSimplePropertyTemplateTypeEnum(v) {
    this.value = v
  }
  IfcSimplePropertyTemplateTypeEnum.P_SINGLEVALUE = 'P_SINGLEVALUE'
  IfcSimplePropertyTemplateTypeEnum.P_ENUMERATEDVALUE = 'P_ENUMERATEDVALUE'
  IfcSimplePropertyTemplateTypeEnum.P_BOUNDEDVALUE = 'P_BOUNDEDVALUE'
  IfcSimplePropertyTemplateTypeEnum.P_LISTVALUE = 'P_LISTVALUE'
  IfcSimplePropertyTemplateTypeEnum.P_TABLEVALUE = 'P_TABLEVALUE'
  IfcSimplePropertyTemplateTypeEnum.P_REFERENCEVALUE = 'P_REFERENCEVALUE'
  IfcSimplePropertyTemplateTypeEnum.Q_LENGTH = 'Q_LENGTH'
  IfcSimplePropertyTemplateTypeEnum.Q_AREA = 'Q_AREA'
  IfcSimplePropertyTemplateTypeEnum.Q_VOLUME = 'Q_VOLUME'
  IfcSimplePropertyTemplateTypeEnum.Q_COUNT = 'Q_COUNT'
  IfcSimplePropertyTemplateTypeEnum.Q_WEIGHT = 'Q_WEIGHT'
  IfcSimplePropertyTemplateTypeEnum.Q_TIME = 'Q_TIME'
  return IfcSimplePropertyTemplateTypeEnum
}())
exports.IfcSimplePropertyTemplateTypeEnum = IfcSimplePropertyTemplateTypeEnum

const IfcSlabTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSlabTypeEnum(v) {
    this.value = v
  }
  IfcSlabTypeEnum.FLOOR = 'FLOOR'
  IfcSlabTypeEnum.ROOF = 'ROOF'
  IfcSlabTypeEnum.LANDING = 'LANDING'
  IfcSlabTypeEnum.BASESLAB = 'BASESLAB'
  IfcSlabTypeEnum.APPROACH_SLAB = 'APPROACH_SLAB'
  IfcSlabTypeEnum.PAVING = 'PAVING'
  IfcSlabTypeEnum.WEARING = 'WEARING'
  IfcSlabTypeEnum.SIDEWALK = 'SIDEWALK'
  IfcSlabTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSlabTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSlabTypeEnum
}())
exports.IfcSlabTypeEnum = IfcSlabTypeEnum

const IfcSolarDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSolarDeviceTypeEnum(v) {
    this.value = v
  }
  IfcSolarDeviceTypeEnum.SOLARCOLLECTOR = 'SOLARCOLLECTOR'
  IfcSolarDeviceTypeEnum.SOLARPANEL = 'SOLARPANEL'
  IfcSolarDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSolarDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSolarDeviceTypeEnum
}())
exports.IfcSolarDeviceTypeEnum = IfcSolarDeviceTypeEnum

const IfcSpaceHeaterTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSpaceHeaterTypeEnum(v) {
    this.value = v
  }
  IfcSpaceHeaterTypeEnum.CONVECTOR = 'CONVECTOR'
  IfcSpaceHeaterTypeEnum.RADIATOR = 'RADIATOR'
  IfcSpaceHeaterTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSpaceHeaterTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSpaceHeaterTypeEnum
}())
exports.IfcSpaceHeaterTypeEnum = IfcSpaceHeaterTypeEnum

const IfcSpaceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSpaceTypeEnum(v) {
    this.value = v
  }
  IfcSpaceTypeEnum.SPACE = 'SPACE'
  IfcSpaceTypeEnum.PARKING = 'PARKING'
  IfcSpaceTypeEnum.GFA = 'GFA'
  IfcSpaceTypeEnum.INTERNAL = 'INTERNAL'
  IfcSpaceTypeEnum.EXTERNAL = 'EXTERNAL'
  IfcSpaceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSpaceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSpaceTypeEnum
}())
exports.IfcSpaceTypeEnum = IfcSpaceTypeEnum

const IfcSpatialZoneTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialZoneTypeEnum(v) {
    this.value = v
  }
  IfcSpatialZoneTypeEnum.CONSTRUCTION = 'CONSTRUCTION'
  IfcSpatialZoneTypeEnum.FIRESAFETY = 'FIRESAFETY'
  IfcSpatialZoneTypeEnum.LIGHTING = 'LIGHTING'
  IfcSpatialZoneTypeEnum.OCCUPANCY = 'OCCUPANCY'
  IfcSpatialZoneTypeEnum.SECURITY = 'SECURITY'
  IfcSpatialZoneTypeEnum.THERMAL = 'THERMAL'
  IfcSpatialZoneTypeEnum.TRANSPORT = 'TRANSPORT'
  IfcSpatialZoneTypeEnum.VENTILATION = 'VENTILATION'
  IfcSpatialZoneTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSpatialZoneTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSpatialZoneTypeEnum
}())
exports.IfcSpatialZoneTypeEnum = IfcSpatialZoneTypeEnum

const IfcStackTerminalTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStackTerminalTypeEnum(v) {
    this.value = v
  }
  IfcStackTerminalTypeEnum.BIRDCAGE = 'BIRDCAGE'
  IfcStackTerminalTypeEnum.COWL = 'COWL'
  IfcStackTerminalTypeEnum.RAINWATERHOPPER = 'RAINWATERHOPPER'
  IfcStackTerminalTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStackTerminalTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStackTerminalTypeEnum
}())
exports.IfcStackTerminalTypeEnum = IfcStackTerminalTypeEnum

const IfcStairFlightTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStairFlightTypeEnum(v) {
    this.value = v
  }
  IfcStairFlightTypeEnum.STRAIGHT = 'STRAIGHT'
  IfcStairFlightTypeEnum.WINDER = 'WINDER'
  IfcStairFlightTypeEnum.SPIRAL = 'SPIRAL'
  IfcStairFlightTypeEnum.CURVED = 'CURVED'
  IfcStairFlightTypeEnum.FREEFORM = 'FREEFORM'
  IfcStairFlightTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStairFlightTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStairFlightTypeEnum
}())
exports.IfcStairFlightTypeEnum = IfcStairFlightTypeEnum

const IfcStairTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStairTypeEnum(v) {
    this.value = v
  }
  IfcStairTypeEnum.STRAIGHT_RUN_STAIR = 'STRAIGHT_RUN_STAIR'
  IfcStairTypeEnum.TWO_STRAIGHT_RUN_STAIR = 'TWO_STRAIGHT_RUN_STAIR'
  IfcStairTypeEnum.QUARTER_WINDING_STAIR = 'QUARTER_WINDING_STAIR'
  IfcStairTypeEnum.QUARTER_TURN_STAIR = 'QUARTER_TURN_STAIR'
  IfcStairTypeEnum.HALF_WINDING_STAIR = 'HALF_WINDING_STAIR'
  IfcStairTypeEnum.HALF_TURN_STAIR = 'HALF_TURN_STAIR'
  IfcStairTypeEnum.TWO_QUARTER_WINDING_STAIR = 'TWO_QUARTER_WINDING_STAIR'
  IfcStairTypeEnum.TWO_QUARTER_TURN_STAIR = 'TWO_QUARTER_TURN_STAIR'
  IfcStairTypeEnum.THREE_QUARTER_WINDING_STAIR = 'THREE_QUARTER_WINDING_STAIR'
  IfcStairTypeEnum.THREE_QUARTER_TURN_STAIR = 'THREE_QUARTER_TURN_STAIR'
  IfcStairTypeEnum.SPIRAL_STAIR = 'SPIRAL_STAIR'
  IfcStairTypeEnum.DOUBLE_RETURN_STAIR = 'DOUBLE_RETURN_STAIR'
  IfcStairTypeEnum.CURVED_RUN_STAIR = 'CURVED_RUN_STAIR'
  IfcStairTypeEnum.TWO_CURVED_RUN_STAIR = 'TWO_CURVED_RUN_STAIR'
  IfcStairTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStairTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStairTypeEnum
}())
exports.IfcStairTypeEnum = IfcStairTypeEnum

const IfcStateEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStateEnum(v) {
    this.value = v
  }
  IfcStateEnum.READWRITE = 'READWRITE'
  IfcStateEnum.READONLY = 'READONLY'
  IfcStateEnum.LOCKED = 'LOCKED'
  IfcStateEnum.READWRITELOCKED = 'READWRITELOCKED'
  IfcStateEnum.READONLYLOCKED = 'READONLYLOCKED'
  return IfcStateEnum
}())
exports.IfcStateEnum = IfcStateEnum

const IfcStructuralCurveActivityTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveActivityTypeEnum(v) {
    this.value = v
  }
  IfcStructuralCurveActivityTypeEnum.CONST = 'CONST'
  IfcStructuralCurveActivityTypeEnum.LINEAR = 'LINEAR'
  IfcStructuralCurveActivityTypeEnum.POLYGONAL = 'POLYGONAL'
  IfcStructuralCurveActivityTypeEnum.EQUIDISTANT = 'EQUIDISTANT'
  IfcStructuralCurveActivityTypeEnum.SINUS = 'SINUS'
  IfcStructuralCurveActivityTypeEnum.PARABOLA = 'PARABOLA'
  IfcStructuralCurveActivityTypeEnum.DISCRETE = 'DISCRETE'
  IfcStructuralCurveActivityTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStructuralCurveActivityTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStructuralCurveActivityTypeEnum
}())
exports.IfcStructuralCurveActivityTypeEnum = IfcStructuralCurveActivityTypeEnum

const IfcStructuralCurveMemberTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveMemberTypeEnum(v) {
    this.value = v
  }
  IfcStructuralCurveMemberTypeEnum.RIGID_JOINED_MEMBER = 'RIGID_JOINED_MEMBER'
  IfcStructuralCurveMemberTypeEnum.PIN_JOINED_MEMBER = 'PIN_JOINED_MEMBER'
  IfcStructuralCurveMemberTypeEnum.CABLE = 'CABLE'
  IfcStructuralCurveMemberTypeEnum.TENSION_MEMBER = 'TENSION_MEMBER'
  IfcStructuralCurveMemberTypeEnum.COMPRESSION_MEMBER = 'COMPRESSION_MEMBER'
  IfcStructuralCurveMemberTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStructuralCurveMemberTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStructuralCurveMemberTypeEnum
}())
exports.IfcStructuralCurveMemberTypeEnum = IfcStructuralCurveMemberTypeEnum

const IfcStructuralSurfaceActivityTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceActivityTypeEnum(v) {
    this.value = v
  }
  IfcStructuralSurfaceActivityTypeEnum.CONST = 'CONST'
  IfcStructuralSurfaceActivityTypeEnum.BILINEAR = 'BILINEAR'
  IfcStructuralSurfaceActivityTypeEnum.DISCRETE = 'DISCRETE'
  IfcStructuralSurfaceActivityTypeEnum.ISOCONTOUR = 'ISOCONTOUR'
  IfcStructuralSurfaceActivityTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStructuralSurfaceActivityTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStructuralSurfaceActivityTypeEnum
}())
exports.IfcStructuralSurfaceActivityTypeEnum = IfcStructuralSurfaceActivityTypeEnum

const IfcStructuralSurfaceMemberTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceMemberTypeEnum(v) {
    this.value = v
  }
  IfcStructuralSurfaceMemberTypeEnum.BENDING_ELEMENT = 'BENDING_ELEMENT'
  IfcStructuralSurfaceMemberTypeEnum.MEMBRANE_ELEMENT = 'MEMBRANE_ELEMENT'
  IfcStructuralSurfaceMemberTypeEnum.SHELL = 'SHELL'
  IfcStructuralSurfaceMemberTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcStructuralSurfaceMemberTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcStructuralSurfaceMemberTypeEnum
}())
exports.IfcStructuralSurfaceMemberTypeEnum = IfcStructuralSurfaceMemberTypeEnum

const IfcSubContractResourceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSubContractResourceTypeEnum(v) {
    this.value = v
  }
  IfcSubContractResourceTypeEnum.PURCHASE = 'PURCHASE'
  IfcSubContractResourceTypeEnum.WORK = 'WORK'
  IfcSubContractResourceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSubContractResourceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSubContractResourceTypeEnum
}())
exports.IfcSubContractResourceTypeEnum = IfcSubContractResourceTypeEnum

const IfcSurfaceFeatureTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceFeatureTypeEnum(v) {
    this.value = v
  }
  IfcSurfaceFeatureTypeEnum.MARK = 'MARK'
  IfcSurfaceFeatureTypeEnum.TAG = 'TAG'
  IfcSurfaceFeatureTypeEnum.TREATMENT = 'TREATMENT'
  IfcSurfaceFeatureTypeEnum.DEFECT = 'DEFECT'
  IfcSurfaceFeatureTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSurfaceFeatureTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSurfaceFeatureTypeEnum
}())
exports.IfcSurfaceFeatureTypeEnum = IfcSurfaceFeatureTypeEnum

const IfcSurfaceSide = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceSide(v) {
    this.value = v
  }
  IfcSurfaceSide.POSITIVE = 'POSITIVE'
  IfcSurfaceSide.NEGATIVE = 'NEGATIVE'
  IfcSurfaceSide.BOTH = 'BOTH'
  return IfcSurfaceSide
}())
exports.IfcSurfaceSide = IfcSurfaceSide

const IfcSwitchingDeviceTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSwitchingDeviceTypeEnum(v) {
    this.value = v
  }
  IfcSwitchingDeviceTypeEnum.CONTACTOR = 'CONTACTOR'
  IfcSwitchingDeviceTypeEnum.DIMMERSWITCH = 'DIMMERSWITCH'
  IfcSwitchingDeviceTypeEnum.EMERGENCYSTOP = 'EMERGENCYSTOP'
  IfcSwitchingDeviceTypeEnum.KEYPAD = 'KEYPAD'
  IfcSwitchingDeviceTypeEnum.MOMENTARYSWITCH = 'MOMENTARYSWITCH'
  IfcSwitchingDeviceTypeEnum.SELECTORSWITCH = 'SELECTORSWITCH'
  IfcSwitchingDeviceTypeEnum.STARTER = 'STARTER'
  IfcSwitchingDeviceTypeEnum.SWITCHDISCONNECTOR = 'SWITCHDISCONNECTOR'
  IfcSwitchingDeviceTypeEnum.TOGGLESWITCH = 'TOGGLESWITCH'
  IfcSwitchingDeviceTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSwitchingDeviceTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSwitchingDeviceTypeEnum
}())
exports.IfcSwitchingDeviceTypeEnum = IfcSwitchingDeviceTypeEnum

const IfcSystemFurnitureElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcSystemFurnitureElementTypeEnum(v) {
    this.value = v
  }
  IfcSystemFurnitureElementTypeEnum.PANEL = 'PANEL'
  IfcSystemFurnitureElementTypeEnum.WORKSURFACE = 'WORKSURFACE'
  IfcSystemFurnitureElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcSystemFurnitureElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcSystemFurnitureElementTypeEnum
}())
exports.IfcSystemFurnitureElementTypeEnum = IfcSystemFurnitureElementTypeEnum

const IfcTankTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTankTypeEnum(v) {
    this.value = v
  }
  IfcTankTypeEnum.BASIN = 'BASIN'
  IfcTankTypeEnum.BREAKPRESSURE = 'BREAKPRESSURE'
  IfcTankTypeEnum.EXPANSION = 'EXPANSION'
  IfcTankTypeEnum.FEEDANDEXPANSION = 'FEEDANDEXPANSION'
  IfcTankTypeEnum.PRESSUREVESSEL = 'PRESSUREVESSEL'
  IfcTankTypeEnum.STORAGE = 'STORAGE'
  IfcTankTypeEnum.VESSEL = 'VESSEL'
  IfcTankTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTankTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTankTypeEnum
}())
exports.IfcTankTypeEnum = IfcTankTypeEnum

const IfcTaskDurationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTaskDurationEnum(v) {
    this.value = v
  }
  IfcTaskDurationEnum.ELAPSEDTIME = 'ELAPSEDTIME'
  IfcTaskDurationEnum.WORKTIME = 'WORKTIME'
  IfcTaskDurationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTaskDurationEnum
}())
exports.IfcTaskDurationEnum = IfcTaskDurationEnum

const IfcTaskTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTaskTypeEnum(v) {
    this.value = v
  }
  IfcTaskTypeEnum.ATTENDANCE = 'ATTENDANCE'
  IfcTaskTypeEnum.CONSTRUCTION = 'CONSTRUCTION'
  IfcTaskTypeEnum.DEMOLITION = 'DEMOLITION'
  IfcTaskTypeEnum.DISMANTLE = 'DISMANTLE'
  IfcTaskTypeEnum.DISPOSAL = 'DISPOSAL'
  IfcTaskTypeEnum.INSTALLATION = 'INSTALLATION'
  IfcTaskTypeEnum.LOGISTIC = 'LOGISTIC'
  IfcTaskTypeEnum.MAINTENANCE = 'MAINTENANCE'
  IfcTaskTypeEnum.MOVE = 'MOVE'
  IfcTaskTypeEnum.OPERATION = 'OPERATION'
  IfcTaskTypeEnum.REMOVAL = 'REMOVAL'
  IfcTaskTypeEnum.RENOVATION = 'RENOVATION'
  IfcTaskTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTaskTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTaskTypeEnum
}())
exports.IfcTaskTypeEnum = IfcTaskTypeEnum

const IfcTendonAnchorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonAnchorTypeEnum(v) {
    this.value = v
  }
  IfcTendonAnchorTypeEnum.COUPLER = 'COUPLER'
  IfcTendonAnchorTypeEnum.FIXED_END = 'FIXED_END'
  IfcTendonAnchorTypeEnum.TENSIONING_END = 'TENSIONING_END'
  IfcTendonAnchorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTendonAnchorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTendonAnchorTypeEnum
}())
exports.IfcTendonAnchorTypeEnum = IfcTendonAnchorTypeEnum

const IfcTendonConduitTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonConduitTypeEnum(v) {
    this.value = v
  }
  IfcTendonConduitTypeEnum.DUCT = 'DUCT'
  IfcTendonConduitTypeEnum.COUPLER = 'COUPLER'
  IfcTendonConduitTypeEnum.GROUTING_DUCT = 'GROUTING_DUCT'
  IfcTendonConduitTypeEnum.TRUMPET = 'TRUMPET'
  IfcTendonConduitTypeEnum.DIABOLO = 'DIABOLO'
  IfcTendonConduitTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTendonConduitTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTendonConduitTypeEnum
}())
exports.IfcTendonConduitTypeEnum = IfcTendonConduitTypeEnum

const IfcTendonTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonTypeEnum(v) {
    this.value = v
  }
  IfcTendonTypeEnum.BAR = 'BAR'
  IfcTendonTypeEnum.COATED = 'COATED'
  IfcTendonTypeEnum.STRAND = 'STRAND'
  IfcTendonTypeEnum.WIRE = 'WIRE'
  IfcTendonTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTendonTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTendonTypeEnum
}())
exports.IfcTendonTypeEnum = IfcTendonTypeEnum

const IfcTextPath = /** @class */ (function() {
  /**
   *
   */
  function IfcTextPath(v) {
    this.value = v
  }
  IfcTextPath.LEFT = 'LEFT'
  IfcTextPath.RIGHT = 'RIGHT'
  IfcTextPath.UP = 'UP'
  IfcTextPath.DOWN = 'DOWN'
  return IfcTextPath
}())
exports.IfcTextPath = IfcTextPath

const IfcTimeSeriesDataTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTimeSeriesDataTypeEnum(v) {
    this.value = v
  }
  IfcTimeSeriesDataTypeEnum.CONTINUOUS = 'CONTINUOUS'
  IfcTimeSeriesDataTypeEnum.DISCRETE = 'DISCRETE'
  IfcTimeSeriesDataTypeEnum.DISCRETEBINARY = 'DISCRETEBINARY'
  IfcTimeSeriesDataTypeEnum.PIECEWISEBINARY = 'PIECEWISEBINARY'
  IfcTimeSeriesDataTypeEnum.PIECEWISECONSTANT = 'PIECEWISECONSTANT'
  IfcTimeSeriesDataTypeEnum.PIECEWISECONTINUOUS = 'PIECEWISECONTINUOUS'
  IfcTimeSeriesDataTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTimeSeriesDataTypeEnum
}())
exports.IfcTimeSeriesDataTypeEnum = IfcTimeSeriesDataTypeEnum

const IfcTransformerTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTransformerTypeEnum(v) {
    this.value = v
  }
  IfcTransformerTypeEnum.CURRENT = 'CURRENT'
  IfcTransformerTypeEnum.FREQUENCY = 'FREQUENCY'
  IfcTransformerTypeEnum.INVERTER = 'INVERTER'
  IfcTransformerTypeEnum.RECTIFIER = 'RECTIFIER'
  IfcTransformerTypeEnum.VOLTAGE = 'VOLTAGE'
  IfcTransformerTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTransformerTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTransformerTypeEnum
}())
exports.IfcTransformerTypeEnum = IfcTransformerTypeEnum

const IfcTransitionCode = /** @class */ (function() {
  /**
   *
   */
  function IfcTransitionCode(v) {
    this.value = v
  }
  IfcTransitionCode.DISCONTINUOUS = 'DISCONTINUOUS'
  IfcTransitionCode.CONTINUOUS = 'CONTINUOUS'
  IfcTransitionCode.CONTSAMEGRADIENT = 'CONTSAMEGRADIENT'
  IfcTransitionCode.CONTSAMEGRADIENTSAMECURVATURE = 'CONTSAMEGRADIENTSAMECURVATURE'
  return IfcTransitionCode
}())
exports.IfcTransitionCode = IfcTransitionCode

const IfcTransitionCurveType = /** @class */ (function() {
  /**
   *
   */
  function IfcTransitionCurveType(v) {
    this.value = v
  }
  IfcTransitionCurveType.BIQUADRATICPARABOLA = 'BIQUADRATICPARABOLA'
  IfcTransitionCurveType.BLOSSCURVE = 'BLOSSCURVE'
  IfcTransitionCurveType.CLOTHOIDCURVE = 'CLOTHOIDCURVE'
  IfcTransitionCurveType.COSINECURVE = 'COSINECURVE'
  IfcTransitionCurveType.CUBICPARABOLA = 'CUBICPARABOLA'
  IfcTransitionCurveType.SINECURVE = 'SINECURVE'
  return IfcTransitionCurveType
}())
exports.IfcTransitionCurveType = IfcTransitionCurveType

const IfcTransportElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTransportElementTypeEnum(v) {
    this.value = v
  }
  IfcTransportElementTypeEnum.ELEVATOR = 'ELEVATOR'
  IfcTransportElementTypeEnum.ESCALATOR = 'ESCALATOR'
  IfcTransportElementTypeEnum.MOVINGWALKWAY = 'MOVINGWALKWAY'
  IfcTransportElementTypeEnum.CRANEWAY = 'CRANEWAY'
  IfcTransportElementTypeEnum.LIFTINGGEAR = 'LIFTINGGEAR'
  IfcTransportElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTransportElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTransportElementTypeEnum
}())
exports.IfcTransportElementTypeEnum = IfcTransportElementTypeEnum

const IfcTrimmingPreference = /** @class */ (function() {
  /**
   *
   */
  function IfcTrimmingPreference(v) {
    this.value = v
  }
  IfcTrimmingPreference.CARTESIAN = 'CARTESIAN'
  IfcTrimmingPreference.PARAMETER = 'PARAMETER'
  IfcTrimmingPreference.UNSPECIFIED = 'UNSPECIFIED'
  return IfcTrimmingPreference
}())
exports.IfcTrimmingPreference = IfcTrimmingPreference

const IfcTubeBundleTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcTubeBundleTypeEnum(v) {
    this.value = v
  }
  IfcTubeBundleTypeEnum.FINNED = 'FINNED'
  IfcTubeBundleTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcTubeBundleTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcTubeBundleTypeEnum
}())
exports.IfcTubeBundleTypeEnum = IfcTubeBundleTypeEnum

const IfcUnitEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitEnum(v) {
    this.value = v
  }
  IfcUnitEnum.ABSORBEDDOSEUNIT = 'ABSORBEDDOSEUNIT'
  IfcUnitEnum.AMOUNTOFSUBSTANCEUNIT = 'AMOUNTOFSUBSTANCEUNIT'
  IfcUnitEnum.AREAUNIT = 'AREAUNIT'
  IfcUnitEnum.DOSEEQUIVALENTUNIT = 'DOSEEQUIVALENTUNIT'
  IfcUnitEnum.ELECTRICCAPACITANCEUNIT = 'ELECTRICCAPACITANCEUNIT'
  IfcUnitEnum.ELECTRICCHARGEUNIT = 'ELECTRICCHARGEUNIT'
  IfcUnitEnum.ELECTRICCONDUCTANCEUNIT = 'ELECTRICCONDUCTANCEUNIT'
  IfcUnitEnum.ELECTRICCURRENTUNIT = 'ELECTRICCURRENTUNIT'
  IfcUnitEnum.ELECTRICRESISTANCEUNIT = 'ELECTRICRESISTANCEUNIT'
  IfcUnitEnum.ELECTRICVOLTAGEUNIT = 'ELECTRICVOLTAGEUNIT'
  IfcUnitEnum.ENERGYUNIT = 'ENERGYUNIT'
  IfcUnitEnum.FORCEUNIT = 'FORCEUNIT'
  IfcUnitEnum.FREQUENCYUNIT = 'FREQUENCYUNIT'
  IfcUnitEnum.ILLUMINANCEUNIT = 'ILLUMINANCEUNIT'
  IfcUnitEnum.INDUCTANCEUNIT = 'INDUCTANCEUNIT'
  IfcUnitEnum.LENGTHUNIT = 'LENGTHUNIT'
  IfcUnitEnum.LUMINOUSFLUXUNIT = 'LUMINOUSFLUXUNIT'
  IfcUnitEnum.LUMINOUSINTENSITYUNIT = 'LUMINOUSINTENSITYUNIT'
  IfcUnitEnum.MAGNETICFLUXDENSITYUNIT = 'MAGNETICFLUXDENSITYUNIT'
  IfcUnitEnum.MAGNETICFLUXUNIT = 'MAGNETICFLUXUNIT'
  IfcUnitEnum.MASSUNIT = 'MASSUNIT'
  IfcUnitEnum.PLANEANGLEUNIT = 'PLANEANGLEUNIT'
  IfcUnitEnum.POWERUNIT = 'POWERUNIT'
  IfcUnitEnum.PRESSUREUNIT = 'PRESSUREUNIT'
  IfcUnitEnum.RADIOACTIVITYUNIT = 'RADIOACTIVITYUNIT'
  IfcUnitEnum.SOLIDANGLEUNIT = 'SOLIDANGLEUNIT'
  IfcUnitEnum.THERMODYNAMICTEMPERATUREUNIT = 'THERMODYNAMICTEMPERATUREUNIT'
  IfcUnitEnum.TIMEUNIT = 'TIMEUNIT'
  IfcUnitEnum.VOLUMEUNIT = 'VOLUMEUNIT'
  IfcUnitEnum.USERDEFINED = 'USERDEFINED'
  return IfcUnitEnum
}())
exports.IfcUnitEnum = IfcUnitEnum

const IfcUnitaryControlElementTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryControlElementTypeEnum(v) {
    this.value = v
  }
  IfcUnitaryControlElementTypeEnum.ALARMPANEL = 'ALARMPANEL'
  IfcUnitaryControlElementTypeEnum.CONTROLPANEL = 'CONTROLPANEL'
  IfcUnitaryControlElementTypeEnum.GASDETECTIONPANEL = 'GASDETECTIONPANEL'
  IfcUnitaryControlElementTypeEnum.INDICATORPANEL = 'INDICATORPANEL'
  IfcUnitaryControlElementTypeEnum.MIMICPANEL = 'MIMICPANEL'
  IfcUnitaryControlElementTypeEnum.HUMIDISTAT = 'HUMIDISTAT'
  IfcUnitaryControlElementTypeEnum.THERMOSTAT = 'THERMOSTAT'
  IfcUnitaryControlElementTypeEnum.WEATHERSTATION = 'WEATHERSTATION'
  IfcUnitaryControlElementTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcUnitaryControlElementTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcUnitaryControlElementTypeEnum
}())
exports.IfcUnitaryControlElementTypeEnum = IfcUnitaryControlElementTypeEnum

const IfcUnitaryEquipmentTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryEquipmentTypeEnum(v) {
    this.value = v
  }
  IfcUnitaryEquipmentTypeEnum.AIRHANDLER = 'AIRHANDLER'
  IfcUnitaryEquipmentTypeEnum.AIRCONDITIONINGUNIT = 'AIRCONDITIONINGUNIT'
  IfcUnitaryEquipmentTypeEnum.DEHUMIDIFIER = 'DEHUMIDIFIER'
  IfcUnitaryEquipmentTypeEnum.SPLITSYSTEM = 'SPLITSYSTEM'
  IfcUnitaryEquipmentTypeEnum.ROOFTOPUNIT = 'ROOFTOPUNIT'
  IfcUnitaryEquipmentTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcUnitaryEquipmentTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcUnitaryEquipmentTypeEnum
}())
exports.IfcUnitaryEquipmentTypeEnum = IfcUnitaryEquipmentTypeEnum

const IfcValveTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcValveTypeEnum(v) {
    this.value = v
  }
  IfcValveTypeEnum.AIRRELEASE = 'AIRRELEASE'
  IfcValveTypeEnum.ANTIVACUUM = 'ANTIVACUUM'
  IfcValveTypeEnum.CHANGEOVER = 'CHANGEOVER'
  IfcValveTypeEnum.CHECK = 'CHECK'
  IfcValveTypeEnum.COMMISSIONING = 'COMMISSIONING'
  IfcValveTypeEnum.DIVERTING = 'DIVERTING'
  IfcValveTypeEnum.DRAWOFFCOCK = 'DRAWOFFCOCK'
  IfcValveTypeEnum.DOUBLECHECK = 'DOUBLECHECK'
  IfcValveTypeEnum.DOUBLEREGULATING = 'DOUBLEREGULATING'
  IfcValveTypeEnum.FAUCET = 'FAUCET'
  IfcValveTypeEnum.FLUSHING = 'FLUSHING'
  IfcValveTypeEnum.GASCOCK = 'GASCOCK'
  IfcValveTypeEnum.GASTAP = 'GASTAP'
  IfcValveTypeEnum.ISOLATING = 'ISOLATING'
  IfcValveTypeEnum.MIXING = 'MIXING'
  IfcValveTypeEnum.PRESSUREREDUCING = 'PRESSUREREDUCING'
  IfcValveTypeEnum.PRESSURERELIEF = 'PRESSURERELIEF'
  IfcValveTypeEnum.REGULATING = 'REGULATING'
  IfcValveTypeEnum.SAFETYCUTOFF = 'SAFETYCUTOFF'
  IfcValveTypeEnum.STEAMTRAP = 'STEAMTRAP'
  IfcValveTypeEnum.STOPCOCK = 'STOPCOCK'
  IfcValveTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcValveTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcValveTypeEnum
}())
exports.IfcValveTypeEnum = IfcValveTypeEnum

const IfcVibrationDamperTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationDamperTypeEnum(v) {
    this.value = v
  }
  IfcVibrationDamperTypeEnum.BENDING_YIELD = 'BENDING_YIELD'
  IfcVibrationDamperTypeEnum.SHEAR_YIELD = 'SHEAR_YIELD'
  IfcVibrationDamperTypeEnum.AXIAL_YIELD = 'AXIAL_YIELD'
  IfcVibrationDamperTypeEnum.FRICTION = 'FRICTION'
  IfcVibrationDamperTypeEnum.VISCOUS = 'VISCOUS'
  IfcVibrationDamperTypeEnum.RUBBER = 'RUBBER'
  IfcVibrationDamperTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcVibrationDamperTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcVibrationDamperTypeEnum
}())
exports.IfcVibrationDamperTypeEnum = IfcVibrationDamperTypeEnum

const IfcVibrationIsolatorTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationIsolatorTypeEnum(v) {
    this.value = v
  }
  IfcVibrationIsolatorTypeEnum.COMPRESSION = 'COMPRESSION'
  IfcVibrationIsolatorTypeEnum.SPRING = 'SPRING'
  IfcVibrationIsolatorTypeEnum.BASE = 'BASE'
  IfcVibrationIsolatorTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcVibrationIsolatorTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcVibrationIsolatorTypeEnum
}())
exports.IfcVibrationIsolatorTypeEnum = IfcVibrationIsolatorTypeEnum

const IfcVoidingFeatureTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcVoidingFeatureTypeEnum(v) {
    this.value = v
  }
  IfcVoidingFeatureTypeEnum.CUTOUT = 'CUTOUT'
  IfcVoidingFeatureTypeEnum.NOTCH = 'NOTCH'
  IfcVoidingFeatureTypeEnum.HOLE = 'HOLE'
  IfcVoidingFeatureTypeEnum.MITER = 'MITER'
  IfcVoidingFeatureTypeEnum.CHAMFER = 'CHAMFER'
  IfcVoidingFeatureTypeEnum.EDGE = 'EDGE'
  IfcVoidingFeatureTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcVoidingFeatureTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcVoidingFeatureTypeEnum
}())
exports.IfcVoidingFeatureTypeEnum = IfcVoidingFeatureTypeEnum

const IfcWallTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWallTypeEnum(v) {
    this.value = v
  }
  IfcWallTypeEnum.MOVABLE = 'MOVABLE'
  IfcWallTypeEnum.PARAPET = 'PARAPET'
  IfcWallTypeEnum.PARTITIONING = 'PARTITIONING'
  IfcWallTypeEnum.PLUMBINGWALL = 'PLUMBINGWALL'
  IfcWallTypeEnum.SHEAR = 'SHEAR'
  IfcWallTypeEnum.SOLIDWALL = 'SOLIDWALL'
  IfcWallTypeEnum.STANDARD = 'STANDARD'
  IfcWallTypeEnum.POLYGONAL = 'POLYGONAL'
  IfcWallTypeEnum.ELEMENTEDWALL = 'ELEMENTEDWALL'
  IfcWallTypeEnum.RETAININGWALL = 'RETAININGWALL'
  IfcWallTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWallTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWallTypeEnum
}())
exports.IfcWallTypeEnum = IfcWallTypeEnum

const IfcWasteTerminalTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWasteTerminalTypeEnum(v) {
    this.value = v
  }
  IfcWasteTerminalTypeEnum.FLOORTRAP = 'FLOORTRAP'
  IfcWasteTerminalTypeEnum.FLOORWASTE = 'FLOORWASTE'
  IfcWasteTerminalTypeEnum.GULLYSUMP = 'GULLYSUMP'
  IfcWasteTerminalTypeEnum.GULLYTRAP = 'GULLYTRAP'
  IfcWasteTerminalTypeEnum.ROOFDRAIN = 'ROOFDRAIN'
  IfcWasteTerminalTypeEnum.WASTEDISPOSALUNIT = 'WASTEDISPOSALUNIT'
  IfcWasteTerminalTypeEnum.WASTETRAP = 'WASTETRAP'
  IfcWasteTerminalTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWasteTerminalTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWasteTerminalTypeEnum
}())
exports.IfcWasteTerminalTypeEnum = IfcWasteTerminalTypeEnum

const IfcWindowPanelOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowPanelOperationEnum(v) {
    this.value = v
  }
  IfcWindowPanelOperationEnum.SIDEHUNGRIGHTHAND = 'SIDEHUNGRIGHTHAND'
  IfcWindowPanelOperationEnum.SIDEHUNGLEFTHAND = 'SIDEHUNGLEFTHAND'
  IfcWindowPanelOperationEnum.TILTANDTURNRIGHTHAND = 'TILTANDTURNRIGHTHAND'
  IfcWindowPanelOperationEnum.TILTANDTURNLEFTHAND = 'TILTANDTURNLEFTHAND'
  IfcWindowPanelOperationEnum.TOPHUNG = 'TOPHUNG'
  IfcWindowPanelOperationEnum.BOTTOMHUNG = 'BOTTOMHUNG'
  IfcWindowPanelOperationEnum.PIVOTHORIZONTAL = 'PIVOTHORIZONTAL'
  IfcWindowPanelOperationEnum.PIVOTVERTICAL = 'PIVOTVERTICAL'
  IfcWindowPanelOperationEnum.SLIDINGHORIZONTAL = 'SLIDINGHORIZONTAL'
  IfcWindowPanelOperationEnum.SLIDINGVERTICAL = 'SLIDINGVERTICAL'
  IfcWindowPanelOperationEnum.REMOVABLECASEMENT = 'REMOVABLECASEMENT'
  IfcWindowPanelOperationEnum.FIXEDCASEMENT = 'FIXEDCASEMENT'
  IfcWindowPanelOperationEnum.OTHEROPERATION = 'OTHEROPERATION'
  IfcWindowPanelOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowPanelOperationEnum
}())
exports.IfcWindowPanelOperationEnum = IfcWindowPanelOperationEnum

const IfcWindowPanelPositionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowPanelPositionEnum(v) {
    this.value = v
  }
  IfcWindowPanelPositionEnum.LEFT = 'LEFT'
  IfcWindowPanelPositionEnum.MIDDLE = 'MIDDLE'
  IfcWindowPanelPositionEnum.RIGHT = 'RIGHT'
  IfcWindowPanelPositionEnum.BOTTOM = 'BOTTOM'
  IfcWindowPanelPositionEnum.TOP = 'TOP'
  IfcWindowPanelPositionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowPanelPositionEnum
}())
exports.IfcWindowPanelPositionEnum = IfcWindowPanelPositionEnum

const IfcWindowStyleConstructionEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowStyleConstructionEnum(v) {
    this.value = v
  }
  IfcWindowStyleConstructionEnum.ALUMINIUM = 'ALUMINIUM'
  IfcWindowStyleConstructionEnum.HIGH_GRADE_STEEL = 'HIGH_GRADE_STEEL'
  IfcWindowStyleConstructionEnum.STEEL = 'STEEL'
  IfcWindowStyleConstructionEnum.WOOD = 'WOOD'
  IfcWindowStyleConstructionEnum.ALUMINIUM_WOOD = 'ALUMINIUM_WOOD'
  IfcWindowStyleConstructionEnum.PLASTIC = 'PLASTIC'
  IfcWindowStyleConstructionEnum.OTHER_CONSTRUCTION = 'OTHER_CONSTRUCTION'
  IfcWindowStyleConstructionEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowStyleConstructionEnum
}())
exports.IfcWindowStyleConstructionEnum = IfcWindowStyleConstructionEnum

const IfcWindowStyleOperationEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowStyleOperationEnum(v) {
    this.value = v
  }
  IfcWindowStyleOperationEnum.SINGLE_PANEL = 'SINGLE_PANEL'
  IfcWindowStyleOperationEnum.DOUBLE_PANEL_VERTICAL = 'DOUBLE_PANEL_VERTICAL'
  IfcWindowStyleOperationEnum.DOUBLE_PANEL_HORIZONTAL = 'DOUBLE_PANEL_HORIZONTAL'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_VERTICAL = 'TRIPLE_PANEL_VERTICAL'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_BOTTOM = 'TRIPLE_PANEL_BOTTOM'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_TOP = 'TRIPLE_PANEL_TOP'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_LEFT = 'TRIPLE_PANEL_LEFT'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_RIGHT = 'TRIPLE_PANEL_RIGHT'
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_HORIZONTAL = 'TRIPLE_PANEL_HORIZONTAL'
  IfcWindowStyleOperationEnum.USERDEFINED = 'USERDEFINED'
  IfcWindowStyleOperationEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowStyleOperationEnum
}())
exports.IfcWindowStyleOperationEnum = IfcWindowStyleOperationEnum

const IfcWindowTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowTypeEnum(v) {
    this.value = v
  }
  IfcWindowTypeEnum.WINDOW = 'WINDOW'
  IfcWindowTypeEnum.SKYLIGHT = 'SKYLIGHT'
  IfcWindowTypeEnum.LIGHTDOME = 'LIGHTDOME'
  IfcWindowTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWindowTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowTypeEnum
}())
exports.IfcWindowTypeEnum = IfcWindowTypeEnum

const IfcWindowTypePartitioningEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowTypePartitioningEnum(v) {
    this.value = v
  }
  IfcWindowTypePartitioningEnum.SINGLE_PANEL = 'SINGLE_PANEL'
  IfcWindowTypePartitioningEnum.DOUBLE_PANEL_VERTICAL = 'DOUBLE_PANEL_VERTICAL'
  IfcWindowTypePartitioningEnum.DOUBLE_PANEL_HORIZONTAL = 'DOUBLE_PANEL_HORIZONTAL'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_VERTICAL = 'TRIPLE_PANEL_VERTICAL'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_BOTTOM = 'TRIPLE_PANEL_BOTTOM'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_TOP = 'TRIPLE_PANEL_TOP'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_LEFT = 'TRIPLE_PANEL_LEFT'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_RIGHT = 'TRIPLE_PANEL_RIGHT'
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_HORIZONTAL = 'TRIPLE_PANEL_HORIZONTAL'
  IfcWindowTypePartitioningEnum.USERDEFINED = 'USERDEFINED'
  IfcWindowTypePartitioningEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWindowTypePartitioningEnum
}())
exports.IfcWindowTypePartitioningEnum = IfcWindowTypePartitioningEnum

const IfcWorkCalendarTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkCalendarTypeEnum(v) {
    this.value = v
  }
  IfcWorkCalendarTypeEnum.FIRSTSHIFT = 'FIRSTSHIFT'
  IfcWorkCalendarTypeEnum.SECONDSHIFT = 'SECONDSHIFT'
  IfcWorkCalendarTypeEnum.THIRDSHIFT = 'THIRDSHIFT'
  IfcWorkCalendarTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWorkCalendarTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWorkCalendarTypeEnum
}())
exports.IfcWorkCalendarTypeEnum = IfcWorkCalendarTypeEnum

const IfcWorkPlanTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkPlanTypeEnum(v) {
    this.value = v
  }
  IfcWorkPlanTypeEnum.ACTUAL = 'ACTUAL'
  IfcWorkPlanTypeEnum.BASELINE = 'BASELINE'
  IfcWorkPlanTypeEnum.PLANNED = 'PLANNED'
  IfcWorkPlanTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWorkPlanTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWorkPlanTypeEnum
}())
exports.IfcWorkPlanTypeEnum = IfcWorkPlanTypeEnum

const IfcWorkScheduleTypeEnum = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkScheduleTypeEnum(v) {
    this.value = v
  }
  IfcWorkScheduleTypeEnum.ACTUAL = 'ACTUAL'
  IfcWorkScheduleTypeEnum.BASELINE = 'BASELINE'
  IfcWorkScheduleTypeEnum.PLANNED = 'PLANNED'
  IfcWorkScheduleTypeEnum.USERDEFINED = 'USERDEFINED'
  IfcWorkScheduleTypeEnum.NOTDEFINED = 'NOTDEFINED'
  return IfcWorkScheduleTypeEnum
}())
exports.IfcWorkScheduleTypeEnum = IfcWorkScheduleTypeEnum

/**
 *
 */
function ParseType(name, value) {
  if (name === 'IFCABSORBEDDOSEMEASURE') {
    return new IfcAbsorbedDoseMeasure(value)
  }
  if (name === 'IFCACCELERATIONMEASURE') {
    return new IfcAccelerationMeasure(value)
  }
  if (name === 'IFCAMOUNTOFSUBSTANCEMEASURE') {
    return new IfcAmountOfSubstanceMeasure(value)
  }
  if (name === 'IFCANGULARVELOCITYMEASURE') {
    return new IfcAngularVelocityMeasure(value)
  }
  if (name === 'IFCAREADENSITYMEASURE') {
    return new IfcAreaDensityMeasure(value)
  }
  if (name === 'IFCAREAMEASURE') {
    return new IfcAreaMeasure(value)
  }
  if (name === 'IFCBINARY') {
    return new IfcBinary(value)
  }
  if (name === 'IFCBOOLEAN') {
    return new IfcBoolean(value)
  }
  if (name === 'IFCBOXALIGNMENT') {
    return new IfcBoxAlignment(value)
  }
  if (name === 'IFCCARDINALPOINTREFERENCE') {
    return new IfcCardinalPointReference(value)
  }
  if (name === 'IFCCONTEXTDEPENDENTMEASURE') {
    return new IfcContextDependentMeasure(value)
  }
  if (name === 'IFCCOUNTMEASURE') {
    return new IfcCountMeasure(value)
  }
  if (name === 'IFCCURVATUREMEASURE') {
    return new IfcCurvatureMeasure(value)
  }
  if (name === 'IFCDATE') {
    return new IfcDate(value)
  }
  if (name === 'IFCDATETIME') {
    return new IfcDateTime(value)
  }
  if (name === 'IFCDAYINMONTHNUMBER') {
    return new IfcDayInMonthNumber(value)
  }
  if (name === 'IFCDAYINWEEKNUMBER') {
    return new IfcDayInWeekNumber(value)
  }
  if (name === 'IFCDESCRIPTIVEMEASURE') {
    return new IfcDescriptiveMeasure(value)
  }
  if (name === 'IFCDIMENSIONCOUNT') {
    return new IfcDimensionCount(value)
  }
  if (name === 'IFCDOSEEQUIVALENTMEASURE') {
    return new IfcDoseEquivalentMeasure(value)
  }
  if (name === 'IFCDURATION') {
    return new IfcDuration(value)
  }
  if (name === 'IFCDYNAMICVISCOSITYMEASURE') {
    return new IfcDynamicViscosityMeasure(value)
  }
  if (name === 'IFCELECTRICCAPACITANCEMEASURE') {
    return new IfcElectricCapacitanceMeasure(value)
  }
  if (name === 'IFCELECTRICCHARGEMEASURE') {
    return new IfcElectricChargeMeasure(value)
  }
  if (name === 'IFCELECTRICCONDUCTANCEMEASURE') {
    return new IfcElectricConductanceMeasure(value)
  }
  if (name === 'IFCELECTRICCURRENTMEASURE') {
    return new IfcElectricCurrentMeasure(value)
  }
  if (name === 'IFCELECTRICRESISTANCEMEASURE') {
    return new IfcElectricResistanceMeasure(value)
  }
  if (name === 'IFCELECTRICVOLTAGEMEASURE') {
    return new IfcElectricVoltageMeasure(value)
  }
  if (name === 'IFCENERGYMEASURE') {
    return new IfcEnergyMeasure(value)
  }
  if (name === 'IFCFONTSTYLE') {
    return new IfcFontStyle(value)
  }
  if (name === 'IFCFONTVARIANT') {
    return new IfcFontVariant(value)
  }
  if (name === 'IFCFONTWEIGHT') {
    return new IfcFontWeight(value)
  }
  if (name === 'IFCFORCEMEASURE') {
    return new IfcForceMeasure(value)
  }
  if (name === 'IFCFREQUENCYMEASURE') {
    return new IfcFrequencyMeasure(value)
  }
  if (name === 'IFCGLOBALLYUNIQUEID') {
    return new IfcGloballyUniqueId(value)
  }
  if (name === 'IFCHEATFLUXDENSITYMEASURE') {
    return new IfcHeatFluxDensityMeasure(value)
  }
  if (name === 'IFCHEATINGVALUEMEASURE') {
    return new IfcHeatingValueMeasure(value)
  }
  if (name === 'IFCIDENTIFIER') {
    return new IfcIdentifier(value)
  }
  if (name === 'IFCILLUMINANCEMEASURE') {
    return new IfcIlluminanceMeasure(value)
  }
  if (name === 'IFCINDUCTANCEMEASURE') {
    return new IfcInductanceMeasure(value)
  }
  if (name === 'IFCINTEGER') {
    return new IfcInteger(value)
  }
  if (name === 'IFCINTEGERCOUNTRATEMEASURE') {
    return new IfcIntegerCountRateMeasure(value)
  }
  if (name === 'IFCIONCONCENTRATIONMEASURE') {
    return new IfcIonConcentrationMeasure(value)
  }
  if (name === 'IFCISOTHERMALMOISTURECAPACITYMEASURE') {
    return new IfcIsothermalMoistureCapacityMeasure(value)
  }
  if (name === 'IFCKINEMATICVISCOSITYMEASURE') {
    return new IfcKinematicViscosityMeasure(value)
  }
  if (name === 'IFCLABEL') {
    return new IfcLabel(value)
  }
  if (name === 'IFCLANGUAGEID') {
    return new IfcLanguageId(value)
  }
  if (name === 'IFCLENGTHMEASURE') {
    return new IfcLengthMeasure(value)
  }
  if (name === 'IFCLINEARFORCEMEASURE') {
    return new IfcLinearForceMeasure(value)
  }
  if (name === 'IFCLINEARMOMENTMEASURE') {
    return new IfcLinearMomentMeasure(value)
  }
  if (name === 'IFCLINEARSTIFFNESSMEASURE') {
    return new IfcLinearStiffnessMeasure(value)
  }
  if (name === 'IFCLINEARVELOCITYMEASURE') {
    return new IfcLinearVelocityMeasure(value)
  }
  if (name === 'IFCLOGICAL') {
    return new IfcLogical(value)
  }
  if (name === 'IFCLUMINOUSFLUXMEASURE') {
    return new IfcLuminousFluxMeasure(value)
  }
  if (name === 'IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE') {
    return new IfcLuminousIntensityDistributionMeasure(value)
  }
  if (name === 'IFCLUMINOUSINTENSITYMEASURE') {
    return new IfcLuminousIntensityMeasure(value)
  }
  if (name === 'IFCMAGNETICFLUXDENSITYMEASURE') {
    return new IfcMagneticFluxDensityMeasure(value)
  }
  if (name === 'IFCMAGNETICFLUXMEASURE') {
    return new IfcMagneticFluxMeasure(value)
  }
  if (name === 'IFCMASSDENSITYMEASURE') {
    return new IfcMassDensityMeasure(value)
  }
  if (name === 'IFCMASSFLOWRATEMEASURE') {
    return new IfcMassFlowRateMeasure(value)
  }
  if (name === 'IFCMASSMEASURE') {
    return new IfcMassMeasure(value)
  }
  if (name === 'IFCMASSPERLENGTHMEASURE') {
    return new IfcMassPerLengthMeasure(value)
  }
  if (name === 'IFCMODULUSOFELASTICITYMEASURE') {
    return new IfcModulusOfElasticityMeasure(value)
  }
  if (name === 'IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE') {
    return new IfcModulusOfLinearSubgradeReactionMeasure(value)
  }
  if (name === 'IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE') {
    return new IfcModulusOfRotationalSubgradeReactionMeasure(value)
  }
  if (name === 'IFCMODULUSOFSUBGRADEREACTIONMEASURE') {
    return new IfcModulusOfSubgradeReactionMeasure(value)
  }
  if (name === 'IFCMOISTUREDIFFUSIVITYMEASURE') {
    return new IfcMoistureDiffusivityMeasure(value)
  }
  if (name === 'IFCMOLECULARWEIGHTMEASURE') {
    return new IfcMolecularWeightMeasure(value)
  }
  if (name === 'IFCMOMENTOFINERTIAMEASURE') {
    return new IfcMomentOfInertiaMeasure(value)
  }
  if (name === 'IFCMONETARYMEASURE') {
    return new IfcMonetaryMeasure(value)
  }
  if (name === 'IFCMONTHINYEARNUMBER') {
    return new IfcMonthInYearNumber(value)
  }
  if (name === 'IFCNONNEGATIVELENGTHMEASURE') {
    return new IfcNonNegativeLengthMeasure(value)
  }
  if (name === 'IFCNORMALISEDRATIOMEASURE') {
    return new IfcNormalisedRatioMeasure(value)
  }
  if (name === 'IFCNUMERICMEASURE') {
    return new IfcNumericMeasure(value)
  }
  if (name === 'IFCPHMEASURE') {
    return new IfcPHMeasure(value)
  }
  if (name === 'IFCPARAMETERVALUE') {
    return new IfcParameterValue(value)
  }
  if (name === 'IFCPLANARFORCEMEASURE') {
    return new IfcPlanarForceMeasure(value)
  }
  if (name === 'IFCPLANEANGLEMEASURE') {
    return new IfcPlaneAngleMeasure(value)
  }
  if (name === 'IFCPOSITIVEINTEGER') {
    return new IfcPositiveInteger(value)
  }
  if (name === 'IFCPOSITIVELENGTHMEASURE') {
    return new IfcPositiveLengthMeasure(value)
  }
  if (name === 'IFCPOSITIVEPLANEANGLEMEASURE') {
    return new IfcPositivePlaneAngleMeasure(value)
  }
  if (name === 'IFCPOSITIVERATIOMEASURE') {
    return new IfcPositiveRatioMeasure(value)
  }
  if (name === 'IFCPOWERMEASURE') {
    return new IfcPowerMeasure(value)
  }
  if (name === 'IFCPRESENTABLETEXT') {
    return new IfcPresentableText(value)
  }
  if (name === 'IFCPRESSUREMEASURE') {
    return new IfcPressureMeasure(value)
  }
  if (name === 'IFCRADIOACTIVITYMEASURE') {
    return new IfcRadioActivityMeasure(value)
  }
  if (name === 'IFCRATIOMEASURE') {
    return new IfcRatioMeasure(value)
  }
  if (name === 'IFCREAL') {
    return new IfcReal(value)
  }
  if (name === 'IFCROTATIONALFREQUENCYMEASURE') {
    return new IfcRotationalFrequencyMeasure(value)
  }
  if (name === 'IFCROTATIONALMASSMEASURE') {
    return new IfcRotationalMassMeasure(value)
  }
  if (name === 'IFCROTATIONALSTIFFNESSMEASURE') {
    return new IfcRotationalStiffnessMeasure(value)
  }
  if (name === 'IFCSECTIONMODULUSMEASURE') {
    return new IfcSectionModulusMeasure(value)
  }
  if (name === 'IFCSECTIONALAREAINTEGRALMEASURE') {
    return new IfcSectionalAreaIntegralMeasure(value)
  }
  if (name === 'IFCSHEARMODULUSMEASURE') {
    return new IfcShearModulusMeasure(value)
  }
  if (name === 'IFCSOLIDANGLEMEASURE') {
    return new IfcSolidAngleMeasure(value)
  }
  if (name === 'IFCSOUNDPOWERLEVELMEASURE') {
    return new IfcSoundPowerLevelMeasure(value)
  }
  if (name === 'IFCSOUNDPOWERMEASURE') {
    return new IfcSoundPowerMeasure(value)
  }
  if (name === 'IFCSOUNDPRESSURELEVELMEASURE') {
    return new IfcSoundPressureLevelMeasure(value)
  }
  if (name === 'IFCSOUNDPRESSUREMEASURE') {
    return new IfcSoundPressureMeasure(value)
  }
  if (name === 'IFCSPECIFICHEATCAPACITYMEASURE') {
    return new IfcSpecificHeatCapacityMeasure(value)
  }
  if (name === 'IFCSPECULAREXPONENT') {
    return new IfcSpecularExponent(value)
  }
  if (name === 'IFCSPECULARROUGHNESS') {
    return new IfcSpecularRoughness(value)
  }
  if (name === 'IFCTEMPERATUREGRADIENTMEASURE') {
    return new IfcTemperatureGradientMeasure(value)
  }
  if (name === 'IFCTEMPERATURERATEOFCHANGEMEASURE') {
    return new IfcTemperatureRateOfChangeMeasure(value)
  }
  if (name === 'IFCTEXT') {
    return new IfcText(value)
  }
  if (name === 'IFCTEXTALIGNMENT') {
    return new IfcTextAlignment(value)
  }
  if (name === 'IFCTEXTDECORATION') {
    return new IfcTextDecoration(value)
  }
  if (name === 'IFCTEXTFONTNAME') {
    return new IfcTextFontName(value)
  }
  if (name === 'IFCTEXTTRANSFORMATION') {
    return new IfcTextTransformation(value)
  }
  if (name === 'IFCTHERMALADMITTANCEMEASURE') {
    return new IfcThermalAdmittanceMeasure(value)
  }
  if (name === 'IFCTHERMALCONDUCTIVITYMEASURE') {
    return new IfcThermalConductivityMeasure(value)
  }
  if (name === 'IFCTHERMALEXPANSIONCOEFFICIENTMEASURE') {
    return new IfcThermalExpansionCoefficientMeasure(value)
  }
  if (name === 'IFCTHERMALRESISTANCEMEASURE') {
    return new IfcThermalResistanceMeasure(value)
  }
  if (name === 'IFCTHERMALTRANSMITTANCEMEASURE') {
    return new IfcThermalTransmittanceMeasure(value)
  }
  if (name === 'IFCTHERMODYNAMICTEMPERATUREMEASURE') {
    return new IfcThermodynamicTemperatureMeasure(value)
  }
  if (name === 'IFCTIME') {
    return new IfcTime(value)
  }
  if (name === 'IFCTIMEMEASURE') {
    return new IfcTimeMeasure(value)
  }
  if (name === 'IFCTIMESTAMP') {
    return new IfcTimeStamp(value)
  }
  if (name === 'IFCTORQUEMEASURE') {
    return new IfcTorqueMeasure(value)
  }
  if (name === 'IFCURIREFERENCE') {
    return new IfcURIReference(value)
  }
  if (name === 'IFCVAPORPERMEABILITYMEASURE') {
    return new IfcVaporPermeabilityMeasure(value)
  }
  if (name === 'IFCVOLUMEMEASURE') {
    return new IfcVolumeMeasure(value)
  }
  if (name === 'IFCVOLUMETRICFLOWRATEMEASURE') {
    return new IfcVolumetricFlowRateMeasure(value)
  }
  if (name === 'IFCWARPINGCONSTANTMEASURE') {
    return new IfcWarpingConstantMeasure(value)
  }
  if (name === 'IFCWARPINGMOMENTMEASURE') {
    return new IfcWarpingMomentMeasure(value)
  }
  if (name === 'IFCACTIONREQUESTTYPEENUM') {
    return new IfcActionRequestTypeEnum(value)
  }
  if (name === 'IFCACTIONSOURCETYPEENUM') {
    return new IfcActionSourceTypeEnum(value)
  }
  if (name === 'IFCACTIONTYPEENUM') {
    return new IfcActionTypeEnum(value)
  }
  if (name === 'IFCACTUATORTYPEENUM') {
    return new IfcActuatorTypeEnum(value)
  }
  if (name === 'IFCADDRESSTYPEENUM') {
    return new IfcAddressTypeEnum(value)
  }
  if (name === 'IFCAIRTERMINALBOXTYPEENUM') {
    return new IfcAirTerminalBoxTypeEnum(value)
  }
  if (name === 'IFCAIRTERMINALTYPEENUM') {
    return new IfcAirTerminalTypeEnum(value)
  }
  if (name === 'IFCAIRTOAIRHEATRECOVERYTYPEENUM') {
    return new IfcAirToAirHeatRecoveryTypeEnum(value)
  }
  if (name === 'IFCALARMTYPEENUM') {
    return new IfcAlarmTypeEnum(value)
  }
  if (name === 'IFCALIGNMENTTYPEENUM') {
    return new IfcAlignmentTypeEnum(value)
  }
  if (name === 'IFCANALYSISMODELTYPEENUM') {
    return new IfcAnalysisModelTypeEnum(value)
  }
  if (name === 'IFCANALYSISTHEORYTYPEENUM') {
    return new IfcAnalysisTheoryTypeEnum(value)
  }
  if (name === 'IFCARITHMETICOPERATORENUM') {
    return new IfcArithmeticOperatorEnum(value)
  }
  if (name === 'IFCASSEMBLYPLACEENUM') {
    return new IfcAssemblyPlaceEnum(value)
  }
  if (name === 'IFCAUDIOVISUALAPPLIANCETYPEENUM') {
    return new IfcAudioVisualApplianceTypeEnum(value)
  }
  if (name === 'IFCBSPLINECURVEFORM') {
    return new IfcBSplineCurveForm(value)
  }
  if (name === 'IFCBSPLINESURFACEFORM') {
    return new IfcBSplineSurfaceForm(value)
  }
  if (name === 'IFCBEAMTYPEENUM') {
    return new IfcBeamTypeEnum(value)
  }
  if (name === 'IFCBEARINGTYPEDISPLACEMENTENUM') {
    return new IfcBearingTypeDisplacementEnum(value)
  }
  if (name === 'IFCBEARINGTYPEENUM') {
    return new IfcBearingTypeEnum(value)
  }
  if (name === 'IFCBENCHMARKENUM') {
    return new IfcBenchmarkEnum(value)
  }
  if (name === 'IFCBOILERTYPEENUM') {
    return new IfcBoilerTypeEnum(value)
  }
  if (name === 'IFCBOOLEANOPERATOR') {
    return new IfcBooleanOperator(value)
  }
  if (name === 'IFCBRIDGEPARTTYPEENUM') {
    return new IfcBridgePartTypeEnum(value)
  }
  if (name === 'IFCBRIDGETYPEENUM') {
    return new IfcBridgeTypeEnum(value)
  }
  if (name === 'IFCBUILDINGELEMENTPARTTYPEENUM') {
    return new IfcBuildingElementPartTypeEnum(value)
  }
  if (name === 'IFCBUILDINGELEMENTPROXYTYPEENUM') {
    return new IfcBuildingElementProxyTypeEnum(value)
  }
  if (name === 'IFCBUILDINGSYSTEMTYPEENUM') {
    return new IfcBuildingSystemTypeEnum(value)
  }
  if (name === 'IFCBURNERTYPEENUM') {
    return new IfcBurnerTypeEnum(value)
  }
  if (name === 'IFCCABLECARRIERFITTINGTYPEENUM') {
    return new IfcCableCarrierFittingTypeEnum(value)
  }
  if (name === 'IFCCABLECARRIERSEGMENTTYPEENUM') {
    return new IfcCableCarrierSegmentTypeEnum(value)
  }
  if (name === 'IFCCABLEFITTINGTYPEENUM') {
    return new IfcCableFittingTypeEnum(value)
  }
  if (name === 'IFCCABLESEGMENTTYPEENUM') {
    return new IfcCableSegmentTypeEnum(value)
  }
  if (name === 'IFCCAISSONFOUNDATIONTYPEENUM') {
    return new IfcCaissonFoundationTypeEnum(value)
  }
  if (name === 'IFCCHANGEACTIONENUM') {
    return new IfcChangeActionEnum(value)
  }
  if (name === 'IFCCHILLERTYPEENUM') {
    return new IfcChillerTypeEnum(value)
  }
  if (name === 'IFCCHIMNEYTYPEENUM') {
    return new IfcChimneyTypeEnum(value)
  }
  if (name === 'IFCCOILTYPEENUM') {
    return new IfcCoilTypeEnum(value)
  }
  if (name === 'IFCCOLUMNTYPEENUM') {
    return new IfcColumnTypeEnum(value)
  }
  if (name === 'IFCCOMMUNICATIONSAPPLIANCETYPEENUM') {
    return new IfcCommunicationsApplianceTypeEnum(value)
  }
  if (name === 'IFCCOMPLEXPROPERTYTEMPLATETYPEENUM') {
    return new IfcComplexPropertyTemplateTypeEnum(value)
  }
  if (name === 'IFCCOMPRESSORTYPEENUM') {
    return new IfcCompressorTypeEnum(value)
  }
  if (name === 'IFCCONDENSERTYPEENUM') {
    return new IfcCondenserTypeEnum(value)
  }
  if (name === 'IFCCONNECTIONTYPEENUM') {
    return new IfcConnectionTypeEnum(value)
  }
  if (name === 'IFCCONSTRAINTENUM') {
    return new IfcConstraintEnum(value)
  }
  if (name === 'IFCCONSTRUCTIONEQUIPMENTRESOURCETYPEENUM') {
    return new IfcConstructionEquipmentResourceTypeEnum(value)
  }
  if (name === 'IFCCONSTRUCTIONMATERIALRESOURCETYPEENUM') {
    return new IfcConstructionMaterialResourceTypeEnum(value)
  }
  if (name === 'IFCCONSTRUCTIONPRODUCTRESOURCETYPEENUM') {
    return new IfcConstructionProductResourceTypeEnum(value)
  }
  if (name === 'IFCCONTROLLERTYPEENUM') {
    return new IfcControllerTypeEnum(value)
  }
  if (name === 'IFCCOOLEDBEAMTYPEENUM') {
    return new IfcCooledBeamTypeEnum(value)
  }
  if (name === 'IFCCOOLINGTOWERTYPEENUM') {
    return new IfcCoolingTowerTypeEnum(value)
  }
  if (name === 'IFCCOSTITEMTYPEENUM') {
    return new IfcCostItemTypeEnum(value)
  }
  if (name === 'IFCCOSTSCHEDULETYPEENUM') {
    return new IfcCostScheduleTypeEnum(value)
  }
  if (name === 'IFCCOVERINGTYPEENUM') {
    return new IfcCoveringTypeEnum(value)
  }
  if (name === 'IFCCREWRESOURCETYPEENUM') {
    return new IfcCrewResourceTypeEnum(value)
  }
  if (name === 'IFCCURTAINWALLTYPEENUM') {
    return new IfcCurtainWallTypeEnum(value)
  }
  if (name === 'IFCCURVEINTERPOLATIONENUM') {
    return new IfcCurveInterpolationEnum(value)
  }
  if (name === 'IFCDAMPERTYPEENUM') {
    return new IfcDamperTypeEnum(value)
  }
  if (name === 'IFCDATAORIGINENUM') {
    return new IfcDataOriginEnum(value)
  }
  if (name === 'IFCDERIVEDUNITENUM') {
    return new IfcDerivedUnitEnum(value)
  }
  if (name === 'IFCDIRECTIONSENSEENUM') {
    return new IfcDirectionSenseEnum(value)
  }
  if (name === 'IFCDISCRETEACCESSORYTYPEENUM') {
    return new IfcDiscreteAccessoryTypeEnum(value)
  }
  if (name === 'IFCDISTRIBUTIONCHAMBERELEMENTTYPEENUM') {
    return new IfcDistributionChamberElementTypeEnum(value)
  }
  if (name === 'IFCDISTRIBUTIONPORTTYPEENUM') {
    return new IfcDistributionPortTypeEnum(value)
  }
  if (name === 'IFCDISTRIBUTIONSYSTEMENUM') {
    return new IfcDistributionSystemEnum(value)
  }
  if (name === 'IFCDOCUMENTCONFIDENTIALITYENUM') {
    return new IfcDocumentConfidentialityEnum(value)
  }
  if (name === 'IFCDOCUMENTSTATUSENUM') {
    return new IfcDocumentStatusEnum(value)
  }
  if (name === 'IFCDOORPANELOPERATIONENUM') {
    return new IfcDoorPanelOperationEnum(value)
  }
  if (name === 'IFCDOORPANELPOSITIONENUM') {
    return new IfcDoorPanelPositionEnum(value)
  }
  if (name === 'IFCDOORSTYLECONSTRUCTIONENUM') {
    return new IfcDoorStyleConstructionEnum(value)
  }
  if (name === 'IFCDOORSTYLEOPERATIONENUM') {
    return new IfcDoorStyleOperationEnum(value)
  }
  if (name === 'IFCDOORTYPEENUM') {
    return new IfcDoorTypeEnum(value)
  }
  if (name === 'IFCDOORTYPEOPERATIONENUM') {
    return new IfcDoorTypeOperationEnum(value)
  }
  if (name === 'IFCDUCTFITTINGTYPEENUM') {
    return new IfcDuctFittingTypeEnum(value)
  }
  if (name === 'IFCDUCTSEGMENTTYPEENUM') {
    return new IfcDuctSegmentTypeEnum(value)
  }
  if (name === 'IFCDUCTSILENCERTYPEENUM') {
    return new IfcDuctSilencerTypeEnum(value)
  }
  if (name === 'IFCELECTRICAPPLIANCETYPEENUM') {
    return new IfcElectricApplianceTypeEnum(value)
  }
  if (name === 'IFCELECTRICDISTRIBUTIONBOARDTYPEENUM') {
    return new IfcElectricDistributionBoardTypeEnum(value)
  }
  if (name === 'IFCELECTRICFLOWSTORAGEDEVICETYPEENUM') {
    return new IfcElectricFlowStorageDeviceTypeEnum(value)
  }
  if (name === 'IFCELECTRICGENERATORTYPEENUM') {
    return new IfcElectricGeneratorTypeEnum(value)
  }
  if (name === 'IFCELECTRICMOTORTYPEENUM') {
    return new IfcElectricMotorTypeEnum(value)
  }
  if (name === 'IFCELECTRICTIMECONTROLTYPEENUM') {
    return new IfcElectricTimeControlTypeEnum(value)
  }
  if (name === 'IFCELEMENTASSEMBLYTYPEENUM') {
    return new IfcElementAssemblyTypeEnum(value)
  }
  if (name === 'IFCELEMENTCOMPOSITIONENUM') {
    return new IfcElementCompositionEnum(value)
  }
  if (name === 'IFCENGINETYPEENUM') {
    return new IfcEngineTypeEnum(value)
  }
  if (name === 'IFCEVAPORATIVECOOLERTYPEENUM') {
    return new IfcEvaporativeCoolerTypeEnum(value)
  }
  if (name === 'IFCEVAPORATORTYPEENUM') {
    return new IfcEvaporatorTypeEnum(value)
  }
  if (name === 'IFCEVENTTRIGGERTYPEENUM') {
    return new IfcEventTriggerTypeEnum(value)
  }
  if (name === 'IFCEVENTTYPEENUM') {
    return new IfcEventTypeEnum(value)
  }
  if (name === 'IFCEXTERNALSPATIALELEMENTTYPEENUM') {
    return new IfcExternalSpatialElementTypeEnum(value)
  }
  if (name === 'IFCFANTYPEENUM') {
    return new IfcFanTypeEnum(value)
  }
  if (name === 'IFCFASTENERTYPEENUM') {
    return new IfcFastenerTypeEnum(value)
  }
  if (name === 'IFCFILTERTYPEENUM') {
    return new IfcFilterTypeEnum(value)
  }
  if (name === 'IFCFIRESUPPRESSIONTERMINALTYPEENUM') {
    return new IfcFireSuppressionTerminalTypeEnum(value)
  }
  if (name === 'IFCFLOWDIRECTIONENUM') {
    return new IfcFlowDirectionEnum(value)
  }
  if (name === 'IFCFLOWINSTRUMENTTYPEENUM') {
    return new IfcFlowInstrumentTypeEnum(value)
  }
  if (name === 'IFCFLOWMETERTYPEENUM') {
    return new IfcFlowMeterTypeEnum(value)
  }
  if (name === 'IFCFOOTINGTYPEENUM') {
    return new IfcFootingTypeEnum(value)
  }
  if (name === 'IFCFURNITURETYPEENUM') {
    return new IfcFurnitureTypeEnum(value)
  }
  if (name === 'IFCGEOGRAPHICELEMENTTYPEENUM') {
    return new IfcGeographicElementTypeEnum(value)
  }
  if (name === 'IFCGEOMETRICPROJECTIONENUM') {
    return new IfcGeometricProjectionEnum(value)
  }
  if (name === 'IFCGLOBALORLOCALENUM') {
    return new IfcGlobalOrLocalEnum(value)
  }
  if (name === 'IFCGRIDTYPEENUM') {
    return new IfcGridTypeEnum(value)
  }
  if (name === 'IFCHEATEXCHANGERTYPEENUM') {
    return new IfcHeatExchangerTypeEnum(value)
  }
  if (name === 'IFCHUMIDIFIERTYPEENUM') {
    return new IfcHumidifierTypeEnum(value)
  }
  if (name === 'IFCINTERCEPTORTYPEENUM') {
    return new IfcInterceptorTypeEnum(value)
  }
  if (name === 'IFCINTERNALOREXTERNALENUM') {
    return new IfcInternalOrExternalEnum(value)
  }
  if (name === 'IFCINVENTORYTYPEENUM') {
    return new IfcInventoryTypeEnum(value)
  }
  if (name === 'IFCJUNCTIONBOXTYPEENUM') {
    return new IfcJunctionBoxTypeEnum(value)
  }
  if (name === 'IFCKNOTTYPE') {
    return new IfcKnotType(value)
  }
  if (name === 'IFCLABORRESOURCETYPEENUM') {
    return new IfcLaborResourceTypeEnum(value)
  }
  if (name === 'IFCLAMPTYPEENUM') {
    return new IfcLampTypeEnum(value)
  }
  if (name === 'IFCLAYERSETDIRECTIONENUM') {
    return new IfcLayerSetDirectionEnum(value)
  }
  if (name === 'IFCLIGHTDISTRIBUTIONCURVEENUM') {
    return new IfcLightDistributionCurveEnum(value)
  }
  if (name === 'IFCLIGHTEMISSIONSOURCEENUM') {
    return new IfcLightEmissionSourceEnum(value)
  }
  if (name === 'IFCLIGHTFIXTURETYPEENUM') {
    return new IfcLightFixtureTypeEnum(value)
  }
  if (name === 'IFCLOADGROUPTYPEENUM') {
    return new IfcLoadGroupTypeEnum(value)
  }
  if (name === 'IFCLOGICALOPERATORENUM') {
    return new IfcLogicalOperatorEnum(value)
  }
  if (name === 'IFCMECHANICALFASTENERTYPEENUM') {
    return new IfcMechanicalFastenerTypeEnum(value)
  }
  if (name === 'IFCMEDICALDEVICETYPEENUM') {
    return new IfcMedicalDeviceTypeEnum(value)
  }
  if (name === 'IFCMEMBERTYPEENUM') {
    return new IfcMemberTypeEnum(value)
  }
  if (name === 'IFCMOTORCONNECTIONTYPEENUM') {
    return new IfcMotorConnectionTypeEnum(value)
  }
  if (name === 'IFCNULLSTYLE') {
    return new IfcNullStyle(value)
  }
  if (name === 'IFCOBJECTTYPEENUM') {
    return new IfcObjectTypeEnum(value)
  }
  if (name === 'IFCOBJECTIVEENUM') {
    return new IfcObjectiveEnum(value)
  }
  if (name === 'IFCOCCUPANTTYPEENUM') {
    return new IfcOccupantTypeEnum(value)
  }
  if (name === 'IFCOPENINGELEMENTTYPEENUM') {
    return new IfcOpeningElementTypeEnum(value)
  }
  if (name === 'IFCOUTLETTYPEENUM') {
    return new IfcOutletTypeEnum(value)
  }
  if (name === 'IFCPERFORMANCEHISTORYTYPEENUM') {
    return new IfcPerformanceHistoryTypeEnum(value)
  }
  if (name === 'IFCPERMEABLECOVERINGOPERATIONENUM') {
    return new IfcPermeableCoveringOperationEnum(value)
  }
  if (name === 'IFCPERMITTYPEENUM') {
    return new IfcPermitTypeEnum(value)
  }
  if (name === 'IFCPHYSICALORVIRTUALENUM') {
    return new IfcPhysicalOrVirtualEnum(value)
  }
  if (name === 'IFCPILECONSTRUCTIONENUM') {
    return new IfcPileConstructionEnum(value)
  }
  if (name === 'IFCPILETYPEENUM') {
    return new IfcPileTypeEnum(value)
  }
  if (name === 'IFCPIPEFITTINGTYPEENUM') {
    return new IfcPipeFittingTypeEnum(value)
  }
  if (name === 'IFCPIPESEGMENTTYPEENUM') {
    return new IfcPipeSegmentTypeEnum(value)
  }
  if (name === 'IFCPLATETYPEENUM') {
    return new IfcPlateTypeEnum(value)
  }
  if (name === 'IFCPREFERREDSURFACECURVEREPRESENTATION') {
    return new IfcPreferredSurfaceCurveRepresentation(value)
  }
  if (name === 'IFCPROCEDURETYPEENUM') {
    return new IfcProcedureTypeEnum(value)
  }
  if (name === 'IFCPROFILETYPEENUM') {
    return new IfcProfileTypeEnum(value)
  }
  if (name === 'IFCPROJECTORDERTYPEENUM') {
    return new IfcProjectOrderTypeEnum(value)
  }
  if (name === 'IFCPROJECTEDORTRUELENGTHENUM') {
    return new IfcProjectedOrTrueLengthEnum(value)
  }
  if (name === 'IFCPROJECTIONELEMENTTYPEENUM') {
    return new IfcProjectionElementTypeEnum(value)
  }
  if (name === 'IFCPROPERTYSETTEMPLATETYPEENUM') {
    return new IfcPropertySetTemplateTypeEnum(value)
  }
  if (name === 'IFCPROTECTIVEDEVICETRIPPINGUNITTYPEENUM') {
    return new IfcProtectiveDeviceTrippingUnitTypeEnum(value)
  }
  if (name === 'IFCPROTECTIVEDEVICETYPEENUM') {
    return new IfcProtectiveDeviceTypeEnum(value)
  }
  if (name === 'IFCPUMPTYPEENUM') {
    return new IfcPumpTypeEnum(value)
  }
  if (name === 'IFCRAILINGTYPEENUM') {
    return new IfcRailingTypeEnum(value)
  }
  if (name === 'IFCRAMPFLIGHTTYPEENUM') {
    return new IfcRampFlightTypeEnum(value)
  }
  if (name === 'IFCRAMPTYPEENUM') {
    return new IfcRampTypeEnum(value)
  }
  if (name === 'IFCRECURRENCETYPEENUM') {
    return new IfcRecurrenceTypeEnum(value)
  }
  if (name === 'IFCREFERENTTYPEENUM') {
    return new IfcReferentTypeEnum(value)
  }
  if (name === 'IFCREFLECTANCEMETHODENUM') {
    return new IfcReflectanceMethodEnum(value)
  }
  if (name === 'IFCREINFORCINGBARROLEENUM') {
    return new IfcReinforcingBarRoleEnum(value)
  }
  if (name === 'IFCREINFORCINGBARSURFACEENUM') {
    return new IfcReinforcingBarSurfaceEnum(value)
  }
  if (name === 'IFCREINFORCINGBARTYPEENUM') {
    return new IfcReinforcingBarTypeEnum(value)
  }
  if (name === 'IFCREINFORCINGMESHTYPEENUM') {
    return new IfcReinforcingMeshTypeEnum(value)
  }
  if (name === 'IFCROLEENUM') {
    return new IfcRoleEnum(value)
  }
  if (name === 'IFCROOFTYPEENUM') {
    return new IfcRoofTypeEnum(value)
  }
  if (name === 'IFCSIPREFIX') {
    return new IfcSIPrefix(value)
  }
  if (name === 'IFCSIUNITNAME') {
    return new IfcSIUnitName(value)
  }
  if (name === 'IFCSANITARYTERMINALTYPEENUM') {
    return new IfcSanitaryTerminalTypeEnum(value)
  }
  if (name === 'IFCSECTIONTYPEENUM') {
    return new IfcSectionTypeEnum(value)
  }
  if (name === 'IFCSENSORTYPEENUM') {
    return new IfcSensorTypeEnum(value)
  }
  if (name === 'IFCSEQUENCEENUM') {
    return new IfcSequenceEnum(value)
  }
  if (name === 'IFCSHADINGDEVICETYPEENUM') {
    return new IfcShadingDeviceTypeEnum(value)
  }
  if (name === 'IFCSIMPLEPROPERTYTEMPLATETYPEENUM') {
    return new IfcSimplePropertyTemplateTypeEnum(value)
  }
  if (name === 'IFCSLABTYPEENUM') {
    return new IfcSlabTypeEnum(value)
  }
  if (name === 'IFCSOLARDEVICETYPEENUM') {
    return new IfcSolarDeviceTypeEnum(value)
  }
  if (name === 'IFCSPACEHEATERTYPEENUM') {
    return new IfcSpaceHeaterTypeEnum(value)
  }
  if (name === 'IFCSPACETYPEENUM') {
    return new IfcSpaceTypeEnum(value)
  }
  if (name === 'IFCSPATIALZONETYPEENUM') {
    return new IfcSpatialZoneTypeEnum(value)
  }
  if (name === 'IFCSTACKTERMINALTYPEENUM') {
    return new IfcStackTerminalTypeEnum(value)
  }
  if (name === 'IFCSTAIRFLIGHTTYPEENUM') {
    return new IfcStairFlightTypeEnum(value)
  }
  if (name === 'IFCSTAIRTYPEENUM') {
    return new IfcStairTypeEnum(value)
  }
  if (name === 'IFCSTATEENUM') {
    return new IfcStateEnum(value)
  }
  if (name === 'IFCSTRUCTURALCURVEACTIVITYTYPEENUM') {
    return new IfcStructuralCurveActivityTypeEnum(value)
  }
  if (name === 'IFCSTRUCTURALCURVEMEMBERTYPEENUM') {
    return new IfcStructuralCurveMemberTypeEnum(value)
  }
  if (name === 'IFCSTRUCTURALSURFACEACTIVITYTYPEENUM') {
    return new IfcStructuralSurfaceActivityTypeEnum(value)
  }
  if (name === 'IFCSTRUCTURALSURFACEMEMBERTYPEENUM') {
    return new IfcStructuralSurfaceMemberTypeEnum(value)
  }
  if (name === 'IFCSUBCONTRACTRESOURCETYPEENUM') {
    return new IfcSubContractResourceTypeEnum(value)
  }
  if (name === 'IFCSURFACEFEATURETYPEENUM') {
    return new IfcSurfaceFeatureTypeEnum(value)
  }
  if (name === 'IFCSURFACESIDE') {
    return new IfcSurfaceSide(value)
  }
  if (name === 'IFCSWITCHINGDEVICETYPEENUM') {
    return new IfcSwitchingDeviceTypeEnum(value)
  }
  if (name === 'IFCSYSTEMFURNITUREELEMENTTYPEENUM') {
    return new IfcSystemFurnitureElementTypeEnum(value)
  }
  if (name === 'IFCTANKTYPEENUM') {
    return new IfcTankTypeEnum(value)
  }
  if (name === 'IFCTASKDURATIONENUM') {
    return new IfcTaskDurationEnum(value)
  }
  if (name === 'IFCTASKTYPEENUM') {
    return new IfcTaskTypeEnum(value)
  }
  if (name === 'IFCTENDONANCHORTYPEENUM') {
    return new IfcTendonAnchorTypeEnum(value)
  }
  if (name === 'IFCTENDONCONDUITTYPEENUM') {
    return new IfcTendonConduitTypeEnum(value)
  }
  if (name === 'IFCTENDONTYPEENUM') {
    return new IfcTendonTypeEnum(value)
  }
  if (name === 'IFCTEXTPATH') {
    return new IfcTextPath(value)
  }
  if (name === 'IFCTIMESERIESDATATYPEENUM') {
    return new IfcTimeSeriesDataTypeEnum(value)
  }
  if (name === 'IFCTRANSFORMERTYPEENUM') {
    return new IfcTransformerTypeEnum(value)
  }
  if (name === 'IFCTRANSITIONCODE') {
    return new IfcTransitionCode(value)
  }
  if (name === 'IFCTRANSITIONCURVETYPE') {
    return new IfcTransitionCurveType(value)
  }
  if (name === 'IFCTRANSPORTELEMENTTYPEENUM') {
    return new IfcTransportElementTypeEnum(value)
  }
  if (name === 'IFCTRIMMINGPREFERENCE') {
    return new IfcTrimmingPreference(value)
  }
  if (name === 'IFCTUBEBUNDLETYPEENUM') {
    return new IfcTubeBundleTypeEnum(value)
  }
  if (name === 'IFCUNITENUM') {
    return new IfcUnitEnum(value)
  }
  if (name === 'IFCUNITARYCONTROLELEMENTTYPEENUM') {
    return new IfcUnitaryControlElementTypeEnum(value)
  }
  if (name === 'IFCUNITARYEQUIPMENTTYPEENUM') {
    return new IfcUnitaryEquipmentTypeEnum(value)
  }
  if (name === 'IFCVALVETYPEENUM') {
    return new IfcValveTypeEnum(value)
  }
  if (name === 'IFCVIBRATIONDAMPERTYPEENUM') {
    return new IfcVibrationDamperTypeEnum(value)
  }
  if (name === 'IFCVIBRATIONISOLATORTYPEENUM') {
    return new IfcVibrationIsolatorTypeEnum(value)
  }
  if (name === 'IFCVOIDINGFEATURETYPEENUM') {
    return new IfcVoidingFeatureTypeEnum(value)
  }
  if (name === 'IFCWALLTYPEENUM') {
    return new IfcWallTypeEnum(value)
  }
  if (name === 'IFCWASTETERMINALTYPEENUM') {
    return new IfcWasteTerminalTypeEnum(value)
  }
  if (name === 'IFCWINDOWPANELOPERATIONENUM') {
    return new IfcWindowPanelOperationEnum(value)
  }
  if (name === 'IFCWINDOWPANELPOSITIONENUM') {
    return new IfcWindowPanelPositionEnum(value)
  }
  if (name === 'IFCWINDOWSTYLECONSTRUCTIONENUM') {
    return new IfcWindowStyleConstructionEnum(value)
  }
  if (name === 'IFCWINDOWSTYLEOPERATIONENUM') {
    return new IfcWindowStyleOperationEnum(value)
  }
  if (name === 'IFCWINDOWTYPEENUM') {
    return new IfcWindowTypeEnum(value)
  }
  if (name === 'IFCWINDOWTYPEPARTITIONINGENUM') {
    return new IfcWindowTypePartitioningEnum(value)
  }
  if (name === 'IFCWORKCALENDARTYPEENUM') {
    return new IfcWorkCalendarTypeEnum(value)
  }
  if (name === 'IFCWORKPLANTYPEENUM') {
    return new IfcWorkPlanTypeEnum(value)
  }
  if (name === 'IFCWORKSCHEDULETYPEENUM') {
    return new IfcWorkScheduleTypeEnum(value)
  }
  console.log(`Unknown type: ${  name}`)
}

var IfcActionRequest = /** @class */ (function() {
  /**
   *
   */
  function IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.PredefinedType = PredefinedType
    this.Status = Status
    this.LongDescription = LongDescription
  }
  IfcActionRequest.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcActionRequestTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    let Status
    if (tape[7]) {
      Status = tape[7]
    } else {
      Status = null
    }
    let LongDescription
    if (tape[8]) {
      LongDescription = tape[8]
    } else {
      LongDescription = null
    }
    return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription)
  }
  IfcActionRequest.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcActionRequest
}())
exports.IfcActionRequest = IfcActionRequest

var IfcActor = /** @class */ (function() {
  /**
   *
   */
  function IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.TheActor = TheActor
  }
  IfcActor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let TheActor
    TheActor = ParseType(tape[5], tape[6][0])
    return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor)
  }
  IfcActor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcActor
}())
exports.IfcActor = IfcActor

var IfcActorRole = /** @class */ (function() {
  /**
   *
   */
  function IfcActorRole(expressID, type, Role, UserDefinedRole, Description) {
    this.expressID = expressID
    this.type = type
    this.Role = Role
    this.UserDefinedRole = UserDefinedRole
    this.Description = Description
  }
  IfcActorRole.FromTape = function(expressID, type, tape) {
    let Role
    Role = new IfcRoleEnum(tape[0])
    let UserDefinedRole
    if (tape[1]) {
      UserDefinedRole = tape[1]
    } else {
      UserDefinedRole = null
    }
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description)
  }
  IfcActorRole.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.Role.value)
    if (this.UserDefinedRole) {
      args.push(STRING)
      args.push(this.UserDefinedRole)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcActorRole
}())
exports.IfcActorRole = IfcActorRole

var IfcActuator = /** @class */ (function() {
  /**
   *
   */
  function IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcActuator.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcActuatorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcActuator.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcActuator
}())
exports.IfcActuator = IfcActuator

var IfcActuatorType = /** @class */ (function() {
  /**
   *
   */
  function IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcActuatorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcActuatorTypeEnum(tape[9])
    return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcActuatorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcActuatorType
}())
exports.IfcActuatorType = IfcActuatorType

var IfcAddress = /** @class */ (function() {
  /**
   *
   */
  function IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose) {
    this.expressID = expressID
    this.type = type
    this.Purpose = Purpose
    this.Description = Description
    this.UserDefinedPurpose = UserDefinedPurpose
  }
  IfcAddress.FromTape = function(expressID, type, tape) {
    let Purpose
    if (tape[0]) {
      Purpose = new IfcAddressTypeEnum(tape[0])
    } else {
      Purpose = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UserDefinedPurpose
    if (tape[2]) {
      UserDefinedPurpose = tape[2]
    } else {
      UserDefinedPurpose = null
    }
    return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose)
  }
  IfcAddress.prototype.ToTape = function() {
    const args = []
    if (this.Purpose) {
      args.push(ENUM)
      args.push(this.Purpose.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPurpose) {
      args.push(STRING)
      args.push(this.UserDefinedPurpose)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAddress
}())
exports.IfcAddress = IfcAddress

var IfcAdvancedBrep = /** @class */ (function() {
  /**
   *
   */
  function IfcAdvancedBrep(expressID, type, Outer) {
    this.expressID = expressID
    this.type = type
    this.Outer = Outer
  }
  IfcAdvancedBrep.FromTape = function(expressID, type, tape) {
    let Outer
    Outer = tape[0]
    return new IfcAdvancedBrep(expressID, type, Outer)
  }
  IfcAdvancedBrep.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Outer)
    return args
  }
  return IfcAdvancedBrep
}())
exports.IfcAdvancedBrep = IfcAdvancedBrep

var IfcAdvancedBrepWithVoids = /** @class */ (function() {
  /**
   *
   */
  function IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids) {
    this.expressID = expressID
    this.type = type
    this.Outer = Outer
    this.Voids = Voids
  }
  IfcAdvancedBrepWithVoids.FromTape = function(expressID, type, tape) {
    let Outer
    Outer = tape[0]
    let Voids
    Voids = []
    let Voids_index = 0
    while (Voids_index < tape[1].length) {
      Voids.push(tape[1][Voids_index++])
    }
    return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids)
  }
  IfcAdvancedBrepWithVoids.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Outer)
    args.push(SET_BEGIN)
    this.Voids.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcAdvancedBrepWithVoids
}())
exports.IfcAdvancedBrepWithVoids = IfcAdvancedBrepWithVoids

var IfcAdvancedFace = /** @class */ (function() {
  /**
   *
   */
  function IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID
    this.type = type
    this.Bounds = Bounds
    this.FaceSurface = FaceSurface
    this.SameSense = SameSense
  }
  IfcAdvancedFace.FromTape = function(expressID, type, tape) {
    let Bounds
    Bounds = []
    let Bounds_index = 0
    while (Bounds_index < tape[0].length) {
      Bounds.push(tape[0][Bounds_index++])
    }
    let FaceSurface
    FaceSurface = tape[1]
    let SameSense
    SameSense = tape[2]
    return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense)
  }
  IfcAdvancedFace.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Bounds.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.FaceSurface)
    return args
  }
  return IfcAdvancedFace
}())
exports.IfcAdvancedFace = IfcAdvancedFace

var IfcAirTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcAirTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAirTerminalTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcAirTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAirTerminal
}())
exports.IfcAirTerminal = IfcAirTerminal

var IfcAirTerminalBox = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcAirTerminalBox.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAirTerminalBoxTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcAirTerminalBox.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAirTerminalBox
}())
exports.IfcAirTerminalBox = IfcAirTerminalBox

var IfcAirTerminalBoxType = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcAirTerminalBoxType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcAirTerminalBoxTypeEnum(tape[9])
    return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcAirTerminalBoxType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcAirTerminalBoxType
}())
exports.IfcAirTerminalBoxType = IfcAirTerminalBoxType

var IfcAirTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcAirTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcAirTerminalTypeEnum(tape[9])
    return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcAirTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcAirTerminalType
}())
exports.IfcAirTerminalType = IfcAirTerminalType

var IfcAirToAirHeatRecovery = /** @class */ (function() {
  /**
   *
   */
  function IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcAirToAirHeatRecovery.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAirToAirHeatRecoveryTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcAirToAirHeatRecovery.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAirToAirHeatRecovery
}())
exports.IfcAirToAirHeatRecovery = IfcAirToAirHeatRecovery

var IfcAirToAirHeatRecoveryType = /** @class */ (function() {
  /**
   *
   */
  function IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcAirToAirHeatRecoveryType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcAirToAirHeatRecoveryTypeEnum(tape[9])
    return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcAirToAirHeatRecoveryType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcAirToAirHeatRecoveryType
}())
exports.IfcAirToAirHeatRecoveryType = IfcAirToAirHeatRecoveryType

var IfcAlarm = /** @class */ (function() {
  /**
   *
   */
  function IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcAlarm.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAlarmTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcAlarm.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAlarm
}())
exports.IfcAlarm = IfcAlarm

var IfcAlarmType = /** @class */ (function() {
  /**
   *
   */
  function IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcAlarmType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcAlarmTypeEnum(tape[9])
    return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcAlarmType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcAlarmType
}())
exports.IfcAlarmType = IfcAlarmType

var IfcAlignment = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Axis = Axis
    this.PredefinedType = PredefinedType
  }
  IfcAlignment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Axis
    Axis = tape[7]
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAlignmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType)
  }
  IfcAlignment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Axis)
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAlignment
}())
exports.IfcAlignment = IfcAlignment

var IfcAlignment2DHorizontal = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments) {
    this.expressID = expressID
    this.type = type
    this.StartDistAlong = StartDistAlong
    this.Segments = Segments
  }
  IfcAlignment2DHorizontal.FromTape = function(expressID, type, tape) {
    let StartDistAlong
    if (tape[0]) {
      StartDistAlong = tape[0]
    } else {
      StartDistAlong = null
    }
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[1].length) {
      Segments.push(tape[1][Segments_index++])
    }
    return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments)
  }
  IfcAlignment2DHorizontal.prototype.ToTape = function() {
    const args = []
    if (this.StartDistAlong) {
      args.push(REAL)
      args.push(this.StartDistAlong)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcAlignment2DHorizontal
}())
exports.IfcAlignment2DHorizontal = IfcAlignment2DHorizontal

var IfcAlignment2DHorizontalSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
    this.CurveGeometry = CurveGeometry
  }
  IfcAlignment2DHorizontalSegment.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    let CurveGeometry
    CurveGeometry = tape[3]
    return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry)
  }
  IfcAlignment2DHorizontalSegment.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.CurveGeometry)
    return args
  }
  return IfcAlignment2DHorizontalSegment
}())
exports.IfcAlignment2DHorizontalSegment = IfcAlignment2DHorizontalSegment

var IfcAlignment2DSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
  }
  IfcAlignment2DSegment.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag)
  }
  IfcAlignment2DSegment.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAlignment2DSegment
}())
exports.IfcAlignment2DSegment = IfcAlignment2DSegment

var IfcAlignment2DVerSegCircularArc = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
    this.StartDistAlong = StartDistAlong
    this.HorizontalLength = HorizontalLength
    this.StartHeight = StartHeight
    this.StartGradient = StartGradient
    this.Radius = Radius
    this.IsConvex = IsConvex
  }
  IfcAlignment2DVerSegCircularArc.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    let StartDistAlong
    StartDistAlong = tape[3]
    let HorizontalLength
    HorizontalLength = tape[4]
    let StartHeight
    StartHeight = tape[5]
    let StartGradient
    StartGradient = tape[6]
    let Radius
    Radius = tape[7]
    let IsConvex
    IsConvex = tape[8]
    return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex)
  }
  IfcAlignment2DVerSegCircularArc.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.StartDistAlong)
    args.push(REAL)
    args.push(this.StartHeight)
    args.push(REAL)
    args.push(this.StartGradient)
    return args
  }
  return IfcAlignment2DVerSegCircularArc
}())
exports.IfcAlignment2DVerSegCircularArc = IfcAlignment2DVerSegCircularArc

var IfcAlignment2DVerSegLine = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
    this.StartDistAlong = StartDistAlong
    this.HorizontalLength = HorizontalLength
    this.StartHeight = StartHeight
    this.StartGradient = StartGradient
  }
  IfcAlignment2DVerSegLine.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    let StartDistAlong
    StartDistAlong = tape[3]
    let HorizontalLength
    HorizontalLength = tape[4]
    let StartHeight
    StartHeight = tape[5]
    let StartGradient
    StartGradient = tape[6]
    return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient)
  }
  IfcAlignment2DVerSegLine.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.StartDistAlong)
    args.push(REAL)
    args.push(this.StartHeight)
    args.push(REAL)
    args.push(this.StartGradient)
    return args
  }
  return IfcAlignment2DVerSegLine
}())
exports.IfcAlignment2DVerSegLine = IfcAlignment2DVerSegLine

var IfcAlignment2DVerSegParabolicArc = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
    this.StartDistAlong = StartDistAlong
    this.HorizontalLength = HorizontalLength
    this.StartHeight = StartHeight
    this.StartGradient = StartGradient
    this.ParabolaConstant = ParabolaConstant
    this.IsConvex = IsConvex
  }
  IfcAlignment2DVerSegParabolicArc.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    let StartDistAlong
    StartDistAlong = tape[3]
    let HorizontalLength
    HorizontalLength = tape[4]
    let StartHeight
    StartHeight = tape[5]
    let StartGradient
    StartGradient = tape[6]
    let ParabolaConstant
    ParabolaConstant = tape[7]
    let IsConvex
    IsConvex = tape[8]
    return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex)
  }
  IfcAlignment2DVerSegParabolicArc.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.StartDistAlong)
    args.push(REAL)
    args.push(this.StartHeight)
    args.push(REAL)
    args.push(this.StartGradient)
    return args
  }
  return IfcAlignment2DVerSegParabolicArc
}())
exports.IfcAlignment2DVerSegParabolicArc = IfcAlignment2DVerSegParabolicArc

var IfcAlignment2DVertical = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DVertical(expressID, type, Segments) {
    this.expressID = expressID
    this.type = type
    this.Segments = Segments
  }
  IfcAlignment2DVertical.FromTape = function(expressID, type, tape) {
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[0].length) {
      Segments.push(tape[0][Segments_index++])
    }
    return new IfcAlignment2DVertical(expressID, type, Segments)
  }
  IfcAlignment2DVertical.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcAlignment2DVertical
}())
exports.IfcAlignment2DVertical = IfcAlignment2DVertical

var IfcAlignment2DVerticalSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID
    this.type = type
    this.TangentialContinuity = TangentialContinuity
    this.StartTag = StartTag
    this.EndTag = EndTag
    this.StartDistAlong = StartDistAlong
    this.HorizontalLength = HorizontalLength
    this.StartHeight = StartHeight
    this.StartGradient = StartGradient
  }
  IfcAlignment2DVerticalSegment.FromTape = function(expressID, type, tape) {
    let TangentialContinuity
    if (tape[0]) {
      TangentialContinuity = tape[0]
    } else {
      TangentialContinuity = null
    }
    let StartTag
    if (tape[1]) {
      StartTag = tape[1]
    } else {
      StartTag = null
    }
    let EndTag
    if (tape[2]) {
      EndTag = tape[2]
    } else {
      EndTag = null
    }
    let StartDistAlong
    StartDistAlong = tape[3]
    let HorizontalLength
    HorizontalLength = tape[4]
    let StartHeight
    StartHeight = tape[5]
    let StartGradient
    StartGradient = tape[6]
    return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient)
  }
  IfcAlignment2DVerticalSegment.prototype.ToTape = function() {
    const args = []
    if (this.TangentialContinuity) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartTag) {
      args.push(STRING)
      args.push(this.StartTag)
    } else {
      args.push(EMPTY)
    }
    if (this.EndTag) {
      args.push(STRING)
      args.push(this.EndTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.StartDistAlong)
    args.push(REAL)
    args.push(this.StartHeight)
    args.push(REAL)
    args.push(this.StartGradient)
    return args
  }
  return IfcAlignment2DVerticalSegment
}())
exports.IfcAlignment2DVerticalSegment = IfcAlignment2DVerticalSegment

var IfcAlignmentCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag) {
    this.expressID = expressID
    this.type = type
    this.Horizontal = Horizontal
    this.Vertical = Vertical
    this.Tag = Tag
  }
  IfcAlignmentCurve.FromTape = function(expressID, type, tape) {
    let Horizontal
    Horizontal = tape[0]
    let Vertical
    if (tape[1]) {
      Vertical = tape[1]
    } else {
      Vertical = null
    }
    let Tag
    if (tape[2]) {
      Tag = tape[2]
    } else {
      Tag = null
    }
    return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag)
  }
  IfcAlignmentCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Horizontal)
    if (this.Vertical) {
      args.push(REF)
      args.push(this.Vertical)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAlignmentCurve
}())
exports.IfcAlignmentCurve = IfcAlignmentCurve

var IfcAnnotation = /** @class */ (function() {
  /**
   *
   */
  function IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcAnnotation.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcAnnotation.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAnnotation
}())
exports.IfcAnnotation = IfcAnnotation

var IfcAnnotationFillArea = /** @class */ (function() {
  /**
   *
   */
  function IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID
    this.type = type
    this.OuterBoundary = OuterBoundary
    this.InnerBoundaries = InnerBoundaries
  }
  IfcAnnotationFillArea.FromTape = function(expressID, type, tape) {
    let OuterBoundary
    OuterBoundary = tape[0]
    let InnerBoundaries
    if (tape[1]) {
      InnerBoundaries = []
      let InnerBoundaries_index = 0
      while (InnerBoundaries_index < tape[1].length) {
        InnerBoundaries.push(tape[1][InnerBoundaries_index++])
      }
    } else {
      InnerBoundaries = null
    }
    return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries)
  }
  IfcAnnotationFillArea.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.OuterBoundary)
    if (this.InnerBoundaries) {
      args.push(SET_BEGIN)
      this.InnerBoundaries.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAnnotationFillArea
}())
exports.IfcAnnotationFillArea = IfcAnnotationFillArea

var IfcApplication = /** @class */ (function() {
  /**
   *
   */
  function IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
    this.expressID = expressID
    this.type = type
    this.ApplicationDeveloper = ApplicationDeveloper
    this.Version = Version
    this.ApplicationFullName = ApplicationFullName
    this.ApplicationIdentifier = ApplicationIdentifier
  }
  IfcApplication.FromTape = function(expressID, type, tape) {
    let ApplicationDeveloper
    ApplicationDeveloper = tape[0]
    let Version
    Version = tape[1]
    let ApplicationFullName
    ApplicationFullName = tape[2]
    let ApplicationIdentifier
    ApplicationIdentifier = tape[3]
    return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier)
  }
  IfcApplication.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ApplicationDeveloper)
    args.push(STRING)
    args.push(this.Version)
    args.push(STRING)
    args.push(this.ApplicationFullName)
    args.push(STRING)
    args.push(this.ApplicationIdentifier)
    return args
  }
  return IfcApplication
}())
exports.IfcApplication = IfcApplication

var IfcAppliedValue = /** @class */ (function() {
  /**
   *
   */
  function IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.AppliedValue = AppliedValue
    this.UnitBasis = UnitBasis
    this.ApplicableDate = ApplicableDate
    this.FixedUntilDate = FixedUntilDate
    this.Category = Category
    this.Condition = Condition
    this.ArithmeticOperator = ArithmeticOperator
    this.Components = Components
  }
  IfcAppliedValue.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let AppliedValue
    if (tape[2]) {
      AppliedValue = ParseType(tape[2], tape[3][0])
    } else {
      AppliedValue = null
    }
    let UnitBasis
    if (tape[3]) {
      UnitBasis = tape[3]
    } else {
      UnitBasis = null
    }
    let ApplicableDate
    if (tape[4]) {
      ApplicableDate = tape[4]
    } else {
      ApplicableDate = null
    }
    let FixedUntilDate
    if (tape[5]) {
      FixedUntilDate = tape[5]
    } else {
      FixedUntilDate = null
    }
    let Category
    if (tape[6]) {
      Category = tape[6]
    } else {
      Category = null
    }
    let Condition
    if (tape[7]) {
      Condition = tape[7]
    } else {
      Condition = null
    }
    let ArithmeticOperator
    if (tape[8]) {
      ArithmeticOperator = new IfcArithmeticOperatorEnum(tape[8])
    } else {
      ArithmeticOperator = null
    }
    let Components
    if (tape[9]) {
      Components = []
      let Components_index = 0
      while (Components_index < tape[9].length) {
        Components.push(tape[9][Components_index++])
      }
    } else {
      Components = null
    }
    return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components)
  }
  IfcAppliedValue.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedValue) {
    } else {
      args.push(EMPTY)
    }
    if (this.UnitBasis) {
      args.push(REF)
      args.push(this.UnitBasis)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableDate) {
      args.push(STRING)
      args.push(this.ApplicableDate)
    } else {
      args.push(EMPTY)
    }
    if (this.FixedUntilDate) {
      args.push(STRING)
      args.push(this.FixedUntilDate)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    if (this.Condition) {
      args.push(STRING)
      args.push(this.Condition)
    } else {
      args.push(EMPTY)
    }
    if (this.ArithmeticOperator) {
      args.push(ENUM)
      args.push(this.ArithmeticOperator.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Components) {
      args.push(SET_BEGIN)
      this.Components.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAppliedValue
}())
exports.IfcAppliedValue = IfcAppliedValue

var IfcApproval = /** @class */ (function() {
  /**
   *
   */
  function IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
    this.expressID = expressID
    this.type = type
    this.Identifier = Identifier
    this.Name = Name
    this.Description = Description
    this.TimeOfApproval = TimeOfApproval
    this.Status = Status
    this.Level = Level
    this.Qualifier = Qualifier
    this.RequestingApproval = RequestingApproval
    this.GivingApproval = GivingApproval
  }
  IfcApproval.FromTape = function(expressID, type, tape) {
    let Identifier
    if (tape[0]) {
      Identifier = tape[0]
    } else {
      Identifier = null
    }
    let Name
    if (tape[1]) {
      Name = tape[1]
    } else {
      Name = null
    }
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    let TimeOfApproval
    if (tape[3]) {
      TimeOfApproval = tape[3]
    } else {
      TimeOfApproval = null
    }
    let Status
    if (tape[4]) {
      Status = tape[4]
    } else {
      Status = null
    }
    let Level
    if (tape[5]) {
      Level = tape[5]
    } else {
      Level = null
    }
    let Qualifier
    if (tape[6]) {
      Qualifier = tape[6]
    } else {
      Qualifier = null
    }
    let RequestingApproval
    if (tape[7]) {
      RequestingApproval = ParseType(tape[7], tape[8][0])
    } else {
      RequestingApproval = null
    }
    let GivingApproval
    if (tape[8]) {
      GivingApproval = ParseType(tape[8], tape[9][0])
    } else {
      GivingApproval = null
    }
    return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval)
  }
  IfcApproval.prototype.ToTape = function() {
    const args = []
    if (this.Identifier) {
      args.push(STRING)
      args.push(this.Identifier)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.TimeOfApproval) {
      args.push(STRING)
      args.push(this.TimeOfApproval)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.Level) {
      args.push(STRING)
      args.push(this.Level)
    } else {
      args.push(EMPTY)
    }
    if (this.Qualifier) {
      args.push(STRING)
      args.push(this.Qualifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RequestingApproval) {
    } else {
      args.push(EMPTY)
    }
    if (this.GivingApproval) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcApproval
}())
exports.IfcApproval = IfcApproval

var IfcApprovalRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingApproval = RelatingApproval
    this.RelatedApprovals = RelatedApprovals
  }
  IfcApprovalRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingApproval
    RelatingApproval = tape[2]
    let RelatedApprovals
    RelatedApprovals = []
    let RelatedApprovals_index = 0
    while (RelatedApprovals_index < tape[3].length) {
      RelatedApprovals.push(tape[3][RelatedApprovals_index++])
    }
    return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals)
  }
  IfcApprovalRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingApproval)
    args.push(SET_BEGIN)
    this.RelatedApprovals.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcApprovalRelationship
}())
exports.IfcApprovalRelationship = IfcApprovalRelationship

var IfcArbitraryClosedProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.OuterCurve = OuterCurve
  }
  IfcArbitraryClosedProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let OuterCurve
    OuterCurve = tape[2]
    return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve)
  }
  IfcArbitraryClosedProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.OuterCurve)
    return args
  }
  return IfcArbitraryClosedProfileDef
}())
exports.IfcArbitraryClosedProfileDef = IfcArbitraryClosedProfileDef

var IfcArbitraryOpenProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Curve = Curve
  }
  IfcArbitraryOpenProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Curve
    Curve = tape[2]
    return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve)
  }
  IfcArbitraryOpenProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Curve)
    return args
  }
  return IfcArbitraryOpenProfileDef
}())
exports.IfcArbitraryOpenProfileDef = IfcArbitraryOpenProfileDef

var IfcArbitraryProfileDefWithVoids = /** @class */ (function() {
  /**
   *
   */
  function IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.OuterCurve = OuterCurve
    this.InnerCurves = InnerCurves
  }
  IfcArbitraryProfileDefWithVoids.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let OuterCurve
    OuterCurve = tape[2]
    let InnerCurves
    InnerCurves = []
    let InnerCurves_index = 0
    while (InnerCurves_index < tape[3].length) {
      InnerCurves.push(tape[3][InnerCurves_index++])
    }
    return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves)
  }
  IfcArbitraryProfileDefWithVoids.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.OuterCurve)
    args.push(SET_BEGIN)
    this.InnerCurves.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcArbitraryProfileDefWithVoids
}())
exports.IfcArbitraryProfileDefWithVoids = IfcArbitraryProfileDefWithVoids

var IfcAsset = /** @class */ (function() {
  /**
   *
   */
  function IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.OriginalValue = OriginalValue
    this.CurrentValue = CurrentValue
    this.TotalReplacementCost = TotalReplacementCost
    this.Owner = Owner
    this.User = User
    this.ResponsiblePerson = ResponsiblePerson
    this.IncorporationDate = IncorporationDate
    this.DepreciatedValue = DepreciatedValue
  }
  IfcAsset.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let OriginalValue
    if (tape[6]) {
      OriginalValue = tape[6]
    } else {
      OriginalValue = null
    }
    let CurrentValue
    if (tape[7]) {
      CurrentValue = tape[7]
    } else {
      CurrentValue = null
    }
    let TotalReplacementCost
    if (tape[8]) {
      TotalReplacementCost = tape[8]
    } else {
      TotalReplacementCost = null
    }
    let Owner
    if (tape[9]) {
      Owner = ParseType(tape[9], tape[10][0])
    } else {
      Owner = null
    }
    let User
    if (tape[10]) {
      User = ParseType(tape[10], tape[11][0])
    } else {
      User = null
    }
    let ResponsiblePerson
    if (tape[11]) {
      ResponsiblePerson = tape[11]
    } else {
      ResponsiblePerson = null
    }
    let IncorporationDate
    if (tape[12]) {
      IncorporationDate = tape[12]
    } else {
      IncorporationDate = null
    }
    let DepreciatedValue
    if (tape[13]) {
      DepreciatedValue = tape[13]
    } else {
      DepreciatedValue = null
    }
    return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue)
  }
  IfcAsset.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.OriginalValue) {
      args.push(REF)
      args.push(this.OriginalValue)
    } else {
      args.push(EMPTY)
    }
    if (this.CurrentValue) {
      args.push(REF)
      args.push(this.CurrentValue)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalReplacementCost) {
      args.push(REF)
      args.push(this.TotalReplacementCost)
    } else {
      args.push(EMPTY)
    }
    if (this.Owner) {
    } else {
      args.push(EMPTY)
    }
    if (this.User) {
    } else {
      args.push(EMPTY)
    }
    if (this.ResponsiblePerson) {
      args.push(REF)
      args.push(this.ResponsiblePerson)
    } else {
      args.push(EMPTY)
    }
    if (this.IncorporationDate) {
      args.push(STRING)
      args.push(this.IncorporationDate)
    } else {
      args.push(EMPTY)
    }
    if (this.DepreciatedValue) {
      args.push(REF)
      args.push(this.DepreciatedValue)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAsset
}())
exports.IfcAsset = IfcAsset

var IfcAsymmetricIShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.BottomFlangeWidth = BottomFlangeWidth
    this.OverallDepth = OverallDepth
    this.WebThickness = WebThickness
    this.BottomFlangeThickness = BottomFlangeThickness
    this.BottomFlangeFilletRadius = BottomFlangeFilletRadius
    this.TopFlangeWidth = TopFlangeWidth
    this.TopFlangeThickness = TopFlangeThickness
    this.TopFlangeFilletRadius = TopFlangeFilletRadius
    this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius
    this.BottomFlangeSlope = BottomFlangeSlope
    this.TopFlangeEdgeRadius = TopFlangeEdgeRadius
    this.TopFlangeSlope = TopFlangeSlope
  }
  IfcAsymmetricIShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let BottomFlangeWidth
    BottomFlangeWidth = tape[3]
    let OverallDepth
    OverallDepth = tape[4]
    let WebThickness
    WebThickness = tape[5]
    let BottomFlangeThickness
    BottomFlangeThickness = tape[6]
    let BottomFlangeFilletRadius
    if (tape[7]) {
      BottomFlangeFilletRadius = tape[7]
    } else {
      BottomFlangeFilletRadius = null
    }
    let TopFlangeWidth
    TopFlangeWidth = tape[8]
    let TopFlangeThickness
    if (tape[9]) {
      TopFlangeThickness = tape[9]
    } else {
      TopFlangeThickness = null
    }
    let TopFlangeFilletRadius
    if (tape[10]) {
      TopFlangeFilletRadius = tape[10]
    } else {
      TopFlangeFilletRadius = null
    }
    let BottomFlangeEdgeRadius
    if (tape[11]) {
      BottomFlangeEdgeRadius = tape[11]
    } else {
      BottomFlangeEdgeRadius = null
    }
    let BottomFlangeSlope
    if (tape[12]) {
      BottomFlangeSlope = tape[12]
    } else {
      BottomFlangeSlope = null
    }
    let TopFlangeEdgeRadius
    if (tape[13]) {
      TopFlangeEdgeRadius = tape[13]
    } else {
      TopFlangeEdgeRadius = null
    }
    let TopFlangeSlope
    if (tape[14]) {
      TopFlangeSlope = tape[14]
    } else {
      TopFlangeSlope = null
    }
    return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope)
  }
  IfcAsymmetricIShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.BottomFlangeFilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.TopFlangeThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.TopFlangeFilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.BottomFlangeEdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.BottomFlangeSlope) {
      args.push(REAL)
      args.push(this.BottomFlangeSlope)
    } else {
      args.push(EMPTY)
    }
    if (this.TopFlangeEdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.TopFlangeSlope) {
      args.push(REAL)
      args.push(this.TopFlangeSlope)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAsymmetricIShapeProfileDef
}())
exports.IfcAsymmetricIShapeProfileDef = IfcAsymmetricIShapeProfileDef

var IfcAudioVisualAppliance = /** @class */ (function() {
  /**
   *
   */
  function IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcAudioVisualAppliance.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcAudioVisualApplianceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcAudioVisualAppliance.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAudioVisualAppliance
}())
exports.IfcAudioVisualAppliance = IfcAudioVisualAppliance

var IfcAudioVisualApplianceType = /** @class */ (function() {
  /**
   *
   */
  function IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcAudioVisualApplianceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcAudioVisualApplianceTypeEnum(tape[9])
    return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcAudioVisualApplianceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcAudioVisualApplianceType
}())
exports.IfcAudioVisualApplianceType = IfcAudioVisualApplianceType

var IfcAxis1Placement = /** @class */ (function() {
  /**
   *
   */
  function IfcAxis1Placement(expressID, type, Location, Axis) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Axis = Axis
  }
  IfcAxis1Placement.FromTape = function(expressID, type, tape) {
    let Location
    Location = tape[0]
    let Axis
    if (tape[1]) {
      Axis = tape[1]
    } else {
      Axis = null
    }
    return new IfcAxis1Placement(expressID, type, Location, Axis)
  }
  IfcAxis1Placement.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Location)
    if (this.Axis) {
      args.push(REF)
      args.push(this.Axis)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAxis1Placement
}())
exports.IfcAxis1Placement = IfcAxis1Placement

var IfcAxis2Placement2D = /** @class */ (function() {
  /**
   *
   */
  function IfcAxis2Placement2D(expressID, type, Location, RefDirection) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.RefDirection = RefDirection
  }
  IfcAxis2Placement2D.FromTape = function(expressID, type, tape) {
    let Location
    Location = tape[0]
    let RefDirection
    if (tape[1]) {
      RefDirection = tape[1]
    } else {
      RefDirection = null
    }
    return new IfcAxis2Placement2D(expressID, type, Location, RefDirection)
  }
  IfcAxis2Placement2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Location)
    if (this.RefDirection) {
      args.push(REF)
      args.push(this.RefDirection)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAxis2Placement2D
}())
exports.IfcAxis2Placement2D = IfcAxis2Placement2D

var IfcAxis2Placement3D = /** @class */ (function() {
  /**
   *
   */
  function IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Axis = Axis
    this.RefDirection = RefDirection
  }
  IfcAxis2Placement3D.FromTape = function(expressID, type, tape) {
    let Location
    Location = tape[0]
    let Axis
    if (tape[1]) {
      Axis = tape[1]
    } else {
      Axis = null
    }
    let RefDirection
    if (tape[2]) {
      RefDirection = tape[2]
    } else {
      RefDirection = null
    }
    return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection)
  }
  IfcAxis2Placement3D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Location)
    if (this.Axis) {
      args.push(REF)
      args.push(this.Axis)
    } else {
      args.push(EMPTY)
    }
    if (this.RefDirection) {
      args.push(REF)
      args.push(this.RefDirection)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcAxis2Placement3D
}())
exports.IfcAxis2Placement3D = IfcAxis2Placement3D

var IfcBSplineCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Degree = Degree
    this.ControlPointsList = ControlPointsList
    this.CurveForm = CurveForm
    this.ClosedCurve = ClosedCurve
    this.SelfIntersect = SelfIntersect
  }
  IfcBSplineCurve.FromTape = function(expressID, type, tape) {
    let Degree
    Degree = tape[0]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[1].length) {
      ControlPointsList.push(tape[1][ControlPointsList_index++])
    }
    let CurveForm
    CurveForm = new IfcBSplineCurveForm(tape[2])
    let ClosedCurve
    ClosedCurve = tape[3]
    let SelfIntersect
    SelfIntersect = tape[4]
    return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect)
  }
  IfcBSplineCurve.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.Degree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.CurveForm.value)
    return args
  }
  return IfcBSplineCurve
}())
exports.IfcBSplineCurve = IfcBSplineCurve

var IfcBSplineCurveWithKnots = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
    this.expressID = expressID
    this.type = type
    this.Degree = Degree
    this.ControlPointsList = ControlPointsList
    this.CurveForm = CurveForm
    this.ClosedCurve = ClosedCurve
    this.SelfIntersect = SelfIntersect
    this.KnotMultiplicities = KnotMultiplicities
    this.Knots = Knots
    this.KnotSpec = KnotSpec
  }
  IfcBSplineCurveWithKnots.FromTape = function(expressID, type, tape) {
    let Degree
    Degree = tape[0]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[1].length) {
      ControlPointsList.push(tape[1][ControlPointsList_index++])
    }
    let CurveForm
    CurveForm = new IfcBSplineCurveForm(tape[2])
    let ClosedCurve
    ClosedCurve = tape[3]
    let SelfIntersect
    SelfIntersect = tape[4]
    let KnotMultiplicities
    KnotMultiplicities = []
    let KnotMultiplicities_index = 0
    while (KnotMultiplicities_index < tape[5].length) {
      KnotMultiplicities.push(tape[5][KnotMultiplicities_index++])
    }
    let Knots
    Knots = []
    let Knots_index = 0
    while (Knots_index < tape[6].length) {
      Knots.push(tape[6][Knots_index++])
    }
    let KnotSpec
    KnotSpec = new IfcKnotType(tape[7])
    return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec)
  }
  IfcBSplineCurveWithKnots.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.Degree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.CurveForm.value)
    args.push(REAL)
    args.push.apply(args, this.KnotMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.Knots)
    args.push(ENUM)
    args.push(this.KnotSpec.value)
    return args
  }
  return IfcBSplineCurveWithKnots
}())
exports.IfcBSplineCurveWithKnots = IfcBSplineCurveWithKnots

var IfcBSplineSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.UDegree = UDegree
    this.VDegree = VDegree
    this.ControlPointsList = ControlPointsList
    this.SurfaceForm = SurfaceForm
    this.UClosed = UClosed
    this.VClosed = VClosed
    this.SelfIntersect = SelfIntersect
  }
  IfcBSplineSurface.FromTape = function(expressID, type, tape) {
    let UDegree
    UDegree = tape[0]
    let VDegree
    VDegree = tape[1]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[2].length) {
      ControlPointsList.push(tape[2][ControlPointsList_index++])
    }
    let SurfaceForm
    SurfaceForm = new IfcBSplineSurfaceForm(tape[3])
    let UClosed
    UClosed = tape[4]
    let VClosed
    VClosed = tape[5]
    let SelfIntersect
    SelfIntersect = tape[6]
    return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect)
  }
  IfcBSplineSurface.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.UDegree)
    args.push(REAL)
    args.push(this.VDegree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.SurfaceForm.value)
    return args
  }
  return IfcBSplineSurface
}())
exports.IfcBSplineSurface = IfcBSplineSurface

var IfcBSplineSurfaceWithKnots = /** @class */ (function() {
  /**
   *
   */
  function IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
    this.expressID = expressID
    this.type = type
    this.UDegree = UDegree
    this.VDegree = VDegree
    this.ControlPointsList = ControlPointsList
    this.SurfaceForm = SurfaceForm
    this.UClosed = UClosed
    this.VClosed = VClosed
    this.SelfIntersect = SelfIntersect
    this.UMultiplicities = UMultiplicities
    this.VMultiplicities = VMultiplicities
    this.UKnots = UKnots
    this.VKnots = VKnots
    this.KnotSpec = KnotSpec
  }
  IfcBSplineSurfaceWithKnots.FromTape = function(expressID, type, tape) {
    let UDegree
    UDegree = tape[0]
    let VDegree
    VDegree = tape[1]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[2].length) {
      ControlPointsList.push(tape[2][ControlPointsList_index++])
    }
    let SurfaceForm
    SurfaceForm = new IfcBSplineSurfaceForm(tape[3])
    let UClosed
    UClosed = tape[4]
    let VClosed
    VClosed = tape[5]
    let SelfIntersect
    SelfIntersect = tape[6]
    let UMultiplicities
    UMultiplicities = []
    let UMultiplicities_index = 0
    while (UMultiplicities_index < tape[7].length) {
      UMultiplicities.push(tape[7][UMultiplicities_index++])
    }
    let VMultiplicities
    VMultiplicities = []
    let VMultiplicities_index = 0
    while (VMultiplicities_index < tape[8].length) {
      VMultiplicities.push(tape[8][VMultiplicities_index++])
    }
    let UKnots
    UKnots = []
    let UKnots_index = 0
    while (UKnots_index < tape[9].length) {
      UKnots.push(tape[9][UKnots_index++])
    }
    let VKnots
    VKnots = []
    let VKnots_index = 0
    while (VKnots_index < tape[10].length) {
      VKnots.push(tape[10][VKnots_index++])
    }
    let KnotSpec
    KnotSpec = new IfcKnotType(tape[11])
    return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec)
  }
  IfcBSplineSurfaceWithKnots.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.UDegree)
    args.push(REAL)
    args.push(this.VDegree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.SurfaceForm.value)
    args.push(REAL)
    args.push.apply(args, this.UMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.VMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.UKnots)
    args.push(REAL)
    args.push.apply(args, this.VKnots)
    args.push(ENUM)
    args.push(this.KnotSpec.value)
    return args
  }
  return IfcBSplineSurfaceWithKnots
}())
exports.IfcBSplineSurfaceWithKnots = IfcBSplineSurfaceWithKnots

var IfcBeam = /** @class */ (function() {
  /**
   *
   */
  function IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBeam.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBeamTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBeam.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBeam
}())
exports.IfcBeam = IfcBeam

var IfcBeamStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBeamStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBeamTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBeamStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBeamStandardCase
}())
exports.IfcBeamStandardCase = IfcBeamStandardCase

var IfcBeamType = /** @class */ (function() {
  /**
   *
   */
  function IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBeamType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBeamTypeEnum(tape[9])
    return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBeamType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBeamType
}())
exports.IfcBeamType = IfcBeamType

var IfcBearing = /** @class */ (function() {
  /**
   *
   */
  function IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBearing.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBearingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBearing.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBearing
}())
exports.IfcBearing = IfcBearing

var IfcBearingType = /** @class */ (function() {
  /**
   *
   */
  function IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBearingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBearingTypeEnum(tape[9])
    return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBearingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBearingType
}())
exports.IfcBearingType = IfcBearingType

var IfcBlobTexture = /** @class */ (function() {
  /**
   *
   */
  function IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
    this.expressID = expressID
    this.type = type
    this.RepeatS = RepeatS
    this.RepeatT = RepeatT
    this.Mode = Mode
    this.TextureTransform = TextureTransform
    this.Parameter = Parameter
    this.RasterFormat = RasterFormat
    this.RasterCode = RasterCode
  }
  IfcBlobTexture.FromTape = function(expressID, type, tape) {
    let RepeatS
    RepeatS = tape[0]
    let RepeatT
    RepeatT = tape[1]
    let Mode
    if (tape[2]) {
      Mode = tape[2]
    } else {
      Mode = null
    }
    let TextureTransform
    if (tape[3]) {
      TextureTransform = tape[3]
    } else {
      TextureTransform = null
    }
    let Parameter
    if (tape[4]) {
      Parameter = []
      let Parameter_index = 0
      while (Parameter_index < tape[4].length) {
        Parameter.push(tape[4][Parameter_index++])
      }
    } else {
      Parameter = null
    }
    let RasterFormat
    RasterFormat = tape[5]
    let RasterCode
    RasterCode = tape[6]
    return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode)
  }
  IfcBlobTexture.prototype.ToTape = function() {
    const args = []
    if (this.Mode) {
      args.push(STRING)
      args.push(this.Mode)
    } else {
      args.push(EMPTY)
    }
    if (this.TextureTransform) {
      args.push(REF)
      args.push(this.TextureTransform)
    } else {
      args.push(EMPTY)
    }
    if (this.Parameter) {
      args.push(STRING)
      args.push.apply(args, this.Parameter)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.RasterFormat)
    args.push(REAL)
    args.push(this.RasterCode)
    return args
  }
  return IfcBlobTexture
}())
exports.IfcBlobTexture = IfcBlobTexture

var IfcBlock = /** @class */ (function() {
  /**
   *
   */
  function IfcBlock(expressID, type, Position, XLength, YLength, ZLength) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.XLength = XLength
    this.YLength = YLength
    this.ZLength = ZLength
  }
  IfcBlock.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let XLength
    XLength = tape[1]
    let YLength
    YLength = tape[2]
    let ZLength
    ZLength = tape[3]
    return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength)
  }
  IfcBlock.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcBlock
}())
exports.IfcBlock = IfcBlock

var IfcBoiler = /** @class */ (function() {
  /**
   *
   */
  function IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBoiler.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBoilerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBoiler.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoiler
}())
exports.IfcBoiler = IfcBoiler

var IfcBoilerType = /** @class */ (function() {
  /**
   *
   */
  function IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBoilerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBoilerTypeEnum(tape[9])
    return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBoilerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBoilerType
}())
exports.IfcBoilerType = IfcBoilerType

var IfcBooleanClippingResult = /** @class */ (function() {
  /**
   *
   */
  function IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID
    this.type = type
    this.Operator = Operator
    this.FirstOperand = FirstOperand
    this.SecondOperand = SecondOperand
  }
  IfcBooleanClippingResult.FromTape = function(expressID, type, tape) {
    let Operator
    Operator = new IfcBooleanOperator(tape[0])
    let FirstOperand
    FirstOperand = ParseType(tape[1], tape[2][0])
    let SecondOperand
    SecondOperand = ParseType(tape[2], tape[3][0])
    return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand)
  }
  IfcBooleanClippingResult.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.Operator.value)
    return args
  }
  return IfcBooleanClippingResult
}())
exports.IfcBooleanClippingResult = IfcBooleanClippingResult

var IfcBooleanResult = /** @class */ (function() {
  /**
   *
   */
  function IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID
    this.type = type
    this.Operator = Operator
    this.FirstOperand = FirstOperand
    this.SecondOperand = SecondOperand
  }
  IfcBooleanResult.FromTape = function(expressID, type, tape) {
    let Operator
    Operator = new IfcBooleanOperator(tape[0])
    let FirstOperand
    FirstOperand = ParseType(tape[1], tape[2][0])
    let SecondOperand
    SecondOperand = ParseType(tape[2], tape[3][0])
    return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand)
  }
  IfcBooleanResult.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.Operator.value)
    return args
  }
  return IfcBooleanResult
}())
exports.IfcBooleanResult = IfcBooleanResult

var IfcBoundaryCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryCondition(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcBoundaryCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcBoundaryCondition(expressID, type, Name)
  }
  IfcBoundaryCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoundaryCondition
}())
exports.IfcBoundaryCondition = IfcBoundaryCondition

var IfcBoundaryCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryCurve(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Segments = Segments
    this.SelfIntersect = SelfIntersect
  }
  IfcBoundaryCurve.FromTape = function(expressID, type, tape) {
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[0].length) {
      Segments.push(tape[0][Segments_index++])
    }
    let SelfIntersect
    SelfIntersect = tape[1]
    return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect)
  }
  IfcBoundaryCurve.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcBoundaryCurve
}())
exports.IfcBoundaryCurve = IfcBoundaryCurve

var IfcBoundaryEdgeCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX
    this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY
    this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ
    this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX
    this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY
    this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ
  }
  IfcBoundaryEdgeCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TranslationalStiffnessByLengthX
    if (tape[1]) {
      TranslationalStiffnessByLengthX = ParseType(tape[1], tape[2][0])
    } else {
      TranslationalStiffnessByLengthX = null
    }
    let TranslationalStiffnessByLengthY
    if (tape[2]) {
      TranslationalStiffnessByLengthY = ParseType(tape[2], tape[3][0])
    } else {
      TranslationalStiffnessByLengthY = null
    }
    let TranslationalStiffnessByLengthZ
    if (tape[3]) {
      TranslationalStiffnessByLengthZ = ParseType(tape[3], tape[4][0])
    } else {
      TranslationalStiffnessByLengthZ = null
    }
    let RotationalStiffnessByLengthX
    if (tape[4]) {
      RotationalStiffnessByLengthX = ParseType(tape[4], tape[5][0])
    } else {
      RotationalStiffnessByLengthX = null
    }
    let RotationalStiffnessByLengthY
    if (tape[5]) {
      RotationalStiffnessByLengthY = ParseType(tape[5], tape[6][0])
    } else {
      RotationalStiffnessByLengthY = null
    }
    let RotationalStiffnessByLengthZ
    if (tape[6]) {
      RotationalStiffnessByLengthZ = ParseType(tape[6], tape[7][0])
    } else {
      RotationalStiffnessByLengthZ = null
    }
    return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ)
  }
  IfcBoundaryEdgeCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByLengthX) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByLengthY) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByLengthZ) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessByLengthX) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessByLengthY) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessByLengthZ) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoundaryEdgeCondition
}())
exports.IfcBoundaryEdgeCondition = IfcBoundaryEdgeCondition

var IfcBoundaryFaceCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX
    this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY
    this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ
  }
  IfcBoundaryFaceCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TranslationalStiffnessByAreaX
    if (tape[1]) {
      TranslationalStiffnessByAreaX = ParseType(tape[1], tape[2][0])
    } else {
      TranslationalStiffnessByAreaX = null
    }
    let TranslationalStiffnessByAreaY
    if (tape[2]) {
      TranslationalStiffnessByAreaY = ParseType(tape[2], tape[3][0])
    } else {
      TranslationalStiffnessByAreaY = null
    }
    let TranslationalStiffnessByAreaZ
    if (tape[3]) {
      TranslationalStiffnessByAreaZ = ParseType(tape[3], tape[4][0])
    } else {
      TranslationalStiffnessByAreaZ = null
    }
    return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ)
  }
  IfcBoundaryFaceCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByAreaX) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByAreaY) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessByAreaZ) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoundaryFaceCondition
}())
exports.IfcBoundaryFaceCondition = IfcBoundaryFaceCondition

var IfcBoundaryNodeCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TranslationalStiffnessX = TranslationalStiffnessX
    this.TranslationalStiffnessY = TranslationalStiffnessY
    this.TranslationalStiffnessZ = TranslationalStiffnessZ
    this.RotationalStiffnessX = RotationalStiffnessX
    this.RotationalStiffnessY = RotationalStiffnessY
    this.RotationalStiffnessZ = RotationalStiffnessZ
  }
  IfcBoundaryNodeCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TranslationalStiffnessX
    if (tape[1]) {
      TranslationalStiffnessX = ParseType(tape[1], tape[2][0])
    } else {
      TranslationalStiffnessX = null
    }
    let TranslationalStiffnessY
    if (tape[2]) {
      TranslationalStiffnessY = ParseType(tape[2], tape[3][0])
    } else {
      TranslationalStiffnessY = null
    }
    let TranslationalStiffnessZ
    if (tape[3]) {
      TranslationalStiffnessZ = ParseType(tape[3], tape[4][0])
    } else {
      TranslationalStiffnessZ = null
    }
    let RotationalStiffnessX
    if (tape[4]) {
      RotationalStiffnessX = ParseType(tape[4], tape[5][0])
    } else {
      RotationalStiffnessX = null
    }
    let RotationalStiffnessY
    if (tape[5]) {
      RotationalStiffnessY = ParseType(tape[5], tape[6][0])
    } else {
      RotationalStiffnessY = null
    }
    let RotationalStiffnessZ
    if (tape[6]) {
      RotationalStiffnessZ = ParseType(tape[6], tape[7][0])
    } else {
      RotationalStiffnessZ = null
    }
    return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ)
  }
  IfcBoundaryNodeCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessX) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessY) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessZ) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessX) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessY) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessZ) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoundaryNodeCondition
}())
exports.IfcBoundaryNodeCondition = IfcBoundaryNodeCondition

var IfcBoundaryNodeConditionWarping = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TranslationalStiffnessX = TranslationalStiffnessX
    this.TranslationalStiffnessY = TranslationalStiffnessY
    this.TranslationalStiffnessZ = TranslationalStiffnessZ
    this.RotationalStiffnessX = RotationalStiffnessX
    this.RotationalStiffnessY = RotationalStiffnessY
    this.RotationalStiffnessZ = RotationalStiffnessZ
    this.WarpingStiffness = WarpingStiffness
  }
  IfcBoundaryNodeConditionWarping.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TranslationalStiffnessX
    if (tape[1]) {
      TranslationalStiffnessX = ParseType(tape[1], tape[2][0])
    } else {
      TranslationalStiffnessX = null
    }
    let TranslationalStiffnessY
    if (tape[2]) {
      TranslationalStiffnessY = ParseType(tape[2], tape[3][0])
    } else {
      TranslationalStiffnessY = null
    }
    let TranslationalStiffnessZ
    if (tape[3]) {
      TranslationalStiffnessZ = ParseType(tape[3], tape[4][0])
    } else {
      TranslationalStiffnessZ = null
    }
    let RotationalStiffnessX
    if (tape[4]) {
      RotationalStiffnessX = ParseType(tape[4], tape[5][0])
    } else {
      RotationalStiffnessX = null
    }
    let RotationalStiffnessY
    if (tape[5]) {
      RotationalStiffnessY = ParseType(tape[5], tape[6][0])
    } else {
      RotationalStiffnessY = null
    }
    let RotationalStiffnessZ
    if (tape[6]) {
      RotationalStiffnessZ = ParseType(tape[6], tape[7][0])
    } else {
      RotationalStiffnessZ = null
    }
    let WarpingStiffness
    if (tape[7]) {
      WarpingStiffness = ParseType(tape[7], tape[8][0])
    } else {
      WarpingStiffness = null
    }
    return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness)
  }
  IfcBoundaryNodeConditionWarping.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessX) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessY) {
    } else {
      args.push(EMPTY)
    }
    if (this.TranslationalStiffnessZ) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessX) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessY) {
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalStiffnessZ) {
    } else {
      args.push(EMPTY)
    }
    if (this.WarpingStiffness) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBoundaryNodeConditionWarping
}())
exports.IfcBoundaryNodeConditionWarping = IfcBoundaryNodeConditionWarping

var IfcBoundedCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundedCurve(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcBoundedCurve.FromTape = function(expressID, type, tape) {
    return new IfcBoundedCurve(expressID, type)
  }
  IfcBoundedCurve.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcBoundedCurve
}())
exports.IfcBoundedCurve = IfcBoundedCurve

var IfcBoundedSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundedSurface(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcBoundedSurface.FromTape = function(expressID, type, tape) {
    return new IfcBoundedSurface(expressID, type)
  }
  IfcBoundedSurface.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcBoundedSurface
}())
exports.IfcBoundedSurface = IfcBoundedSurface

var IfcBoundingBox = /** @class */ (function() {
  /**
   *
   */
  function IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim) {
    this.expressID = expressID
    this.type = type
    this.Corner = Corner
    this.XDim = XDim
    this.YDim = YDim
    this.ZDim = ZDim
  }
  IfcBoundingBox.FromTape = function(expressID, type, tape) {
    let Corner
    Corner = tape[0]
    let XDim
    XDim = tape[1]
    let YDim
    YDim = tape[2]
    let ZDim
    ZDim = tape[3]
    return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim)
  }
  IfcBoundingBox.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Corner)
    return args
  }
  return IfcBoundingBox
}())
exports.IfcBoundingBox = IfcBoundingBox

var IfcBoxedHalfSpace = /** @class */ (function() {
  /**
   *
   */
  function IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
    this.expressID = expressID
    this.type = type
    this.BaseSurface = BaseSurface
    this.AgreementFlag = AgreementFlag
    this.Enclosure = Enclosure
  }
  IfcBoxedHalfSpace.FromTape = function(expressID, type, tape) {
    let BaseSurface
    BaseSurface = tape[0]
    let AgreementFlag
    AgreementFlag = tape[1]
    let Enclosure
    Enclosure = tape[2]
    return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure)
  }
  IfcBoxedHalfSpace.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BaseSurface)
    args.push(REF)
    args.push(this.Enclosure)
    return args
  }
  return IfcBoxedHalfSpace
}())
exports.IfcBoxedHalfSpace = IfcBoxedHalfSpace

var IfcBridge = /** @class */ (function() {
  /**
   *
   */
  function IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.PredefinedType = PredefinedType
  }
  IfcBridge.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcBridgeTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType)
  }
  IfcBridge.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBridge
}())
exports.IfcBridge = IfcBridge

var IfcBridgePart = /** @class */ (function() {
  /**
   *
   */
  function IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.PredefinedType = PredefinedType
  }
  IfcBridgePart.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcBridgePartTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType)
  }
  IfcBridgePart.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBridgePart
}())
exports.IfcBridgePart = IfcBridgePart

var IfcBuilding = /** @class */ (function() {
  /**
   *
   */
  function IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.ElevationOfRefHeight = ElevationOfRefHeight
    this.ElevationOfTerrain = ElevationOfTerrain
    this.BuildingAddress = BuildingAddress
  }
  IfcBuilding.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let ElevationOfRefHeight
    if (tape[9]) {
      ElevationOfRefHeight = tape[9]
    } else {
      ElevationOfRefHeight = null
    }
    let ElevationOfTerrain
    if (tape[10]) {
      ElevationOfTerrain = tape[10]
    } else {
      ElevationOfTerrain = null
    }
    let BuildingAddress
    if (tape[11]) {
      BuildingAddress = tape[11]
    } else {
      BuildingAddress = null
    }
    return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress)
  }
  IfcBuilding.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ElevationOfRefHeight) {
      args.push(REAL)
      args.push(this.ElevationOfRefHeight)
    } else {
      args.push(EMPTY)
    }
    if (this.ElevationOfTerrain) {
      args.push(REAL)
      args.push(this.ElevationOfTerrain)
    } else {
      args.push(EMPTY)
    }
    if (this.BuildingAddress) {
      args.push(REF)
      args.push(this.BuildingAddress)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuilding
}())
exports.IfcBuilding = IfcBuilding

var IfcBuildingElement = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcBuildingElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcBuildingElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingElement
}())
exports.IfcBuildingElement = IfcBuildingElement

var IfcBuildingElementPart = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBuildingElementPart.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBuildingElementPartTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBuildingElementPart.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingElementPart
}())
exports.IfcBuildingElementPart = IfcBuildingElementPart

var IfcBuildingElementPartType = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBuildingElementPartType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBuildingElementPartTypeEnum(tape[9])
    return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBuildingElementPartType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBuildingElementPartType
}())
exports.IfcBuildingElementPartType = IfcBuildingElementPartType

var IfcBuildingElementProxy = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBuildingElementProxy.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBuildingElementProxyTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBuildingElementProxy.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingElementProxy
}())
exports.IfcBuildingElementProxy = IfcBuildingElementProxy

var IfcBuildingElementProxyType = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBuildingElementProxyType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBuildingElementProxyTypeEnum(tape[9])
    return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBuildingElementProxyType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBuildingElementProxyType
}())
exports.IfcBuildingElementProxyType = IfcBuildingElementProxyType

var IfcBuildingElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcBuildingElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcBuildingElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingElementType
}())
exports.IfcBuildingElementType = IfcBuildingElementType

var IfcBuildingStorey = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.Elevation = Elevation
  }
  IfcBuildingStorey.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let Elevation
    if (tape[9]) {
      Elevation = tape[9]
    } else {
      Elevation = null
    }
    return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation)
  }
  IfcBuildingStorey.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Elevation) {
      args.push(REAL)
      args.push(this.Elevation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingStorey
}())
exports.IfcBuildingStorey = IfcBuildingStorey

var IfcBuildingSystem = /** @class */ (function() {
  /**
   *
   */
  function IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.PredefinedType = PredefinedType
    this.LongName = LongName
  }
  IfcBuildingSystem.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let PredefinedType
    if (tape[5]) {
      PredefinedType = new IfcBuildingSystemTypeEnum(tape[5])
    } else {
      PredefinedType = null
    }
    let LongName
    if (tape[6]) {
      LongName = tape[6]
    } else {
      LongName = null
    }
    return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName)
  }
  IfcBuildingSystem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBuildingSystem
}())
exports.IfcBuildingSystem = IfcBuildingSystem

var IfcBurner = /** @class */ (function() {
  /**
   *
   */
  function IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcBurner.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcBurnerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcBurner.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcBurner
}())
exports.IfcBurner = IfcBurner

var IfcBurnerType = /** @class */ (function() {
  /**
   *
   */
  function IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcBurnerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcBurnerTypeEnum(tape[9])
    return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcBurnerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcBurnerType
}())
exports.IfcBurnerType = IfcBurnerType

var IfcCShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Depth = Depth
    this.Width = Width
    this.WallThickness = WallThickness
    this.Girth = Girth
    this.InternalFilletRadius = InternalFilletRadius
  }
  IfcCShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Depth
    Depth = tape[3]
    let Width
    Width = tape[4]
    let WallThickness
    WallThickness = tape[5]
    let Girth
    Girth = tape[6]
    let InternalFilletRadius
    if (tape[7]) {
      InternalFilletRadius = tape[7]
    } else {
      InternalFilletRadius = null
    }
    return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius)
  }
  IfcCShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.InternalFilletRadius) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCShapeProfileDef
}())
exports.IfcCShapeProfileDef = IfcCShapeProfileDef

var IfcCableCarrierFitting = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCableCarrierFitting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCableCarrierFittingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCableCarrierFitting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCableCarrierFitting
}())
exports.IfcCableCarrierFitting = IfcCableCarrierFitting

var IfcCableCarrierFittingType = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCableCarrierFittingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCableCarrierFittingTypeEnum(tape[9])
    return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCableCarrierFittingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCableCarrierFittingType
}())
exports.IfcCableCarrierFittingType = IfcCableCarrierFittingType

var IfcCableCarrierSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCableCarrierSegment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCableCarrierSegmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCableCarrierSegment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCableCarrierSegment
}())
exports.IfcCableCarrierSegment = IfcCableCarrierSegment

var IfcCableCarrierSegmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCableCarrierSegmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCableCarrierSegmentTypeEnum(tape[9])
    return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCableCarrierSegmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCableCarrierSegmentType
}())
exports.IfcCableCarrierSegmentType = IfcCableCarrierSegmentType

var IfcCableFitting = /** @class */ (function() {
  /**
   *
   */
  function IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCableFitting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCableFittingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCableFitting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCableFitting
}())
exports.IfcCableFitting = IfcCableFitting

var IfcCableFittingType = /** @class */ (function() {
  /**
   *
   */
  function IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCableFittingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCableFittingTypeEnum(tape[9])
    return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCableFittingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCableFittingType
}())
exports.IfcCableFittingType = IfcCableFittingType

var IfcCableSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCableSegment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCableSegmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCableSegment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCableSegment
}())
exports.IfcCableSegment = IfcCableSegment

var IfcCableSegmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCableSegmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCableSegmentTypeEnum(tape[9])
    return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCableSegmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCableSegmentType
}())
exports.IfcCableSegmentType = IfcCableSegmentType

var IfcCaissonFoundation = /** @class */ (function() {
  /**
   *
   */
  function IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCaissonFoundation.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCaissonFoundationTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCaissonFoundation.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCaissonFoundation
}())
exports.IfcCaissonFoundation = IfcCaissonFoundation

var IfcCaissonFoundationType = /** @class */ (function() {
  /**
   *
   */
  function IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCaissonFoundationType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCaissonFoundationTypeEnum(tape[9])
    return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCaissonFoundationType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCaissonFoundationType
}())
exports.IfcCaissonFoundationType = IfcCaissonFoundationType

var IfcCartesianPoint = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianPoint(expressID, type, Coordinates) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
  }
  IfcCartesianPoint.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = []
    let Coordinates_index = 0
    while (Coordinates_index < tape[0].length) {
      Coordinates.push(tape[0][Coordinates_index++])
    }
    return new IfcCartesianPoint(expressID, type, Coordinates)
  }
  IfcCartesianPoint.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.Coordinates)
    return args
  }
  return IfcCartesianPoint
}())
exports.IfcCartesianPoint = IfcCartesianPoint

var IfcCartesianPointList = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianPointList(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcCartesianPointList.FromTape = function(expressID, type, tape) {
    return new IfcCartesianPointList(expressID, type)
  }
  IfcCartesianPointList.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcCartesianPointList
}())
exports.IfcCartesianPointList = IfcCartesianPointList

var IfcCartesianPointList2D = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianPointList2D(expressID, type, CoordList, TagList) {
    this.expressID = expressID
    this.type = type
    this.CoordList = CoordList
    this.TagList = TagList
  }
  IfcCartesianPointList2D.FromTape = function(expressID, type, tape) {
    let CoordList
    CoordList = []
    let CoordList_index = 0
    while (CoordList_index < tape[0].length) {
      CoordList.push(tape[0][CoordList_index++])
    }
    let TagList
    if (tape[1]) {
      TagList = []
      let TagList_index = 0
      while (TagList_index < tape[1].length) {
        TagList.push(tape[1][TagList_index++])
      }
    } else {
      TagList = null
    }
    return new IfcCartesianPointList2D(expressID, type, CoordList, TagList)
  }
  IfcCartesianPointList2D.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.CoordList)
    if (this.TagList) {
      args.push(STRING)
      args.push.apply(args, this.TagList)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianPointList2D
}())
exports.IfcCartesianPointList2D = IfcCartesianPointList2D

var IfcCartesianPointList3D = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianPointList3D(expressID, type, CoordList, TagList) {
    this.expressID = expressID
    this.type = type
    this.CoordList = CoordList
    this.TagList = TagList
  }
  IfcCartesianPointList3D.FromTape = function(expressID, type, tape) {
    let CoordList
    CoordList = []
    let CoordList_index = 0
    while (CoordList_index < tape[0].length) {
      CoordList.push(tape[0][CoordList_index++])
    }
    let TagList
    if (tape[1]) {
      TagList = []
      let TagList_index = 0
      while (TagList_index < tape[1].length) {
        TagList.push(tape[1][TagList_index++])
      }
    } else {
      TagList = null
    }
    return new IfcCartesianPointList3D(expressID, type, CoordList, TagList)
  }
  IfcCartesianPointList3D.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.CoordList)
    if (this.TagList) {
      args.push(STRING)
      args.push.apply(args, this.TagList)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianPointList3D
}())
exports.IfcCartesianPointList3D = IfcCartesianPointList3D

var IfcCartesianTransformationOperator = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID
    this.type = type
    this.Axis1 = Axis1
    this.Axis2 = Axis2
    this.LocalOrigin = LocalOrigin
    this.Scale = Scale
  }
  IfcCartesianTransformationOperator.FromTape = function(expressID, type, tape) {
    let Axis1
    if (tape[0]) {
      Axis1 = tape[0]
    } else {
      Axis1 = null
    }
    let Axis2
    if (tape[1]) {
      Axis2 = tape[1]
    } else {
      Axis2 = null
    }
    let LocalOrigin
    LocalOrigin = tape[2]
    let Scale
    if (tape[3]) {
      Scale = tape[3]
    } else {
      Scale = null
    }
    return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale)
  }
  IfcCartesianTransformationOperator.prototype.ToTape = function() {
    const args = []
    if (this.Axis1) {
      args.push(REF)
      args.push(this.Axis1)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis2) {
      args.push(REF)
      args.push(this.Axis2)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LocalOrigin)
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianTransformationOperator
}())
exports.IfcCartesianTransformationOperator = IfcCartesianTransformationOperator

var IfcCartesianTransformationOperator2D = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID
    this.type = type
    this.Axis1 = Axis1
    this.Axis2 = Axis2
    this.LocalOrigin = LocalOrigin
    this.Scale = Scale
  }
  IfcCartesianTransformationOperator2D.FromTape = function(expressID, type, tape) {
    let Axis1
    if (tape[0]) {
      Axis1 = tape[0]
    } else {
      Axis1 = null
    }
    let Axis2
    if (tape[1]) {
      Axis2 = tape[1]
    } else {
      Axis2 = null
    }
    let LocalOrigin
    LocalOrigin = tape[2]
    let Scale
    if (tape[3]) {
      Scale = tape[3]
    } else {
      Scale = null
    }
    return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale)
  }
  IfcCartesianTransformationOperator2D.prototype.ToTape = function() {
    const args = []
    if (this.Axis1) {
      args.push(REF)
      args.push(this.Axis1)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis2) {
      args.push(REF)
      args.push(this.Axis2)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LocalOrigin)
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianTransformationOperator2D
}())
exports.IfcCartesianTransformationOperator2D = IfcCartesianTransformationOperator2D

var IfcCartesianTransformationOperator2DnonUniform = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
    this.expressID = expressID
    this.type = type
    this.Axis1 = Axis1
    this.Axis2 = Axis2
    this.LocalOrigin = LocalOrigin
    this.Scale = Scale
    this.Scale2 = Scale2
  }
  IfcCartesianTransformationOperator2DnonUniform.FromTape = function(expressID, type, tape) {
    let Axis1
    if (tape[0]) {
      Axis1 = tape[0]
    } else {
      Axis1 = null
    }
    let Axis2
    if (tape[1]) {
      Axis2 = tape[1]
    } else {
      Axis2 = null
    }
    let LocalOrigin
    LocalOrigin = tape[2]
    let Scale
    if (tape[3]) {
      Scale = tape[3]
    } else {
      Scale = null
    }
    let Scale2
    if (tape[4]) {
      Scale2 = tape[4]
    } else {
      Scale2 = null
    }
    return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2)
  }
  IfcCartesianTransformationOperator2DnonUniform.prototype.ToTape = function() {
    const args = []
    if (this.Axis1) {
      args.push(REF)
      args.push(this.Axis1)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis2) {
      args.push(REF)
      args.push(this.Axis2)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LocalOrigin)
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    if (this.Scale2) {
      args.push(REAL)
      args.push(this.Scale2)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianTransformationOperator2DnonUniform
}())
exports.IfcCartesianTransformationOperator2DnonUniform = IfcCartesianTransformationOperator2DnonUniform

var IfcCartesianTransformationOperator3D = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
    this.expressID = expressID
    this.type = type
    this.Axis1 = Axis1
    this.Axis2 = Axis2
    this.LocalOrigin = LocalOrigin
    this.Scale = Scale
    this.Axis3 = Axis3
  }
  IfcCartesianTransformationOperator3D.FromTape = function(expressID, type, tape) {
    let Axis1
    if (tape[0]) {
      Axis1 = tape[0]
    } else {
      Axis1 = null
    }
    let Axis2
    if (tape[1]) {
      Axis2 = tape[1]
    } else {
      Axis2 = null
    }
    let LocalOrigin
    LocalOrigin = tape[2]
    let Scale
    if (tape[3]) {
      Scale = tape[3]
    } else {
      Scale = null
    }
    let Axis3
    if (tape[4]) {
      Axis3 = tape[4]
    } else {
      Axis3 = null
    }
    return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3)
  }
  IfcCartesianTransformationOperator3D.prototype.ToTape = function() {
    const args = []
    if (this.Axis1) {
      args.push(REF)
      args.push(this.Axis1)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis2) {
      args.push(REF)
      args.push(this.Axis2)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LocalOrigin)
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis3) {
      args.push(REF)
      args.push(this.Axis3)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianTransformationOperator3D
}())
exports.IfcCartesianTransformationOperator3D = IfcCartesianTransformationOperator3D

var IfcCartesianTransformationOperator3DnonUniform = /** @class */ (function() {
  /**
   *
   */
  function IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
    this.expressID = expressID
    this.type = type
    this.Axis1 = Axis1
    this.Axis2 = Axis2
    this.LocalOrigin = LocalOrigin
    this.Scale = Scale
    this.Axis3 = Axis3
    this.Scale2 = Scale2
    this.Scale3 = Scale3
  }
  IfcCartesianTransformationOperator3DnonUniform.FromTape = function(expressID, type, tape) {
    let Axis1
    if (tape[0]) {
      Axis1 = tape[0]
    } else {
      Axis1 = null
    }
    let Axis2
    if (tape[1]) {
      Axis2 = tape[1]
    } else {
      Axis2 = null
    }
    let LocalOrigin
    LocalOrigin = tape[2]
    let Scale
    if (tape[3]) {
      Scale = tape[3]
    } else {
      Scale = null
    }
    let Axis3
    if (tape[4]) {
      Axis3 = tape[4]
    } else {
      Axis3 = null
    }
    let Scale2
    if (tape[5]) {
      Scale2 = tape[5]
    } else {
      Scale2 = null
    }
    let Scale3
    if (tape[6]) {
      Scale3 = tape[6]
    } else {
      Scale3 = null
    }
    return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3)
  }
  IfcCartesianTransformationOperator3DnonUniform.prototype.ToTape = function() {
    const args = []
    if (this.Axis1) {
      args.push(REF)
      args.push(this.Axis1)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis2) {
      args.push(REF)
      args.push(this.Axis2)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LocalOrigin)
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    if (this.Axis3) {
      args.push(REF)
      args.push(this.Axis3)
    } else {
      args.push(EMPTY)
    }
    if (this.Scale2) {
      args.push(REAL)
      args.push(this.Scale2)
    } else {
      args.push(EMPTY)
    }
    if (this.Scale3) {
      args.push(REAL)
      args.push(this.Scale3)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCartesianTransformationOperator3DnonUniform
}())
exports.IfcCartesianTransformationOperator3DnonUniform = IfcCartesianTransformationOperator3DnonUniform

var IfcCenterLineProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Curve = Curve
    this.Thickness = Thickness
  }
  IfcCenterLineProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Curve
    Curve = tape[2]
    let Thickness
    Thickness = tape[3]
    return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness)
  }
  IfcCenterLineProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Curve)
    return args
  }
  return IfcCenterLineProfileDef
}())
exports.IfcCenterLineProfileDef = IfcCenterLineProfileDef

var IfcChiller = /** @class */ (function() {
  /**
   *
   */
  function IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcChiller.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcChillerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcChiller.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcChiller
}())
exports.IfcChiller = IfcChiller

var IfcChillerType = /** @class */ (function() {
  /**
   *
   */
  function IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcChillerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcChillerTypeEnum(tape[9])
    return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcChillerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcChillerType
}())
exports.IfcChillerType = IfcChillerType

var IfcChimney = /** @class */ (function() {
  /**
   *
   */
  function IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcChimney.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcChimneyTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcChimney.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcChimney
}())
exports.IfcChimney = IfcChimney

var IfcChimneyType = /** @class */ (function() {
  /**
   *
   */
  function IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcChimneyType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcChimneyTypeEnum(tape[9])
    return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcChimneyType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcChimneyType
}())
exports.IfcChimneyType = IfcChimneyType

var IfcCircle = /** @class */ (function() {
  /**
   *
   */
  function IfcCircle(expressID, type, Position, Radius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Radius = Radius
  }
  IfcCircle.FromTape = function(expressID, type, tape) {
    let Position
    Position = ParseType(tape[0], tape[1][0])
    let Radius
    Radius = tape[1]
    return new IfcCircle(expressID, type, Position, Radius)
  }
  IfcCircle.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcCircle
}())
exports.IfcCircle = IfcCircle

var IfcCircleHollowProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Radius = Radius
    this.WallThickness = WallThickness
  }
  IfcCircleHollowProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Radius
    Radius = tape[3]
    let WallThickness
    WallThickness = tape[4]
    return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness)
  }
  IfcCircleHollowProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCircleHollowProfileDef
}())
exports.IfcCircleHollowProfileDef = IfcCircleHollowProfileDef

var IfcCircleProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Radius = Radius
  }
  IfcCircleProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Radius
    Radius = tape[3]
    return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius)
  }
  IfcCircleProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCircleProfileDef
}())
exports.IfcCircleProfileDef = IfcCircleProfileDef

var IfcCircularArcSegment2D = /** @class */ (function() {
  /**
   *
   */
  function IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
    this.expressID = expressID
    this.type = type
    this.StartPoint = StartPoint
    this.StartDirection = StartDirection
    this.SegmentLength = SegmentLength
    this.Radius = Radius
    this.IsCCW = IsCCW
  }
  IfcCircularArcSegment2D.FromTape = function(expressID, type, tape) {
    let StartPoint
    StartPoint = tape[0]
    let StartDirection
    StartDirection = tape[1]
    let SegmentLength
    SegmentLength = tape[2]
    let Radius
    Radius = tape[3]
    let IsCCW
    IsCCW = tape[4]
    return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW)
  }
  IfcCircularArcSegment2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.StartPoint)
    args.push(REAL)
    args.push(this.StartDirection)
    return args
  }
  return IfcCircularArcSegment2D
}())
exports.IfcCircularArcSegment2D = IfcCircularArcSegment2D

var IfcCivilElement = /** @class */ (function() {
  /**
   *
   */
  function IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcCivilElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcCivilElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCivilElement
}())
exports.IfcCivilElement = IfcCivilElement

var IfcCivilElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcCivilElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcCivilElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCivilElementType
}())
exports.IfcCivilElementType = IfcCivilElementType

var IfcClassification = /** @class */ (function() {
  /**
   *
   */
  function IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
    this.expressID = expressID
    this.type = type
    this.Source = Source
    this.Edition = Edition
    this.EditionDate = EditionDate
    this.Name = Name
    this.Description = Description
    this.Location = Location
    this.ReferenceTokens = ReferenceTokens
  }
  IfcClassification.FromTape = function(expressID, type, tape) {
    let Source
    if (tape[0]) {
      Source = tape[0]
    } else {
      Source = null
    }
    let Edition
    if (tape[1]) {
      Edition = tape[1]
    } else {
      Edition = null
    }
    let EditionDate
    if (tape[2]) {
      EditionDate = tape[2]
    } else {
      EditionDate = null
    }
    let Name
    Name = tape[3]
    let Description
    if (tape[4]) {
      Description = tape[4]
    } else {
      Description = null
    }
    let Location
    if (tape[5]) {
      Location = tape[5]
    } else {
      Location = null
    }
    let ReferenceTokens
    if (tape[6]) {
      ReferenceTokens = []
      let ReferenceTokens_index = 0
      while (ReferenceTokens_index < tape[6].length) {
        ReferenceTokens.push(tape[6][ReferenceTokens_index++])
      }
    } else {
      ReferenceTokens = null
    }
    return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens)
  }
  IfcClassification.prototype.ToTape = function() {
    const args = []
    if (this.Source) {
      args.push(STRING)
      args.push(this.Source)
    } else {
      args.push(EMPTY)
    }
    if (this.Edition) {
      args.push(STRING)
      args.push(this.Edition)
    } else {
      args.push(EMPTY)
    }
    if (this.EditionDate) {
      args.push(STRING)
      args.push(this.EditionDate)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.ReferenceTokens) {
      args.push(STRING)
      args.push.apply(args, this.ReferenceTokens)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcClassification
}())
exports.IfcClassification = IfcClassification

var IfcClassificationReference = /** @class */ (function() {
  /**
   *
   */
  function IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
    this.ReferencedSource = ReferencedSource
    this.Description = Description
    this.Sort = Sort
  }
  IfcClassificationReference.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let ReferencedSource
    if (tape[3]) {
      ReferencedSource = ParseType(tape[3], tape[4][0])
    } else {
      ReferencedSource = null
    }
    let Description
    if (tape[4]) {
      Description = tape[4]
    } else {
      Description = null
    }
    let Sort
    if (tape[5]) {
      Sort = tape[5]
    } else {
      Sort = null
    }
    return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort)
  }
  IfcClassificationReference.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.ReferencedSource) {
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Sort) {
      args.push(STRING)
      args.push(this.Sort)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcClassificationReference
}())
exports.IfcClassificationReference = IfcClassificationReference

var IfcClosedShell = /** @class */ (function() {
  /**
   *
   */
  function IfcClosedShell(expressID, type, CfsFaces) {
    this.expressID = expressID
    this.type = type
    this.CfsFaces = CfsFaces
  }
  IfcClosedShell.FromTape = function(expressID, type, tape) {
    let CfsFaces
    CfsFaces = []
    let CfsFaces_index = 0
    while (CfsFaces_index < tape[0].length) {
      CfsFaces.push(tape[0][CfsFaces_index++])
    }
    return new IfcClosedShell(expressID, type, CfsFaces)
  }
  IfcClosedShell.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.CfsFaces.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcClosedShell
}())
exports.IfcClosedShell = IfcClosedShell

var IfcCoil = /** @class */ (function() {
  /**
   *
   */
  function IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCoil.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCoilTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCoil.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCoil
}())
exports.IfcCoil = IfcCoil

var IfcCoilType = /** @class */ (function() {
  /**
   *
   */
  function IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCoilType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCoilTypeEnum(tape[9])
    return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCoilType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCoilType
}())
exports.IfcCoilType = IfcCoilType

var IfcColourRgb = /** @class */ (function() {
  /**
   *
   */
  function IfcColourRgb(expressID, type, Name, Red, Green, Blue) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Red = Red
    this.Green = Green
    this.Blue = Blue
  }
  IfcColourRgb.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Red
    Red = tape[1]
    let Green
    Green = tape[2]
    let Blue
    Blue = tape[3]
    return new IfcColourRgb(expressID, type, Name, Red, Green, Blue)
  }
  IfcColourRgb.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcColourRgb
}())
exports.IfcColourRgb = IfcColourRgb

var IfcColourRgbList = /** @class */ (function() {
  /**
   *
   */
  function IfcColourRgbList(expressID, type, ColourList) {
    this.expressID = expressID
    this.type = type
    this.ColourList = ColourList
  }
  IfcColourRgbList.FromTape = function(expressID, type, tape) {
    let ColourList
    ColourList = []
    let ColourList_index = 0
    while (ColourList_index < tape[0].length) {
      ColourList.push(tape[0][ColourList_index++])
    }
    return new IfcColourRgbList(expressID, type, ColourList)
  }
  IfcColourRgbList.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcColourRgbList
}())
exports.IfcColourRgbList = IfcColourRgbList

var IfcColourSpecification = /** @class */ (function() {
  /**
   *
   */
  function IfcColourSpecification(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcColourSpecification.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcColourSpecification(expressID, type, Name)
  }
  IfcColourSpecification.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcColourSpecification
}())
exports.IfcColourSpecification = IfcColourSpecification

var IfcColumn = /** @class */ (function() {
  /**
   *
   */
  function IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcColumn.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcColumnTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcColumn.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcColumn
}())
exports.IfcColumn = IfcColumn

var IfcColumnStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcColumnStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcColumnTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcColumnStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcColumnStandardCase
}())
exports.IfcColumnStandardCase = IfcColumnStandardCase

var IfcColumnType = /** @class */ (function() {
  /**
   *
   */
  function IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcColumnType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcColumnTypeEnum(tape[9])
    return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcColumnType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcColumnType
}())
exports.IfcColumnType = IfcColumnType

var IfcCommunicationsAppliance = /** @class */ (function() {
  /**
   *
   */
  function IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCommunicationsAppliance.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCommunicationsApplianceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCommunicationsAppliance.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCommunicationsAppliance
}())
exports.IfcCommunicationsAppliance = IfcCommunicationsAppliance

var IfcCommunicationsApplianceType = /** @class */ (function() {
  /**
   *
   */
  function IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCommunicationsApplianceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCommunicationsApplianceTypeEnum(tape[9])
    return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCommunicationsApplianceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCommunicationsApplianceType
}())
exports.IfcCommunicationsApplianceType = IfcCommunicationsApplianceType

var IfcComplexProperty = /** @class */ (function() {
  /**
   *
   */
  function IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.UsageName = UsageName
    this.HasProperties = HasProperties
  }
  IfcComplexProperty.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UsageName
    UsageName = tape[2]
    let HasProperties
    HasProperties = []
    let HasProperties_index = 0
    while (HasProperties_index < tape[3].length) {
      HasProperties.push(tape[3][HasProperties_index++])
    }
    return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties)
  }
  IfcComplexProperty.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.UsageName)
    args.push(SET_BEGIN)
    this.HasProperties.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcComplexProperty
}())
exports.IfcComplexProperty = IfcComplexProperty

var IfcComplexPropertyTemplate = /** @class */ (function() {
  /**
   *
   */
  function IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.UsageName = UsageName
    this.TemplateType = TemplateType
    this.HasPropertyTemplates = HasPropertyTemplates
  }
  IfcComplexPropertyTemplate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let UsageName
    if (tape[4]) {
      UsageName = tape[4]
    } else {
      UsageName = null
    }
    let TemplateType
    if (tape[5]) {
      TemplateType = new IfcComplexPropertyTemplateTypeEnum(tape[5])
    } else {
      TemplateType = null
    }
    let HasPropertyTemplates
    if (tape[6]) {
      HasPropertyTemplates = []
      let HasPropertyTemplates_index = 0
      while (HasPropertyTemplates_index < tape[6].length) {
        HasPropertyTemplates.push(tape[6][HasPropertyTemplates_index++])
      }
    } else {
      HasPropertyTemplates = null
    }
    return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates)
  }
  IfcComplexPropertyTemplate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UsageName) {
      args.push(STRING)
      args.push(this.UsageName)
    } else {
      args.push(EMPTY)
    }
    if (this.TemplateType) {
      args.push(ENUM)
      args.push(this.TemplateType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertyTemplates) {
      args.push(SET_BEGIN)
      this.HasPropertyTemplates.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcComplexPropertyTemplate
}())
exports.IfcComplexPropertyTemplate = IfcComplexPropertyTemplate

var IfcCompositeCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcCompositeCurve(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Segments = Segments
    this.SelfIntersect = SelfIntersect
  }
  IfcCompositeCurve.FromTape = function(expressID, type, tape) {
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[0].length) {
      Segments.push(tape[0][Segments_index++])
    }
    let SelfIntersect
    SelfIntersect = tape[1]
    return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect)
  }
  IfcCompositeCurve.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcCompositeCurve
}())
exports.IfcCompositeCurve = IfcCompositeCurve

var IfcCompositeCurveOnSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Segments = Segments
    this.SelfIntersect = SelfIntersect
  }
  IfcCompositeCurveOnSurface.FromTape = function(expressID, type, tape) {
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[0].length) {
      Segments.push(tape[0][Segments_index++])
    }
    let SelfIntersect
    SelfIntersect = tape[1]
    return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect)
  }
  IfcCompositeCurveOnSurface.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcCompositeCurveOnSurface
}())
exports.IfcCompositeCurveOnSurface = IfcCompositeCurveOnSurface

var IfcCompositeCurveSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve) {
    this.expressID = expressID
    this.type = type
    this.Transition = Transition
    this.SameSense = SameSense
    this.ParentCurve = ParentCurve
  }
  IfcCompositeCurveSegment.FromTape = function(expressID, type, tape) {
    let Transition
    Transition = new IfcTransitionCode(tape[0])
    let SameSense
    SameSense = tape[1]
    let ParentCurve
    ParentCurve = tape[2]
    return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve)
  }
  IfcCompositeCurveSegment.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.Transition.value)
    args.push(REF)
    args.push(this.ParentCurve)
    return args
  }
  return IfcCompositeCurveSegment
}())
exports.IfcCompositeCurveSegment = IfcCompositeCurveSegment

var IfcCompositeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Profiles = Profiles
    this.Label = Label
  }
  IfcCompositeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Profiles
    Profiles = []
    let Profiles_index = 0
    while (Profiles_index < tape[2].length) {
      Profiles.push(tape[2][Profiles_index++])
    }
    let Label
    if (tape[3]) {
      Label = tape[3]
    } else {
      Label = null
    }
    return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label)
  }
  IfcCompositeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Profiles.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.Label) {
      args.push(STRING)
      args.push(this.Label)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCompositeProfileDef
}())
exports.IfcCompositeProfileDef = IfcCompositeProfileDef

var IfcCompressor = /** @class */ (function() {
  /**
   *
   */
  function IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCompressor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCompressorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCompressor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCompressor
}())
exports.IfcCompressor = IfcCompressor

var IfcCompressorType = /** @class */ (function() {
  /**
   *
   */
  function IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCompressorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCompressorTypeEnum(tape[9])
    return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCompressorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCompressorType
}())
exports.IfcCompressorType = IfcCompressorType

var IfcCondenser = /** @class */ (function() {
  /**
   *
   */
  function IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCondenser.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCondenserTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCondenser.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCondenser
}())
exports.IfcCondenser = IfcCondenser

var IfcCondenserType = /** @class */ (function() {
  /**
   *
   */
  function IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCondenserType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCondenserTypeEnum(tape[9])
    return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCondenserType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCondenserType
}())
exports.IfcCondenserType = IfcCondenserType

var IfcConic = /** @class */ (function() {
  /**
   *
   */
  function IfcConic(expressID, type, Position) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
  }
  IfcConic.FromTape = function(expressID, type, tape) {
    let Position
    Position = ParseType(tape[0], tape[1][0])
    return new IfcConic(expressID, type, Position)
  }
  IfcConic.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcConic
}())
exports.IfcConic = IfcConic

var IfcConnectedFaceSet = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectedFaceSet(expressID, type, CfsFaces) {
    this.expressID = expressID
    this.type = type
    this.CfsFaces = CfsFaces
  }
  IfcConnectedFaceSet.FromTape = function(expressID, type, tape) {
    let CfsFaces
    CfsFaces = []
    let CfsFaces_index = 0
    while (CfsFaces_index < tape[0].length) {
      CfsFaces.push(tape[0][CfsFaces_index++])
    }
    return new IfcConnectedFaceSet(expressID, type, CfsFaces)
  }
  IfcConnectedFaceSet.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.CfsFaces.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcConnectedFaceSet
}())
exports.IfcConnectedFaceSet = IfcConnectedFaceSet

var IfcConnectionCurveGeometry = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
    this.expressID = expressID
    this.type = type
    this.CurveOnRelatingElement = CurveOnRelatingElement
    this.CurveOnRelatedElement = CurveOnRelatedElement
  }
  IfcConnectionCurveGeometry.FromTape = function(expressID, type, tape) {
    let CurveOnRelatingElement
    CurveOnRelatingElement = ParseType(tape[0], tape[1][0])
    let CurveOnRelatedElement
    if (tape[1]) {
      CurveOnRelatedElement = ParseType(tape[1], tape[2][0])
    } else {
      CurveOnRelatedElement = null
    }
    return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement)
  }
  IfcConnectionCurveGeometry.prototype.ToTape = function() {
    const args = []
    if (this.CurveOnRelatedElement) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConnectionCurveGeometry
}())
exports.IfcConnectionCurveGeometry = IfcConnectionCurveGeometry

var IfcConnectionGeometry = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionGeometry(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcConnectionGeometry.FromTape = function(expressID, type, tape) {
    return new IfcConnectionGeometry(expressID, type)
  }
  IfcConnectionGeometry.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcConnectionGeometry
}())
exports.IfcConnectionGeometry = IfcConnectionGeometry

var IfcConnectionPointEccentricity = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
    this.expressID = expressID
    this.type = type
    this.PointOnRelatingElement = PointOnRelatingElement
    this.PointOnRelatedElement = PointOnRelatedElement
    this.EccentricityInX = EccentricityInX
    this.EccentricityInY = EccentricityInY
    this.EccentricityInZ = EccentricityInZ
  }
  IfcConnectionPointEccentricity.FromTape = function(expressID, type, tape) {
    let PointOnRelatingElement
    PointOnRelatingElement = ParseType(tape[0], tape[1][0])
    let PointOnRelatedElement
    if (tape[1]) {
      PointOnRelatedElement = ParseType(tape[1], tape[2][0])
    } else {
      PointOnRelatedElement = null
    }
    let EccentricityInX
    if (tape[2]) {
      EccentricityInX = tape[2]
    } else {
      EccentricityInX = null
    }
    let EccentricityInY
    if (tape[3]) {
      EccentricityInY = tape[3]
    } else {
      EccentricityInY = null
    }
    let EccentricityInZ
    if (tape[4]) {
      EccentricityInZ = tape[4]
    } else {
      EccentricityInZ = null
    }
    return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ)
  }
  IfcConnectionPointEccentricity.prototype.ToTape = function() {
    const args = []
    if (this.PointOnRelatedElement) {
    } else {
      args.push(EMPTY)
    }
    if (this.EccentricityInX) {
      args.push(REAL)
      args.push(this.EccentricityInX)
    } else {
      args.push(EMPTY)
    }
    if (this.EccentricityInY) {
      args.push(REAL)
      args.push(this.EccentricityInY)
    } else {
      args.push(EMPTY)
    }
    if (this.EccentricityInZ) {
      args.push(REAL)
      args.push(this.EccentricityInZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConnectionPointEccentricity
}())
exports.IfcConnectionPointEccentricity = IfcConnectionPointEccentricity

var IfcConnectionPointGeometry = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
    this.expressID = expressID
    this.type = type
    this.PointOnRelatingElement = PointOnRelatingElement
    this.PointOnRelatedElement = PointOnRelatedElement
  }
  IfcConnectionPointGeometry.FromTape = function(expressID, type, tape) {
    let PointOnRelatingElement
    PointOnRelatingElement = ParseType(tape[0], tape[1][0])
    let PointOnRelatedElement
    if (tape[1]) {
      PointOnRelatedElement = ParseType(tape[1], tape[2][0])
    } else {
      PointOnRelatedElement = null
    }
    return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement)
  }
  IfcConnectionPointGeometry.prototype.ToTape = function() {
    const args = []
    if (this.PointOnRelatedElement) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConnectionPointGeometry
}())
exports.IfcConnectionPointGeometry = IfcConnectionPointGeometry

var IfcConnectionSurfaceGeometry = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
    this.expressID = expressID
    this.type = type
    this.SurfaceOnRelatingElement = SurfaceOnRelatingElement
    this.SurfaceOnRelatedElement = SurfaceOnRelatedElement
  }
  IfcConnectionSurfaceGeometry.FromTape = function(expressID, type, tape) {
    let SurfaceOnRelatingElement
    SurfaceOnRelatingElement = ParseType(tape[0], tape[1][0])
    let SurfaceOnRelatedElement
    if (tape[1]) {
      SurfaceOnRelatedElement = ParseType(tape[1], tape[2][0])
    } else {
      SurfaceOnRelatedElement = null
    }
    return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement)
  }
  IfcConnectionSurfaceGeometry.prototype.ToTape = function() {
    const args = []
    if (this.SurfaceOnRelatedElement) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConnectionSurfaceGeometry
}())
exports.IfcConnectionSurfaceGeometry = IfcConnectionSurfaceGeometry

var IfcConnectionVolumeGeometry = /** @class */ (function() {
  /**
   *
   */
  function IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
    this.expressID = expressID
    this.type = type
    this.VolumeOnRelatingElement = VolumeOnRelatingElement
    this.VolumeOnRelatedElement = VolumeOnRelatedElement
  }
  IfcConnectionVolumeGeometry.FromTape = function(expressID, type, tape) {
    let VolumeOnRelatingElement
    VolumeOnRelatingElement = ParseType(tape[0], tape[1][0])
    let VolumeOnRelatedElement
    if (tape[1]) {
      VolumeOnRelatedElement = ParseType(tape[1], tape[2][0])
    } else {
      VolumeOnRelatedElement = null
    }
    return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement)
  }
  IfcConnectionVolumeGeometry.prototype.ToTape = function() {
    const args = []
    if (this.VolumeOnRelatedElement) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConnectionVolumeGeometry
}())
exports.IfcConnectionVolumeGeometry = IfcConnectionVolumeGeometry

var IfcConstraint = /** @class */ (function() {
  /**
   *
   */
  function IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.ConstraintGrade = ConstraintGrade
    this.ConstraintSource = ConstraintSource
    this.CreatingActor = CreatingActor
    this.CreationTime = CreationTime
    this.UserDefinedGrade = UserDefinedGrade
  }
  IfcConstraint.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let ConstraintGrade
    ConstraintGrade = new IfcConstraintEnum(tape[2])
    let ConstraintSource
    if (tape[3]) {
      ConstraintSource = tape[3]
    } else {
      ConstraintSource = null
    }
    let CreatingActor
    if (tape[4]) {
      CreatingActor = ParseType(tape[4], tape[5][0])
    } else {
      CreatingActor = null
    }
    let CreationTime
    if (tape[5]) {
      CreationTime = tape[5]
    } else {
      CreationTime = null
    }
    let UserDefinedGrade
    if (tape[6]) {
      UserDefinedGrade = tape[6]
    } else {
      UserDefinedGrade = null
    }
    return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
  }
  IfcConstraint.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ConstraintGrade.value)
    if (this.ConstraintSource) {
      args.push(STRING)
      args.push(this.ConstraintSource)
    } else {
      args.push(EMPTY)
    }
    if (this.CreatingActor) {
    } else {
      args.push(EMPTY)
    }
    if (this.CreationTime) {
      args.push(STRING)
      args.push(this.CreationTime)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedGrade) {
      args.push(STRING)
      args.push(this.UserDefinedGrade)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstraint
}())
exports.IfcConstraint = IfcConstraint

var IfcConstructionEquipmentResource = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionEquipmentResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcConstructionEquipmentResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionEquipmentResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstructionEquipmentResource
}())
exports.IfcConstructionEquipmentResource = IfcConstructionEquipmentResource

var IfcConstructionEquipmentResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionEquipmentResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcConstructionEquipmentResourceTypeEnum(tape[11])
    return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionEquipmentResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcConstructionEquipmentResourceType
}())
exports.IfcConstructionEquipmentResourceType = IfcConstructionEquipmentResourceType

var IfcConstructionMaterialResource = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionMaterialResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcConstructionMaterialResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionMaterialResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstructionMaterialResource
}())
exports.IfcConstructionMaterialResource = IfcConstructionMaterialResource

var IfcConstructionMaterialResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionMaterialResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcConstructionMaterialResourceTypeEnum(tape[11])
    return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionMaterialResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcConstructionMaterialResourceType
}())
exports.IfcConstructionMaterialResourceType = IfcConstructionMaterialResourceType

var IfcConstructionProductResource = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionProductResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcConstructionProductResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionProductResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstructionProductResource
}())
exports.IfcConstructionProductResource = IfcConstructionProductResource

var IfcConstructionProductResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcConstructionProductResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcConstructionProductResourceTypeEnum(tape[11])
    return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcConstructionProductResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcConstructionProductResourceType
}())
exports.IfcConstructionProductResourceType = IfcConstructionProductResourceType

var IfcConstructionResource = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
  }
  IfcConstructionResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
  }
  IfcConstructionResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstructionResource
}())
exports.IfcConstructionResource = IfcConstructionResource

var IfcConstructionResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
  }
  IfcConstructionResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
  }
  IfcConstructionResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcConstructionResourceType
}())
exports.IfcConstructionResourceType = IfcConstructionResourceType

var IfcContext = /** @class */ (function() {
  /**
   *
   */
  function IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
    this.Phase = Phase
    this.RepresentationContexts = RepresentationContexts
    this.UnitsInContext = UnitsInContext
  }
  IfcContext.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    let Phase
    if (tape[6]) {
      Phase = tape[6]
    } else {
      Phase = null
    }
    let RepresentationContexts
    if (tape[7]) {
      RepresentationContexts = []
      let RepresentationContexts_index = 0
      while (RepresentationContexts_index < tape[7].length) {
        RepresentationContexts.push(tape[7][RepresentationContexts_index++])
      }
    } else {
      RepresentationContexts = null
    }
    let UnitsInContext
    if (tape[8]) {
      UnitsInContext = tape[8]
    } else {
      UnitsInContext = null
    }
    return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
  }
  IfcContext.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.Phase) {
      args.push(STRING)
      args.push(this.Phase)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationContexts) {
      args.push(SET_BEGIN)
      this.RepresentationContexts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.UnitsInContext) {
      args.push(REF)
      args.push(this.UnitsInContext)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcContext
}())
exports.IfcContext = IfcContext

var IfcContextDependentUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name) {
    this.expressID = expressID
    this.type = type
    this.Dimensions = Dimensions
    this.UnitType = UnitType
    this.Name = Name
  }
  IfcContextDependentUnit.FromTape = function(expressID, type, tape) {
    let Dimensions
    Dimensions = tape[0]
    let UnitType
    UnitType = new IfcUnitEnum(tape[1])
    let Name
    Name = tape[2]
    return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name)
  }
  IfcContextDependentUnit.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Dimensions)
    args.push(ENUM)
    args.push(this.UnitType.value)
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcContextDependentUnit
}())
exports.IfcContextDependentUnit = IfcContextDependentUnit

var IfcControl = /** @class */ (function() {
  /**
   *
   */
  function IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
  }
  IfcControl.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
  }
  IfcControl.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcControl
}())
exports.IfcControl = IfcControl

var IfcController = /** @class */ (function() {
  /**
   *
   */
  function IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcController.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcControllerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcController.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcController
}())
exports.IfcController = IfcController

var IfcControllerType = /** @class */ (function() {
  /**
   *
   */
  function IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcControllerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcControllerTypeEnum(tape[9])
    return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcControllerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcControllerType
}())
exports.IfcControllerType = IfcControllerType

var IfcConversionBasedUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
    this.expressID = expressID
    this.type = type
    this.Dimensions = Dimensions
    this.UnitType = UnitType
    this.Name = Name
    this.ConversionFactor = ConversionFactor
  }
  IfcConversionBasedUnit.FromTape = function(expressID, type, tape) {
    let Dimensions
    Dimensions = tape[0]
    let UnitType
    UnitType = new IfcUnitEnum(tape[1])
    let Name
    Name = tape[2]
    let ConversionFactor
    ConversionFactor = tape[3]
    return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor)
  }
  IfcConversionBasedUnit.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Dimensions)
    args.push(ENUM)
    args.push(this.UnitType.value)
    args.push(STRING)
    args.push(this.Name)
    args.push(REF)
    args.push(this.ConversionFactor)
    return args
  }
  return IfcConversionBasedUnit
}())
exports.IfcConversionBasedUnit = IfcConversionBasedUnit

var IfcConversionBasedUnitWithOffset = /** @class */ (function() {
  /**
   *
   */
  function IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
    this.expressID = expressID
    this.type = type
    this.Dimensions = Dimensions
    this.UnitType = UnitType
    this.Name = Name
    this.ConversionFactor = ConversionFactor
    this.ConversionOffset = ConversionOffset
  }
  IfcConversionBasedUnitWithOffset.FromTape = function(expressID, type, tape) {
    let Dimensions
    Dimensions = tape[0]
    let UnitType
    UnitType = new IfcUnitEnum(tape[1])
    let Name
    Name = tape[2]
    let ConversionFactor
    ConversionFactor = tape[3]
    let ConversionOffset
    ConversionOffset = tape[4]
    return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset)
  }
  IfcConversionBasedUnitWithOffset.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Dimensions)
    args.push(ENUM)
    args.push(this.UnitType.value)
    args.push(STRING)
    args.push(this.Name)
    args.push(REF)
    args.push(this.ConversionFactor)
    args.push(REAL)
    args.push(this.ConversionOffset)
    return args
  }
  return IfcConversionBasedUnitWithOffset
}())
exports.IfcConversionBasedUnitWithOffset = IfcConversionBasedUnitWithOffset

var IfcCooledBeam = /** @class */ (function() {
  /**
   *
   */
  function IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCooledBeam.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCooledBeamTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCooledBeam.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCooledBeam
}())
exports.IfcCooledBeam = IfcCooledBeam

var IfcCooledBeamType = /** @class */ (function() {
  /**
   *
   */
  function IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCooledBeamType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCooledBeamTypeEnum(tape[9])
    return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCooledBeamType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCooledBeamType
}())
exports.IfcCooledBeamType = IfcCooledBeamType

var IfcCoolingTower = /** @class */ (function() {
  /**
   *
   */
  function IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCoolingTower.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCoolingTowerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCoolingTower.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCoolingTower
}())
exports.IfcCoolingTower = IfcCoolingTower

var IfcCoolingTowerType = /** @class */ (function() {
  /**
   *
   */
  function IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCoolingTowerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCoolingTowerTypeEnum(tape[9])
    return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCoolingTowerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCoolingTowerType
}())
exports.IfcCoolingTowerType = IfcCoolingTowerType

var IfcCoordinateOperation = /** @class */ (function() {
  /**
   *
   */
  function IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS) {
    this.expressID = expressID
    this.type = type
    this.SourceCRS = SourceCRS
    this.TargetCRS = TargetCRS
  }
  IfcCoordinateOperation.FromTape = function(expressID, type, tape) {
    let SourceCRS
    SourceCRS = ParseType(tape[0], tape[1][0])
    let TargetCRS
    TargetCRS = tape[1]
    return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS)
  }
  IfcCoordinateOperation.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.TargetCRS)
    return args
  }
  return IfcCoordinateOperation
}())
exports.IfcCoordinateOperation = IfcCoordinateOperation

var IfcCoordinateReferenceSystem = /** @class */ (function() {
  /**
   *
   */
  function IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.GeodeticDatum = GeodeticDatum
    this.VerticalDatum = VerticalDatum
  }
  IfcCoordinateReferenceSystem.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let GeodeticDatum
    if (tape[2]) {
      GeodeticDatum = tape[2]
    } else {
      GeodeticDatum = null
    }
    let VerticalDatum
    if (tape[3]) {
      VerticalDatum = tape[3]
    } else {
      VerticalDatum = null
    }
    return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum)
  }
  IfcCoordinateReferenceSystem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.GeodeticDatum) {
      args.push(STRING)
      args.push(this.GeodeticDatum)
    } else {
      args.push(EMPTY)
    }
    if (this.VerticalDatum) {
      args.push(STRING)
      args.push(this.VerticalDatum)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCoordinateReferenceSystem
}())
exports.IfcCoordinateReferenceSystem = IfcCoordinateReferenceSystem

var IfcCostItem = /** @class */ (function() {
  /**
   *
   */
  function IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.PredefinedType = PredefinedType
    this.CostValues = CostValues
    this.CostQuantities = CostQuantities
  }
  IfcCostItem.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcCostItemTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    let CostValues
    if (tape[7]) {
      CostValues = []
      let CostValues_index = 0
      while (CostValues_index < tape[7].length) {
        CostValues.push(tape[7][CostValues_index++])
      }
    } else {
      CostValues = null
    }
    let CostQuantities
    if (tape[8]) {
      CostQuantities = []
      let CostQuantities_index = 0
      while (CostQuantities_index < tape[8].length) {
        CostQuantities.push(tape[8][CostQuantities_index++])
      }
    } else {
      CostQuantities = null
    }
    return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities)
  }
  IfcCostItem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.CostValues) {
      args.push(SET_BEGIN)
      this.CostValues.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.CostQuantities) {
      args.push(SET_BEGIN)
      this.CostQuantities.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCostItem
}())
exports.IfcCostItem = IfcCostItem

var IfcCostSchedule = /** @class */ (function() {
  /**
   *
   */
  function IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.PredefinedType = PredefinedType
    this.Status = Status
    this.SubmittedOn = SubmittedOn
    this.UpdateDate = UpdateDate
  }
  IfcCostSchedule.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcCostScheduleTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    let Status
    if (tape[7]) {
      Status = tape[7]
    } else {
      Status = null
    }
    let SubmittedOn
    if (tape[8]) {
      SubmittedOn = tape[8]
    } else {
      SubmittedOn = null
    }
    let UpdateDate
    if (tape[9]) {
      UpdateDate = tape[9]
    } else {
      UpdateDate = null
    }
    return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate)
  }
  IfcCostSchedule.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.SubmittedOn) {
      args.push(STRING)
      args.push(this.SubmittedOn)
    } else {
      args.push(EMPTY)
    }
    if (this.UpdateDate) {
      args.push(STRING)
      args.push(this.UpdateDate)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCostSchedule
}())
exports.IfcCostSchedule = IfcCostSchedule

var IfcCostValue = /** @class */ (function() {
  /**
   *
   */
  function IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.AppliedValue = AppliedValue
    this.UnitBasis = UnitBasis
    this.ApplicableDate = ApplicableDate
    this.FixedUntilDate = FixedUntilDate
    this.Category = Category
    this.Condition = Condition
    this.ArithmeticOperator = ArithmeticOperator
    this.Components = Components
  }
  IfcCostValue.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let AppliedValue
    if (tape[2]) {
      AppliedValue = ParseType(tape[2], tape[3][0])
    } else {
      AppliedValue = null
    }
    let UnitBasis
    if (tape[3]) {
      UnitBasis = tape[3]
    } else {
      UnitBasis = null
    }
    let ApplicableDate
    if (tape[4]) {
      ApplicableDate = tape[4]
    } else {
      ApplicableDate = null
    }
    let FixedUntilDate
    if (tape[5]) {
      FixedUntilDate = tape[5]
    } else {
      FixedUntilDate = null
    }
    let Category
    if (tape[6]) {
      Category = tape[6]
    } else {
      Category = null
    }
    let Condition
    if (tape[7]) {
      Condition = tape[7]
    } else {
      Condition = null
    }
    let ArithmeticOperator
    if (tape[8]) {
      ArithmeticOperator = new IfcArithmeticOperatorEnum(tape[8])
    } else {
      ArithmeticOperator = null
    }
    let Components
    if (tape[9]) {
      Components = []
      let Components_index = 0
      while (Components_index < tape[9].length) {
        Components.push(tape[9][Components_index++])
      }
    } else {
      Components = null
    }
    return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components)
  }
  IfcCostValue.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedValue) {
    } else {
      args.push(EMPTY)
    }
    if (this.UnitBasis) {
      args.push(REF)
      args.push(this.UnitBasis)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableDate) {
      args.push(STRING)
      args.push(this.ApplicableDate)
    } else {
      args.push(EMPTY)
    }
    if (this.FixedUntilDate) {
      args.push(STRING)
      args.push(this.FixedUntilDate)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    if (this.Condition) {
      args.push(STRING)
      args.push(this.Condition)
    } else {
      args.push(EMPTY)
    }
    if (this.ArithmeticOperator) {
      args.push(ENUM)
      args.push(this.ArithmeticOperator.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Components) {
      args.push(SET_BEGIN)
      this.Components.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCostValue
}())
exports.IfcCostValue = IfcCostValue

var IfcCovering = /** @class */ (function() {
  /**
   *
   */
  function IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCovering.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCoveringTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCovering.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCovering
}())
exports.IfcCovering = IfcCovering

var IfcCoveringType = /** @class */ (function() {
  /**
   *
   */
  function IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCoveringType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCoveringTypeEnum(tape[9])
    return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCoveringType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCoveringType
}())
exports.IfcCoveringType = IfcCoveringType

var IfcCrewResource = /** @class */ (function() {
  /**
   *
   */
  function IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcCrewResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcCrewResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcCrewResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCrewResource
}())
exports.IfcCrewResource = IfcCrewResource

var IfcCrewResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcCrewResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcCrewResourceTypeEnum(tape[11])
    return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcCrewResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCrewResourceType
}())
exports.IfcCrewResourceType = IfcCrewResourceType

var IfcCsgPrimitive3D = /** @class */ (function() {
  /**
   *
   */
  function IfcCsgPrimitive3D(expressID, type, Position) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
  }
  IfcCsgPrimitive3D.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    return new IfcCsgPrimitive3D(expressID, type, Position)
  }
  IfcCsgPrimitive3D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcCsgPrimitive3D
}())
exports.IfcCsgPrimitive3D = IfcCsgPrimitive3D

var IfcCsgSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcCsgSolid(expressID, type, TreeRootExpression) {
    this.expressID = expressID
    this.type = type
    this.TreeRootExpression = TreeRootExpression
  }
  IfcCsgSolid.FromTape = function(expressID, type, tape) {
    let TreeRootExpression
    TreeRootExpression = ParseType(tape[0], tape[1][0])
    return new IfcCsgSolid(expressID, type, TreeRootExpression)
  }
  IfcCsgSolid.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcCsgSolid
}())
exports.IfcCsgSolid = IfcCsgSolid

var IfcCurrencyRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingMonetaryUnit = RelatingMonetaryUnit
    this.RelatedMonetaryUnit = RelatedMonetaryUnit
    this.ExchangeRate = ExchangeRate
    this.RateDateTime = RateDateTime
    this.RateSource = RateSource
  }
  IfcCurrencyRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingMonetaryUnit
    RelatingMonetaryUnit = tape[2]
    let RelatedMonetaryUnit
    RelatedMonetaryUnit = tape[3]
    let ExchangeRate
    ExchangeRate = tape[4]
    let RateDateTime
    if (tape[5]) {
      RateDateTime = tape[5]
    } else {
      RateDateTime = null
    }
    let RateSource
    if (tape[6]) {
      RateSource = tape[6]
    } else {
      RateSource = null
    }
    return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource)
  }
  IfcCurrencyRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingMonetaryUnit)
    args.push(REF)
    args.push(this.RelatedMonetaryUnit)
    if (this.RateDateTime) {
      args.push(STRING)
      args.push(this.RateDateTime)
    } else {
      args.push(EMPTY)
    }
    if (this.RateSource) {
      args.push(REF)
      args.push(this.RateSource)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCurrencyRelationship
}())
exports.IfcCurrencyRelationship = IfcCurrencyRelationship

var IfcCurtainWall = /** @class */ (function() {
  /**
   *
   */
  function IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcCurtainWall.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcCurtainWallTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcCurtainWall.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCurtainWall
}())
exports.IfcCurtainWall = IfcCurtainWall

var IfcCurtainWallType = /** @class */ (function() {
  /**
   *
   */
  function IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcCurtainWallType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcCurtainWallTypeEnum(tape[9])
    return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcCurtainWallType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcCurtainWallType
}())
exports.IfcCurtainWallType = IfcCurtainWallType

var IfcCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcCurve(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcCurve.FromTape = function(expressID, type, tape) {
    return new IfcCurve(expressID, type)
  }
  IfcCurve.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcCurve
}())
exports.IfcCurve = IfcCurve

var IfcCurveBoundedPlane = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID
    this.type = type
    this.BasisSurface = BasisSurface
    this.OuterBoundary = OuterBoundary
    this.InnerBoundaries = InnerBoundaries
  }
  IfcCurveBoundedPlane.FromTape = function(expressID, type, tape) {
    let BasisSurface
    BasisSurface = tape[0]
    let OuterBoundary
    OuterBoundary = tape[1]
    let InnerBoundaries
    InnerBoundaries = []
    let InnerBoundaries_index = 0
    while (InnerBoundaries_index < tape[2].length) {
      InnerBoundaries.push(tape[2][InnerBoundaries_index++])
    }
    return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries)
  }
  IfcCurveBoundedPlane.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisSurface)
    args.push(REF)
    args.push(this.OuterBoundary)
    args.push(SET_BEGIN)
    this.InnerBoundaries.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcCurveBoundedPlane
}())
exports.IfcCurveBoundedPlane = IfcCurveBoundedPlane

var IfcCurveBoundedSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
    this.expressID = expressID
    this.type = type
    this.BasisSurface = BasisSurface
    this.Boundaries = Boundaries
    this.ImplicitOuter = ImplicitOuter
  }
  IfcCurveBoundedSurface.FromTape = function(expressID, type, tape) {
    let BasisSurface
    BasisSurface = tape[0]
    let Boundaries
    Boundaries = []
    let Boundaries_index = 0
    while (Boundaries_index < tape[1].length) {
      Boundaries.push(tape[1][Boundaries_index++])
    }
    let ImplicitOuter
    ImplicitOuter = tape[2]
    return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter)
  }
  IfcCurveBoundedSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisSurface)
    args.push(SET_BEGIN)
    this.Boundaries.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcCurveBoundedSurface
}())
exports.IfcCurveBoundedSurface = IfcCurveBoundedSurface

var IfcCurveSegment2D = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID
    this.type = type
    this.StartPoint = StartPoint
    this.StartDirection = StartDirection
    this.SegmentLength = SegmentLength
  }
  IfcCurveSegment2D.FromTape = function(expressID, type, tape) {
    let StartPoint
    StartPoint = tape[0]
    let StartDirection
    StartDirection = tape[1]
    let SegmentLength
    SegmentLength = tape[2]
    return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength)
  }
  IfcCurveSegment2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.StartPoint)
    args.push(REAL)
    args.push(this.StartDirection)
    return args
  }
  return IfcCurveSegment2D
}())
exports.IfcCurveSegment2D = IfcCurveSegment2D

var IfcCurveStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.CurveFont = CurveFont
    this.CurveWidth = CurveWidth
    this.CurveColour = CurveColour
    this.ModelOrDraughting = ModelOrDraughting
  }
  IfcCurveStyle.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let CurveFont
    if (tape[1]) {
      CurveFont = ParseType(tape[1], tape[2][0])
    } else {
      CurveFont = null
    }
    let CurveWidth
    if (tape[2]) {
      CurveWidth = ParseType(tape[2], tape[3][0])
    } else {
      CurveWidth = null
    }
    let CurveColour
    if (tape[3]) {
      CurveColour = ParseType(tape[3], tape[4][0])
    } else {
      CurveColour = null
    }
    let ModelOrDraughting
    if (tape[4]) {
      ModelOrDraughting = tape[4]
    } else {
      ModelOrDraughting = null
    }
    return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting)
  }
  IfcCurveStyle.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.CurveFont) {
    } else {
      args.push(EMPTY)
    }
    if (this.CurveWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.CurveColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.ModelOrDraughting) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCurveStyle
}())
exports.IfcCurveStyle = IfcCurveStyle

var IfcCurveStyleFont = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveStyleFont(expressID, type, Name, PatternList) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.PatternList = PatternList
  }
  IfcCurveStyleFont.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let PatternList
    PatternList = []
    let PatternList_index = 0
    while (PatternList_index < tape[1].length) {
      PatternList.push(tape[1][PatternList_index++])
    }
    return new IfcCurveStyleFont(expressID, type, Name, PatternList)
  }
  IfcCurveStyleFont.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.PatternList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcCurveStyleFont
}())
exports.IfcCurveStyleFont = IfcCurveStyleFont

var IfcCurveStyleFontAndScaling = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.CurveFont = CurveFont
    this.CurveFontScaling = CurveFontScaling
  }
  IfcCurveStyleFontAndScaling.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let CurveFont
    CurveFont = ParseType(tape[1], tape[2][0])
    let CurveFontScaling
    CurveFontScaling = tape[2]
    return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling)
  }
  IfcCurveStyleFontAndScaling.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcCurveStyleFontAndScaling
}())
exports.IfcCurveStyleFontAndScaling = IfcCurveStyleFontAndScaling

var IfcCurveStyleFontPattern = /** @class */ (function() {
  /**
   *
   */
  function IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
    this.expressID = expressID
    this.type = type
    this.VisibleSegmentLength = VisibleSegmentLength
    this.InvisibleSegmentLength = InvisibleSegmentLength
  }
  IfcCurveStyleFontPattern.FromTape = function(expressID, type, tape) {
    let VisibleSegmentLength
    VisibleSegmentLength = tape[0]
    let InvisibleSegmentLength
    InvisibleSegmentLength = tape[1]
    return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength)
  }
  IfcCurveStyleFontPattern.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.VisibleSegmentLength)
    return args
  }
  return IfcCurveStyleFontPattern
}())
exports.IfcCurveStyleFontPattern = IfcCurveStyleFontPattern

var IfcCylindricalSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcCylindricalSurface(expressID, type, Position, Radius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Radius = Radius
  }
  IfcCylindricalSurface.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let Radius
    Radius = tape[1]
    return new IfcCylindricalSurface(expressID, type, Position, Radius)
  }
  IfcCylindricalSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcCylindricalSurface
}())
exports.IfcCylindricalSurface = IfcCylindricalSurface

var IfcDamper = /** @class */ (function() {
  /**
   *
   */
  function IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDamper.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDamperTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDamper.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDamper
}())
exports.IfcDamper = IfcDamper

var IfcDamperType = /** @class */ (function() {
  /**
   *
   */
  function IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDamperType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDamperTypeEnum(tape[9])
    return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDamperType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDamperType
}())
exports.IfcDamperType = IfcDamperType

var IfcDeepFoundation = /** @class */ (function() {
  /**
   *
   */
  function IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcDeepFoundation.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcDeepFoundation.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDeepFoundation
}())
exports.IfcDeepFoundation = IfcDeepFoundation

var IfcDeepFoundationType = /** @class */ (function() {
  /**
   *
   */
  function IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcDeepFoundationType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcDeepFoundationType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDeepFoundationType
}())
exports.IfcDeepFoundationType = IfcDeepFoundationType

var IfcDerivedProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.ParentProfile = ParentProfile
    this.Operator = Operator
    this.Label = Label
  }
  IfcDerivedProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let ParentProfile
    ParentProfile = tape[2]
    let Operator
    Operator = tape[3]
    let Label
    if (tape[4]) {
      Label = tape[4]
    } else {
      Label = null
    }
    return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label)
  }
  IfcDerivedProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ParentProfile)
    args.push(REF)
    args.push(this.Operator)
    if (this.Label) {
      args.push(STRING)
      args.push(this.Label)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDerivedProfileDef
}())
exports.IfcDerivedProfileDef = IfcDerivedProfileDef

var IfcDerivedUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType) {
    this.expressID = expressID
    this.type = type
    this.Elements = Elements
    this.UnitType = UnitType
    this.UserDefinedType = UserDefinedType
  }
  IfcDerivedUnit.FromTape = function(expressID, type, tape) {
    let Elements
    Elements = []
    let Elements_index = 0
    while (Elements_index < tape[0].length) {
      Elements.push(tape[0][Elements_index++])
    }
    let UnitType
    UnitType = new IfcDerivedUnitEnum(tape[1])
    let UserDefinedType
    if (tape[2]) {
      UserDefinedType = tape[2]
    } else {
      UserDefinedType = null
    }
    return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType)
  }
  IfcDerivedUnit.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Elements.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.UnitType.value)
    if (this.UserDefinedType) {
      args.push(STRING)
      args.push(this.UserDefinedType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDerivedUnit
}())
exports.IfcDerivedUnit = IfcDerivedUnit

var IfcDerivedUnitElement = /** @class */ (function() {
  /**
   *
   */
  function IfcDerivedUnitElement(expressID, type, Unit, Exponent) {
    this.expressID = expressID
    this.type = type
    this.Unit = Unit
    this.Exponent = Exponent
  }
  IfcDerivedUnitElement.FromTape = function(expressID, type, tape) {
    let Unit
    Unit = tape[0]
    let Exponent
    Exponent = tape[1]
    return new IfcDerivedUnitElement(expressID, type, Unit, Exponent)
  }
  IfcDerivedUnitElement.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Unit)
    args.push(REF)
    args.push(this.Exponent)
    return args
  }
  return IfcDerivedUnitElement
}())
exports.IfcDerivedUnitElement = IfcDerivedUnitElement

var IfcDimensionalExponents = /** @class */ (function() {
  /**
   *
   */
  function IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
    this.expressID = expressID
    this.type = type
    this.LengthExponent = LengthExponent
    this.MassExponent = MassExponent
    this.TimeExponent = TimeExponent
    this.ElectricCurrentExponent = ElectricCurrentExponent
    this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent
    this.AmountOfSubstanceExponent = AmountOfSubstanceExponent
    this.LuminousIntensityExponent = LuminousIntensityExponent
  }
  IfcDimensionalExponents.FromTape = function(expressID, type, tape) {
    let LengthExponent
    LengthExponent = tape[0]
    let MassExponent
    MassExponent = tape[1]
    let TimeExponent
    TimeExponent = tape[2]
    let ElectricCurrentExponent
    ElectricCurrentExponent = tape[3]
    let ThermodynamicTemperatureExponent
    ThermodynamicTemperatureExponent = tape[4]
    let AmountOfSubstanceExponent
    AmountOfSubstanceExponent = tape[5]
    let LuminousIntensityExponent
    LuminousIntensityExponent = tape[6]
    return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent)
  }
  IfcDimensionalExponents.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.LengthExponent)
    args.push(REF)
    args.push(this.MassExponent)
    args.push(REF)
    args.push(this.TimeExponent)
    args.push(REF)
    args.push(this.ElectricCurrentExponent)
    args.push(REF)
    args.push(this.ThermodynamicTemperatureExponent)
    args.push(REF)
    args.push(this.AmountOfSubstanceExponent)
    args.push(REF)
    args.push(this.LuminousIntensityExponent)
    return args
  }
  return IfcDimensionalExponents
}())
exports.IfcDimensionalExponents = IfcDimensionalExponents

var IfcDirection = /** @class */ (function() {
  /**
   *
   */
  function IfcDirection(expressID, type, DirectionRatios) {
    this.expressID = expressID
    this.type = type
    this.DirectionRatios = DirectionRatios
  }
  IfcDirection.FromTape = function(expressID, type, tape) {
    let DirectionRatios
    DirectionRatios = []
    let DirectionRatios_index = 0
    while (DirectionRatios_index < tape[0].length) {
      DirectionRatios.push(tape[0][DirectionRatios_index++])
    }
    return new IfcDirection(expressID, type, DirectionRatios)
  }
  IfcDirection.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.DirectionRatios)
    return args
  }
  return IfcDirection
}())
exports.IfcDirection = IfcDirection

var IfcDiscreteAccessory = /** @class */ (function() {
  /**
   *
   */
  function IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDiscreteAccessory.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDiscreteAccessoryTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDiscreteAccessory.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDiscreteAccessory
}())
exports.IfcDiscreteAccessory = IfcDiscreteAccessory

var IfcDiscreteAccessoryType = /** @class */ (function() {
  /**
   *
   */
  function IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDiscreteAccessoryType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDiscreteAccessoryTypeEnum(tape[9])
    return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDiscreteAccessoryType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDiscreteAccessoryType
}())
exports.IfcDiscreteAccessoryType = IfcDiscreteAccessoryType

var IfcDistanceExpression = /** @class */ (function() {
  /**
   *
   */
  function IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
    this.expressID = expressID
    this.type = type
    this.DistanceAlong = DistanceAlong
    this.OffsetLateral = OffsetLateral
    this.OffsetVertical = OffsetVertical
    this.OffsetLongitudinal = OffsetLongitudinal
    this.AlongHorizontal = AlongHorizontal
  }
  IfcDistanceExpression.FromTape = function(expressID, type, tape) {
    let DistanceAlong
    DistanceAlong = tape[0]
    let OffsetLateral
    if (tape[1]) {
      OffsetLateral = tape[1]
    } else {
      OffsetLateral = null
    }
    let OffsetVertical
    if (tape[2]) {
      OffsetVertical = tape[2]
    } else {
      OffsetVertical = null
    }
    let OffsetLongitudinal
    if (tape[3]) {
      OffsetLongitudinal = tape[3]
    } else {
      OffsetLongitudinal = null
    }
    let AlongHorizontal
    if (tape[4]) {
      AlongHorizontal = tape[4]
    } else {
      AlongHorizontal = null
    }
    return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal)
  }
  IfcDistanceExpression.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.DistanceAlong)
    if (this.OffsetLateral) {
      args.push(REAL)
      args.push(this.OffsetLateral)
    } else {
      args.push(EMPTY)
    }
    if (this.OffsetVertical) {
      args.push(REAL)
      args.push(this.OffsetVertical)
    } else {
      args.push(EMPTY)
    }
    if (this.OffsetLongitudinal) {
      args.push(REAL)
      args.push(this.OffsetLongitudinal)
    } else {
      args.push(EMPTY)
    }
    if (this.AlongHorizontal) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistanceExpression
}())
exports.IfcDistanceExpression = IfcDistanceExpression

var IfcDistributionChamberElement = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDistributionChamberElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDistributionChamberElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDistributionChamberElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionChamberElement
}())
exports.IfcDistributionChamberElement = IfcDistributionChamberElement

var IfcDistributionChamberElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDistributionChamberElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDistributionChamberElementTypeEnum(tape[9])
    return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDistributionChamberElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDistributionChamberElementType
}())
exports.IfcDistributionChamberElementType = IfcDistributionChamberElementType

var IfcDistributionCircuit = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
    this.PredefinedType = PredefinedType
  }
  IfcDistributionCircuit.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcDistributionSystemEnum(tape[6])
    } else {
      PredefinedType = null
    }
    return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType)
  }
  IfcDistributionCircuit.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionCircuit
}())
exports.IfcDistributionCircuit = IfcDistributionCircuit

var IfcDistributionControlElement = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcDistributionControlElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcDistributionControlElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionControlElement
}())
exports.IfcDistributionControlElement = IfcDistributionControlElement

var IfcDistributionControlElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcDistributionControlElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcDistributionControlElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionControlElementType
}())
exports.IfcDistributionControlElementType = IfcDistributionControlElementType

var IfcDistributionElement = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcDistributionElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcDistributionElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionElement
}())
exports.IfcDistributionElement = IfcDistributionElement

var IfcDistributionElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcDistributionElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcDistributionElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionElementType
}())
exports.IfcDistributionElementType = IfcDistributionElementType

var IfcDistributionFlowElement = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcDistributionFlowElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcDistributionFlowElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionFlowElement
}())
exports.IfcDistributionFlowElement = IfcDistributionFlowElement

var IfcDistributionFlowElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcDistributionFlowElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcDistributionFlowElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionFlowElementType
}())
exports.IfcDistributionFlowElementType = IfcDistributionFlowElementType

var IfcDistributionPort = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.FlowDirection = FlowDirection
    this.PredefinedType = PredefinedType
    this.SystemType = SystemType
  }
  IfcDistributionPort.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let FlowDirection
    if (tape[7]) {
      FlowDirection = new IfcFlowDirectionEnum(tape[7])
    } else {
      FlowDirection = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDistributionPortTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    let SystemType
    if (tape[9]) {
      SystemType = new IfcDistributionSystemEnum(tape[9])
    } else {
      SystemType = null
    }
    return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType)
  }
  IfcDistributionPort.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.FlowDirection) {
      args.push(ENUM)
      args.push(this.FlowDirection.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.SystemType) {
      args.push(ENUM)
      args.push(this.SystemType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionPort
}())
exports.IfcDistributionPort = IfcDistributionPort

var IfcDistributionSystem = /** @class */ (function() {
  /**
   *
   */
  function IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
    this.PredefinedType = PredefinedType
  }
  IfcDistributionSystem.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcDistributionSystemEnum(tape[6])
    } else {
      PredefinedType = null
    }
    return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType)
  }
  IfcDistributionSystem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDistributionSystem
}())
exports.IfcDistributionSystem = IfcDistributionSystem

var IfcDocumentInformation = /** @class */ (function() {
  /**
   *
   */
  function IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
    this.expressID = expressID
    this.type = type
    this.Identification = Identification
    this.Name = Name
    this.Description = Description
    this.Location = Location
    this.Purpose = Purpose
    this.IntendedUse = IntendedUse
    this.Scope = Scope
    this.Revision = Revision
    this.DocumentOwner = DocumentOwner
    this.Editors = Editors
    this.CreationTime = CreationTime
    this.LastRevisionTime = LastRevisionTime
    this.ElectronicFormat = ElectronicFormat
    this.ValidFrom = ValidFrom
    this.ValidUntil = ValidUntil
    this.Confidentiality = Confidentiality
    this.Status = Status
  }
  IfcDocumentInformation.FromTape = function(expressID, type, tape) {
    let Identification
    Identification = tape[0]
    let Name
    Name = tape[1]
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    let Location
    if (tape[3]) {
      Location = tape[3]
    } else {
      Location = null
    }
    let Purpose
    if (tape[4]) {
      Purpose = tape[4]
    } else {
      Purpose = null
    }
    let IntendedUse
    if (tape[5]) {
      IntendedUse = tape[5]
    } else {
      IntendedUse = null
    }
    let Scope
    if (tape[6]) {
      Scope = tape[6]
    } else {
      Scope = null
    }
    let Revision
    if (tape[7]) {
      Revision = tape[7]
    } else {
      Revision = null
    }
    let DocumentOwner
    if (tape[8]) {
      DocumentOwner = ParseType(tape[8], tape[9][0])
    } else {
      DocumentOwner = null
    }
    let Editors
    if (tape[9]) {
      Editors = []
      let Editors_index = 0
      while (Editors_index < tape[9].length) {
        Editors.push(ParseType(tape[9][Editors_index++], tape[9][Editors_index++][0]))
      }
    } else {
      Editors = null
    }
    let CreationTime
    if (tape[10]) {
      CreationTime = tape[10]
    } else {
      CreationTime = null
    }
    let LastRevisionTime
    if (tape[11]) {
      LastRevisionTime = tape[11]
    } else {
      LastRevisionTime = null
    }
    let ElectronicFormat
    if (tape[12]) {
      ElectronicFormat = tape[12]
    } else {
      ElectronicFormat = null
    }
    let ValidFrom
    if (tape[13]) {
      ValidFrom = tape[13]
    } else {
      ValidFrom = null
    }
    let ValidUntil
    if (tape[14]) {
      ValidUntil = tape[14]
    } else {
      ValidUntil = null
    }
    let Confidentiality
    if (tape[15]) {
      Confidentiality = new IfcDocumentConfidentialityEnum(tape[15])
    } else {
      Confidentiality = null
    }
    let Status
    if (tape[16]) {
      Status = new IfcDocumentStatusEnum(tape[16])
    } else {
      Status = null
    }
    return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status)
  }
  IfcDocumentInformation.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Identification)
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    if (this.IntendedUse) {
      args.push(STRING)
      args.push(this.IntendedUse)
    } else {
      args.push(EMPTY)
    }
    if (this.Scope) {
      args.push(STRING)
      args.push(this.Scope)
    } else {
      args.push(EMPTY)
    }
    if (this.Revision) {
      args.push(STRING)
      args.push(this.Revision)
    } else {
      args.push(EMPTY)
    }
    if (this.DocumentOwner) {
    } else {
      args.push(EMPTY)
    }
    if (this.Editors) {
    } else {
      args.push(EMPTY)
    }
    if (this.CreationTime) {
      args.push(STRING)
      args.push(this.CreationTime)
    } else {
      args.push(EMPTY)
    }
    if (this.LastRevisionTime) {
      args.push(STRING)
      args.push(this.LastRevisionTime)
    } else {
      args.push(EMPTY)
    }
    if (this.ElectronicFormat) {
      args.push(STRING)
      args.push(this.ElectronicFormat)
    } else {
      args.push(EMPTY)
    }
    if (this.ValidFrom) {
      args.push(STRING)
      args.push(this.ValidFrom)
    } else {
      args.push(EMPTY)
    }
    if (this.ValidUntil) {
      args.push(STRING)
      args.push(this.ValidUntil)
    } else {
      args.push(EMPTY)
    }
    if (this.Confidentiality) {
      args.push(ENUM)
      args.push(this.Confidentiality.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(ENUM)
      args.push(this.Status.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDocumentInformation
}())
exports.IfcDocumentInformation = IfcDocumentInformation

var IfcDocumentInformationRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingDocument = RelatingDocument
    this.RelatedDocuments = RelatedDocuments
    this.RelationshipType = RelationshipType
  }
  IfcDocumentInformationRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingDocument
    RelatingDocument = tape[2]
    let RelatedDocuments
    RelatedDocuments = []
    let RelatedDocuments_index = 0
    while (RelatedDocuments_index < tape[3].length) {
      RelatedDocuments.push(tape[3][RelatedDocuments_index++])
    }
    let RelationshipType
    if (tape[4]) {
      RelationshipType = tape[4]
    } else {
      RelationshipType = null
    }
    return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType)
  }
  IfcDocumentInformationRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingDocument)
    args.push(SET_BEGIN)
    this.RelatedDocuments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelationshipType) {
      args.push(STRING)
      args.push(this.RelationshipType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDocumentInformationRelationship
}())
exports.IfcDocumentInformationRelationship = IfcDocumentInformationRelationship

var IfcDocumentReference = /** @class */ (function() {
  /**
   *
   */
  function IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
    this.Description = Description
    this.ReferencedDocument = ReferencedDocument
  }
  IfcDocumentReference.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ReferencedDocument
    if (tape[4]) {
      ReferencedDocument = tape[4]
    } else {
      ReferencedDocument = null
    }
    return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument)
  }
  IfcDocumentReference.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ReferencedDocument) {
      args.push(REF)
      args.push(this.ReferencedDocument)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDocumentReference
}())
exports.IfcDocumentReference = IfcDocumentReference

var IfcDoor = /** @class */ (function() {
  /**
   *
   */
  function IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.OverallHeight = OverallHeight
    this.OverallWidth = OverallWidth
    this.PredefinedType = PredefinedType
    this.OperationType = OperationType
    this.UserDefinedOperationType = UserDefinedOperationType
  }
  IfcDoor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let OverallHeight
    if (tape[8]) {
      OverallHeight = tape[8]
    } else {
      OverallHeight = null
    }
    let OverallWidth
    if (tape[9]) {
      OverallWidth = tape[9]
    } else {
      OverallWidth = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcDoorTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    let OperationType
    if (tape[11]) {
      OperationType = new IfcDoorTypeOperationEnum(tape[11])
    } else {
      OperationType = null
    }
    let UserDefinedOperationType
    if (tape[12]) {
      UserDefinedOperationType = tape[12]
    } else {
      UserDefinedOperationType = null
    }
    return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType)
  }
  IfcDoor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.OverallHeight) {
    } else {
      args.push(EMPTY)
    }
    if (this.OverallWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.OperationType) {
      args.push(ENUM)
      args.push(this.OperationType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedOperationType) {
      args.push(STRING)
      args.push(this.UserDefinedOperationType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDoor
}())
exports.IfcDoor = IfcDoor

var IfcDoorLiningProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.LiningDepth = LiningDepth
    this.LiningThickness = LiningThickness
    this.ThresholdDepth = ThresholdDepth
    this.ThresholdThickness = ThresholdThickness
    this.TransomThickness = TransomThickness
    this.TransomOffset = TransomOffset
    this.LiningOffset = LiningOffset
    this.ThresholdOffset = ThresholdOffset
    this.CasingThickness = CasingThickness
    this.CasingDepth = CasingDepth
    this.ShapeAspectStyle = ShapeAspectStyle
    this.LiningToPanelOffsetX = LiningToPanelOffsetX
    this.LiningToPanelOffsetY = LiningToPanelOffsetY
  }
  IfcDoorLiningProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let LiningDepth
    if (tape[4]) {
      LiningDepth = tape[4]
    } else {
      LiningDepth = null
    }
    let LiningThickness
    if (tape[5]) {
      LiningThickness = tape[5]
    } else {
      LiningThickness = null
    }
    let ThresholdDepth
    if (tape[6]) {
      ThresholdDepth = tape[6]
    } else {
      ThresholdDepth = null
    }
    let ThresholdThickness
    if (tape[7]) {
      ThresholdThickness = tape[7]
    } else {
      ThresholdThickness = null
    }
    let TransomThickness
    if (tape[8]) {
      TransomThickness = tape[8]
    } else {
      TransomThickness = null
    }
    let TransomOffset
    if (tape[9]) {
      TransomOffset = tape[9]
    } else {
      TransomOffset = null
    }
    let LiningOffset
    if (tape[10]) {
      LiningOffset = tape[10]
    } else {
      LiningOffset = null
    }
    let ThresholdOffset
    if (tape[11]) {
      ThresholdOffset = tape[11]
    } else {
      ThresholdOffset = null
    }
    let CasingThickness
    if (tape[12]) {
      CasingThickness = tape[12]
    } else {
      CasingThickness = null
    }
    let CasingDepth
    if (tape[13]) {
      CasingDepth = tape[13]
    } else {
      CasingDepth = null
    }
    let ShapeAspectStyle
    if (tape[14]) {
      ShapeAspectStyle = tape[14]
    } else {
      ShapeAspectStyle = null
    }
    let LiningToPanelOffsetX
    if (tape[15]) {
      LiningToPanelOffsetX = tape[15]
    } else {
      LiningToPanelOffsetX = null
    }
    let LiningToPanelOffsetY
    if (tape[16]) {
      LiningToPanelOffsetY = tape[16]
    } else {
      LiningToPanelOffsetY = null
    }
    return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY)
  }
  IfcDoorLiningProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.LiningThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.ThresholdDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.ThresholdThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransomThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransomOffset) {
      args.push(REAL)
      args.push(this.TransomOffset)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningOffset) {
      args.push(REAL)
      args.push(this.LiningOffset)
    } else {
      args.push(EMPTY)
    }
    if (this.ThresholdOffset) {
      args.push(REAL)
      args.push(this.ThresholdOffset)
    } else {
      args.push(EMPTY)
    }
    if (this.CasingThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.CasingDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.ShapeAspectStyle) {
      args.push(REF)
      args.push(this.ShapeAspectStyle)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningToPanelOffsetX) {
      args.push(REAL)
      args.push(this.LiningToPanelOffsetX)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningToPanelOffsetY) {
      args.push(REAL)
      args.push(this.LiningToPanelOffsetY)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDoorLiningProperties
}())
exports.IfcDoorLiningProperties = IfcDoorLiningProperties

var IfcDoorPanelProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.PanelDepth = PanelDepth
    this.PanelOperation = PanelOperation
    this.PanelWidth = PanelWidth
    this.PanelPosition = PanelPosition
    this.ShapeAspectStyle = ShapeAspectStyle
  }
  IfcDoorPanelProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let PanelDepth
    if (tape[4]) {
      PanelDepth = tape[4]
    } else {
      PanelDepth = null
    }
    let PanelOperation
    PanelOperation = new IfcDoorPanelOperationEnum(tape[5])
    let PanelWidth
    if (tape[6]) {
      PanelWidth = tape[6]
    } else {
      PanelWidth = null
    }
    let PanelPosition
    PanelPosition = new IfcDoorPanelPositionEnum(tape[7])
    let ShapeAspectStyle
    if (tape[8]) {
      ShapeAspectStyle = tape[8]
    } else {
      ShapeAspectStyle = null
    }
    return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle)
  }
  IfcDoorPanelProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.PanelDepth) {
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PanelOperation.value)
    if (this.PanelWidth) {
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PanelPosition.value)
    if (this.ShapeAspectStyle) {
      args.push(REF)
      args.push(this.ShapeAspectStyle)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDoorPanelProperties
}())
exports.IfcDoorPanelProperties = IfcDoorPanelProperties

var IfcDoorStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.OverallHeight = OverallHeight
    this.OverallWidth = OverallWidth
    this.PredefinedType = PredefinedType
    this.OperationType = OperationType
    this.UserDefinedOperationType = UserDefinedOperationType
  }
  IfcDoorStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let OverallHeight
    if (tape[8]) {
      OverallHeight = tape[8]
    } else {
      OverallHeight = null
    }
    let OverallWidth
    if (tape[9]) {
      OverallWidth = tape[9]
    } else {
      OverallWidth = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcDoorTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    let OperationType
    if (tape[11]) {
      OperationType = new IfcDoorTypeOperationEnum(tape[11])
    } else {
      OperationType = null
    }
    let UserDefinedOperationType
    if (tape[12]) {
      UserDefinedOperationType = tape[12]
    } else {
      UserDefinedOperationType = null
    }
    return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType)
  }
  IfcDoorStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.OverallHeight) {
    } else {
      args.push(EMPTY)
    }
    if (this.OverallWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.OperationType) {
      args.push(ENUM)
      args.push(this.OperationType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedOperationType) {
      args.push(STRING)
      args.push(this.UserDefinedOperationType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDoorStandardCase
}())
exports.IfcDoorStandardCase = IfcDoorStandardCase

var IfcDoorStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.OperationType = OperationType
    this.ConstructionType = ConstructionType
    this.ParameterTakesPrecedence = ParameterTakesPrecedence
    this.Sizeable = Sizeable
  }
  IfcDoorStyle.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let OperationType
    OperationType = new IfcDoorStyleOperationEnum(tape[8])
    let ConstructionType
    ConstructionType = new IfcDoorStyleConstructionEnum(tape[9])
    let ParameterTakesPrecedence
    ParameterTakesPrecedence = tape[10]
    let Sizeable
    Sizeable = tape[11]
    return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable)
  }
  IfcDoorStyle.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.OperationType.value)
    args.push(ENUM)
    args.push(this.ConstructionType.value)
    return args
  }
  return IfcDoorStyle
}())
exports.IfcDoorStyle = IfcDoorStyle

var IfcDoorType = /** @class */ (function() {
  /**
   *
   */
  function IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.OperationType = OperationType
    this.ParameterTakesPrecedence = ParameterTakesPrecedence
    this.UserDefinedOperationType = UserDefinedOperationType
  }
  IfcDoorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDoorTypeEnum(tape[9])
    let OperationType
    OperationType = new IfcDoorTypeOperationEnum(tape[10])
    let ParameterTakesPrecedence
    if (tape[11]) {
      ParameterTakesPrecedence = tape[11]
    } else {
      ParameterTakesPrecedence = null
    }
    let UserDefinedOperationType
    if (tape[12]) {
      UserDefinedOperationType = tape[12]
    } else {
      UserDefinedOperationType = null
    }
    return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType)
  }
  IfcDoorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(ENUM)
    args.push(this.OperationType.value)
    if (this.ParameterTakesPrecedence) {
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedOperationType) {
      args.push(STRING)
      args.push(this.UserDefinedOperationType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDoorType
}())
exports.IfcDoorType = IfcDoorType

var IfcDraughtingPreDefinedColour = /** @class */ (function() {
  /**
   *
   */
  function IfcDraughtingPreDefinedColour(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcDraughtingPreDefinedColour.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcDraughtingPreDefinedColour(expressID, type, Name)
  }
  IfcDraughtingPreDefinedColour.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcDraughtingPreDefinedColour
}())
exports.IfcDraughtingPreDefinedColour = IfcDraughtingPreDefinedColour

var IfcDraughtingPreDefinedCurveFont = /** @class */ (function() {
  /**
   *
   */
  function IfcDraughtingPreDefinedCurveFont(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcDraughtingPreDefinedCurveFont.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name)
  }
  IfcDraughtingPreDefinedCurveFont.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcDraughtingPreDefinedCurveFont
}())
exports.IfcDraughtingPreDefinedCurveFont = IfcDraughtingPreDefinedCurveFont

var IfcDuctFitting = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDuctFitting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDuctFittingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDuctFitting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDuctFitting
}())
exports.IfcDuctFitting = IfcDuctFitting

var IfcDuctFittingType = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDuctFittingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDuctFittingTypeEnum(tape[9])
    return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDuctFittingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDuctFittingType
}())
exports.IfcDuctFittingType = IfcDuctFittingType

var IfcDuctSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDuctSegment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDuctSegmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDuctSegment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDuctSegment
}())
exports.IfcDuctSegment = IfcDuctSegment

var IfcDuctSegmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDuctSegmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDuctSegmentTypeEnum(tape[9])
    return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDuctSegmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDuctSegmentType
}())
exports.IfcDuctSegmentType = IfcDuctSegmentType

var IfcDuctSilencer = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcDuctSilencer.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcDuctSilencerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcDuctSilencer.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcDuctSilencer
}())
exports.IfcDuctSilencer = IfcDuctSilencer

var IfcDuctSilencerType = /** @class */ (function() {
  /**
   *
   */
  function IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcDuctSilencerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcDuctSilencerTypeEnum(tape[9])
    return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcDuctSilencerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcDuctSilencerType
}())
exports.IfcDuctSilencerType = IfcDuctSilencerType

var IfcEdge = /** @class */ (function() {
  /**
   *
   */
  function IfcEdge(expressID, type, EdgeStart, EdgeEnd) {
    this.expressID = expressID
    this.type = type
    this.EdgeStart = EdgeStart
    this.EdgeEnd = EdgeEnd
  }
  IfcEdge.FromTape = function(expressID, type, tape) {
    let EdgeStart
    EdgeStart = tape[0]
    let EdgeEnd
    EdgeEnd = tape[1]
    return new IfcEdge(expressID, type, EdgeStart, EdgeEnd)
  }
  IfcEdge.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.EdgeStart)
    args.push(REF)
    args.push(this.EdgeEnd)
    return args
  }
  return IfcEdge
}())
exports.IfcEdge = IfcEdge

var IfcEdgeCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
    this.expressID = expressID
    this.type = type
    this.EdgeStart = EdgeStart
    this.EdgeEnd = EdgeEnd
    this.EdgeGeometry = EdgeGeometry
    this.SameSense = SameSense
  }
  IfcEdgeCurve.FromTape = function(expressID, type, tape) {
    let EdgeStart
    EdgeStart = tape[0]
    let EdgeEnd
    EdgeEnd = tape[1]
    let EdgeGeometry
    EdgeGeometry = tape[2]
    let SameSense
    SameSense = tape[3]
    return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense)
  }
  IfcEdgeCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.EdgeStart)
    args.push(REF)
    args.push(this.EdgeEnd)
    args.push(REF)
    args.push(this.EdgeGeometry)
    return args
  }
  return IfcEdgeCurve
}())
exports.IfcEdgeCurve = IfcEdgeCurve

var IfcEdgeLoop = /** @class */ (function() {
  /**
   *
   */
  function IfcEdgeLoop(expressID, type, EdgeList) {
    this.expressID = expressID
    this.type = type
    this.EdgeList = EdgeList
  }
  IfcEdgeLoop.FromTape = function(expressID, type, tape) {
    let EdgeList
    EdgeList = []
    let EdgeList_index = 0
    while (EdgeList_index < tape[0].length) {
      EdgeList.push(tape[0][EdgeList_index++])
    }
    return new IfcEdgeLoop(expressID, type, EdgeList)
  }
  IfcEdgeLoop.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.EdgeList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcEdgeLoop
}())
exports.IfcEdgeLoop = IfcEdgeLoop

var IfcElectricAppliance = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricAppliance.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricApplianceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricAppliance.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricAppliance
}())
exports.IfcElectricAppliance = IfcElectricAppliance

var IfcElectricApplianceType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricApplianceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricApplianceTypeEnum(tape[9])
    return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricApplianceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricApplianceType
}())
exports.IfcElectricApplianceType = IfcElectricApplianceType

var IfcElectricDistributionBoard = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricDistributionBoard.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricDistributionBoardTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricDistributionBoard.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricDistributionBoard
}())
exports.IfcElectricDistributionBoard = IfcElectricDistributionBoard

var IfcElectricDistributionBoardType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricDistributionBoardType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricDistributionBoardTypeEnum(tape[9])
    return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricDistributionBoardType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricDistributionBoardType
}())
exports.IfcElectricDistributionBoardType = IfcElectricDistributionBoardType

var IfcElectricFlowStorageDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricFlowStorageDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricFlowStorageDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricFlowStorageDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricFlowStorageDevice
}())
exports.IfcElectricFlowStorageDevice = IfcElectricFlowStorageDevice

var IfcElectricFlowStorageDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricFlowStorageDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricFlowStorageDeviceTypeEnum(tape[9])
    return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricFlowStorageDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricFlowStorageDeviceType
}())
exports.IfcElectricFlowStorageDeviceType = IfcElectricFlowStorageDeviceType

var IfcElectricGenerator = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricGenerator.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricGeneratorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricGenerator.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricGenerator
}())
exports.IfcElectricGenerator = IfcElectricGenerator

var IfcElectricGeneratorType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricGeneratorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricGeneratorTypeEnum(tape[9])
    return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricGeneratorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricGeneratorType
}())
exports.IfcElectricGeneratorType = IfcElectricGeneratorType

var IfcElectricMotor = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricMotor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricMotorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricMotor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricMotor
}())
exports.IfcElectricMotor = IfcElectricMotor

var IfcElectricMotorType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricMotorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricMotorTypeEnum(tape[9])
    return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricMotorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricMotorType
}())
exports.IfcElectricMotorType = IfcElectricMotorType

var IfcElectricTimeControl = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcElectricTimeControl.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcElectricTimeControlTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcElectricTimeControl.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElectricTimeControl
}())
exports.IfcElectricTimeControl = IfcElectricTimeControl

var IfcElectricTimeControlType = /** @class */ (function() {
  /**
   *
   */
  function IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElectricTimeControlType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElectricTimeControlTypeEnum(tape[9])
    return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElectricTimeControlType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElectricTimeControlType
}())
exports.IfcElectricTimeControlType = IfcElectricTimeControlType

var IfcElement = /** @class */ (function() {
  /**
   *
   */
  function IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElement
}())
exports.IfcElement = IfcElement

var IfcElementAssembly = /** @class */ (function() {
  /**
   *
   */
  function IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.AssemblyPlace = AssemblyPlace
    this.PredefinedType = PredefinedType
  }
  IfcElementAssembly.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let AssemblyPlace
    if (tape[8]) {
      AssemblyPlace = new IfcAssemblyPlaceEnum(tape[8])
    } else {
      AssemblyPlace = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcElementAssemblyTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType)
  }
  IfcElementAssembly.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.AssemblyPlace) {
      args.push(ENUM)
      args.push(this.AssemblyPlace.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElementAssembly
}())
exports.IfcElementAssembly = IfcElementAssembly

var IfcElementAssemblyType = /** @class */ (function() {
  /**
   *
   */
  function IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcElementAssemblyType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcElementAssemblyTypeEnum(tape[9])
    return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcElementAssemblyType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcElementAssemblyType
}())
exports.IfcElementAssemblyType = IfcElementAssemblyType

var IfcElementComponent = /** @class */ (function() {
  /**
   *
   */
  function IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcElementComponent.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcElementComponent.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElementComponent
}())
exports.IfcElementComponent = IfcElementComponent

var IfcElementComponentType = /** @class */ (function() {
  /**
   *
   */
  function IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcElementComponentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcElementComponentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElementComponentType
}())
exports.IfcElementComponentType = IfcElementComponentType

var IfcElementQuantity = /** @class */ (function() {
  /**
   *
   */
  function IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.MethodOfMeasurement = MethodOfMeasurement
    this.Quantities = Quantities
  }
  IfcElementQuantity.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let MethodOfMeasurement
    if (tape[4]) {
      MethodOfMeasurement = tape[4]
    } else {
      MethodOfMeasurement = null
    }
    let Quantities
    Quantities = []
    let Quantities_index = 0
    while (Quantities_index < tape[5].length) {
      Quantities.push(tape[5][Quantities_index++])
    }
    return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities)
  }
  IfcElementQuantity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.MethodOfMeasurement) {
      args.push(STRING)
      args.push(this.MethodOfMeasurement)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Quantities.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcElementQuantity
}())
exports.IfcElementQuantity = IfcElementQuantity

var IfcElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcElementType
}())
exports.IfcElementType = IfcElementType

var IfcElementarySurface = /** @class */ (function() {
  /**
   *
   */
  function IfcElementarySurface(expressID, type, Position) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
  }
  IfcElementarySurface.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    return new IfcElementarySurface(expressID, type, Position)
  }
  IfcElementarySurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcElementarySurface
}())
exports.IfcElementarySurface = IfcElementarySurface

var IfcEllipse = /** @class */ (function() {
  /**
   *
   */
  function IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.SemiAxis1 = SemiAxis1
    this.SemiAxis2 = SemiAxis2
  }
  IfcEllipse.FromTape = function(expressID, type, tape) {
    let Position
    Position = ParseType(tape[0], tape[1][0])
    let SemiAxis1
    SemiAxis1 = tape[1]
    let SemiAxis2
    SemiAxis2 = tape[2]
    return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2)
  }
  IfcEllipse.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcEllipse
}())
exports.IfcEllipse = IfcEllipse

var IfcEllipseProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.SemiAxis1 = SemiAxis1
    this.SemiAxis2 = SemiAxis2
  }
  IfcEllipseProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let SemiAxis1
    SemiAxis1 = tape[3]
    let SemiAxis2
    SemiAxis2 = tape[4]
    return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2)
  }
  IfcEllipseProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEllipseProfileDef
}())
exports.IfcEllipseProfileDef = IfcEllipseProfileDef

var IfcEnergyConversionDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcEnergyConversionDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcEnergyConversionDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEnergyConversionDevice
}())
exports.IfcEnergyConversionDevice = IfcEnergyConversionDevice

var IfcEnergyConversionDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcEnergyConversionDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcEnergyConversionDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEnergyConversionDeviceType
}())
exports.IfcEnergyConversionDeviceType = IfcEnergyConversionDeviceType

var IfcEngine = /** @class */ (function() {
  /**
   *
   */
  function IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcEngine.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcEngineTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcEngine.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEngine
}())
exports.IfcEngine = IfcEngine

var IfcEngineType = /** @class */ (function() {
  /**
   *
   */
  function IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcEngineType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcEngineTypeEnum(tape[9])
    return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcEngineType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcEngineType
}())
exports.IfcEngineType = IfcEngineType

var IfcEvaporativeCooler = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcEvaporativeCooler.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcEvaporativeCoolerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcEvaporativeCooler.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEvaporativeCooler
}())
exports.IfcEvaporativeCooler = IfcEvaporativeCooler

var IfcEvaporativeCoolerType = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcEvaporativeCoolerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcEvaporativeCoolerTypeEnum(tape[9])
    return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcEvaporativeCoolerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcEvaporativeCoolerType
}())
exports.IfcEvaporativeCoolerType = IfcEvaporativeCoolerType

var IfcEvaporator = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcEvaporator.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcEvaporatorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcEvaporator.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEvaporator
}())
exports.IfcEvaporator = IfcEvaporator

var IfcEvaporatorType = /** @class */ (function() {
  /**
   *
   */
  function IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcEvaporatorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcEvaporatorTypeEnum(tape[9])
    return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcEvaporatorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcEvaporatorType
}())
exports.IfcEvaporatorType = IfcEvaporatorType

var IfcEvent = /** @class */ (function() {
  /**
   *
   */
  function IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.PredefinedType = PredefinedType
    this.EventTriggerType = EventTriggerType
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType
    this.EventOccurenceTime = EventOccurenceTime
  }
  IfcEvent.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let PredefinedType
    if (tape[7]) {
      PredefinedType = new IfcEventTypeEnum(tape[7])
    } else {
      PredefinedType = null
    }
    let EventTriggerType
    if (tape[8]) {
      EventTriggerType = new IfcEventTriggerTypeEnum(tape[8])
    } else {
      EventTriggerType = null
    }
    let UserDefinedEventTriggerType
    if (tape[9]) {
      UserDefinedEventTriggerType = tape[9]
    } else {
      UserDefinedEventTriggerType = null
    }
    let EventOccurenceTime
    if (tape[10]) {
      EventOccurenceTime = tape[10]
    } else {
      EventOccurenceTime = null
    }
    return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime)
  }
  IfcEvent.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.EventTriggerType) {
      args.push(ENUM)
      args.push(this.EventTriggerType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedEventTriggerType) {
      args.push(STRING)
      args.push(this.UserDefinedEventTriggerType)
    } else {
      args.push(EMPTY)
    }
    if (this.EventOccurenceTime) {
      args.push(REF)
      args.push(this.EventOccurenceTime)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEvent
}())
exports.IfcEvent = IfcEvent

var IfcEventTime = /** @class */ (function() {
  /**
   *
   */
  function IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.ActualDate = ActualDate
    this.EarlyDate = EarlyDate
    this.LateDate = LateDate
    this.ScheduleDate = ScheduleDate
  }
  IfcEventTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let ActualDate
    if (tape[3]) {
      ActualDate = tape[3]
    } else {
      ActualDate = null
    }
    let EarlyDate
    if (tape[4]) {
      EarlyDate = tape[4]
    } else {
      EarlyDate = null
    }
    let LateDate
    if (tape[5]) {
      LateDate = tape[5]
    } else {
      LateDate = null
    }
    let ScheduleDate
    if (tape[6]) {
      ScheduleDate = tape[6]
    } else {
      ScheduleDate = null
    }
    return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate)
  }
  IfcEventTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualDate) {
      args.push(STRING)
      args.push(this.ActualDate)
    } else {
      args.push(EMPTY)
    }
    if (this.EarlyDate) {
      args.push(STRING)
      args.push(this.EarlyDate)
    } else {
      args.push(EMPTY)
    }
    if (this.LateDate) {
      args.push(STRING)
      args.push(this.LateDate)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleDate) {
      args.push(STRING)
      args.push(this.ScheduleDate)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEventTime
}())
exports.IfcEventTime = IfcEventTime

var IfcEventType = /** @class */ (function() {
  /**
   *
   */
  function IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ProcessType = ProcessType
    this.PredefinedType = PredefinedType
    this.EventTriggerType = EventTriggerType
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType
  }
  IfcEventType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ProcessType
    if (tape[8]) {
      ProcessType = tape[8]
    } else {
      ProcessType = null
    }
    let PredefinedType
    PredefinedType = new IfcEventTypeEnum(tape[9])
    let EventTriggerType
    EventTriggerType = new IfcEventTriggerTypeEnum(tape[10])
    let UserDefinedEventTriggerType
    if (tape[11]) {
      UserDefinedEventTriggerType = tape[11]
    } else {
      UserDefinedEventTriggerType = null
    }
    return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType)
  }
  IfcEventType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ProcessType) {
      args.push(STRING)
      args.push(this.ProcessType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(ENUM)
    args.push(this.EventTriggerType.value)
    if (this.UserDefinedEventTriggerType) {
      args.push(STRING)
      args.push(this.UserDefinedEventTriggerType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcEventType
}())
exports.IfcEventType = IfcEventType

var IfcExtendedProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcExtendedProperties(expressID, type, Name, Description, Properties) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Properties = Properties
  }
  IfcExtendedProperties.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Properties
    Properties = []
    let Properties_index = 0
    while (Properties_index < tape[2].length) {
      Properties.push(tape[2][Properties_index++])
    }
    return new IfcExtendedProperties(expressID, type, Name, Description, Properties)
  }
  IfcExtendedProperties.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Properties.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcExtendedProperties
}())
exports.IfcExtendedProperties = IfcExtendedProperties

var IfcExternalInformation = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalInformation(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcExternalInformation.FromTape = function(expressID, type, tape) {
    return new IfcExternalInformation(expressID, type)
  }
  IfcExternalInformation.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcExternalInformation
}())
exports.IfcExternalInformation = IfcExternalInformation

var IfcExternalReference = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalReference(expressID, type, Location, Identification, Name) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
  }
  IfcExternalReference.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    return new IfcExternalReference(expressID, type, Location, Identification, Name)
  }
  IfcExternalReference.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternalReference
}())
exports.IfcExternalReference = IfcExternalReference

var IfcExternalReferenceRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingReference = RelatingReference
    this.RelatedResourceObjects = RelatedResourceObjects
  }
  IfcExternalReferenceRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingReference
    RelatingReference = tape[2]
    let RelatedResourceObjects
    RelatedResourceObjects = []
    let RelatedResourceObjects_index = 0
    while (RelatedResourceObjects_index < tape[3].length) {
      RelatedResourceObjects.push(ParseType(tape[3][RelatedResourceObjects_index++], tape[3][RelatedResourceObjects_index++][0]))
    }
    return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects)
  }
  IfcExternalReferenceRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingReference)
    return args
  }
  return IfcExternalReferenceRelationship
}())
exports.IfcExternalReferenceRelationship = IfcExternalReferenceRelationship

var IfcExternalSpatialElement = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.PredefinedType = PredefinedType
  }
  IfcExternalSpatialElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcExternalSpatialElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType)
  }
  IfcExternalSpatialElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternalSpatialElement
}())
exports.IfcExternalSpatialElement = IfcExternalSpatialElement

var IfcExternalSpatialStructureElement = /** @class */ (function() {
  /**
   *
   */
  function IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
  }
  IfcExternalSpatialStructureElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
  }
  IfcExternalSpatialStructureElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternalSpatialStructureElement
}())
exports.IfcExternalSpatialStructureElement = IfcExternalSpatialStructureElement

var IfcExternallyDefinedHatchStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
  }
  IfcExternallyDefinedHatchStyle.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name)
  }
  IfcExternallyDefinedHatchStyle.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternallyDefinedHatchStyle
}())
exports.IfcExternallyDefinedHatchStyle = IfcExternallyDefinedHatchStyle

var IfcExternallyDefinedSurfaceStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
  }
  IfcExternallyDefinedSurfaceStyle.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name)
  }
  IfcExternallyDefinedSurfaceStyle.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternallyDefinedSurfaceStyle
}())
exports.IfcExternallyDefinedSurfaceStyle = IfcExternallyDefinedSurfaceStyle

var IfcExternallyDefinedTextFont = /** @class */ (function() {
  /**
   *
   */
  function IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
  }
  IfcExternallyDefinedTextFont.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name)
  }
  IfcExternallyDefinedTextFont.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcExternallyDefinedTextFont
}())
exports.IfcExternallyDefinedTextFont = IfcExternallyDefinedTextFont

var IfcExtrudedAreaSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.ExtrudedDirection = ExtrudedDirection
    this.Depth = Depth
  }
  IfcExtrudedAreaSolid.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let ExtrudedDirection
    ExtrudedDirection = tape[2]
    let Depth
    Depth = tape[3]
    return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth)
  }
  IfcExtrudedAreaSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ExtrudedDirection)
    return args
  }
  return IfcExtrudedAreaSolid
}())
exports.IfcExtrudedAreaSolid = IfcExtrudedAreaSolid

var IfcExtrudedAreaSolidTapered = /** @class */ (function() {
  /**
   *
   */
  function IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.ExtrudedDirection = ExtrudedDirection
    this.Depth = Depth
    this.EndSweptArea = EndSweptArea
  }
  IfcExtrudedAreaSolidTapered.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let ExtrudedDirection
    ExtrudedDirection = tape[2]
    let Depth
    Depth = tape[3]
    let EndSweptArea
    EndSweptArea = tape[4]
    return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea)
  }
  IfcExtrudedAreaSolidTapered.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ExtrudedDirection)
    args.push(REF)
    args.push(this.EndSweptArea)
    return args
  }
  return IfcExtrudedAreaSolidTapered
}())
exports.IfcExtrudedAreaSolidTapered = IfcExtrudedAreaSolidTapered

var IfcFace = /** @class */ (function() {
  /**
   *
   */
  function IfcFace(expressID, type, Bounds) {
    this.expressID = expressID
    this.type = type
    this.Bounds = Bounds
  }
  IfcFace.FromTape = function(expressID, type, tape) {
    let Bounds
    Bounds = []
    let Bounds_index = 0
    while (Bounds_index < tape[0].length) {
      Bounds.push(tape[0][Bounds_index++])
    }
    return new IfcFace(expressID, type, Bounds)
  }
  IfcFace.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Bounds.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcFace
}())
exports.IfcFace = IfcFace

var IfcFaceBasedSurfaceModel = /** @class */ (function() {
  /**
   *
   */
  function IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces) {
    this.expressID = expressID
    this.type = type
    this.FbsmFaces = FbsmFaces
  }
  IfcFaceBasedSurfaceModel.FromTape = function(expressID, type, tape) {
    let FbsmFaces
    FbsmFaces = []
    let FbsmFaces_index = 0
    while (FbsmFaces_index < tape[0].length) {
      FbsmFaces.push(tape[0][FbsmFaces_index++])
    }
    return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces)
  }
  IfcFaceBasedSurfaceModel.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.FbsmFaces.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcFaceBasedSurfaceModel
}())
exports.IfcFaceBasedSurfaceModel = IfcFaceBasedSurfaceModel

var IfcFaceBound = /** @class */ (function() {
  /**
   *
   */
  function IfcFaceBound(expressID, type, Bound, Orientation) {
    this.expressID = expressID
    this.type = type
    this.Bound = Bound
    this.Orientation = Orientation
  }
  IfcFaceBound.FromTape = function(expressID, type, tape) {
    let Bound
    Bound = tape[0]
    let Orientation
    Orientation = tape[1]
    return new IfcFaceBound(expressID, type, Bound, Orientation)
  }
  IfcFaceBound.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Bound)
    return args
  }
  return IfcFaceBound
}())
exports.IfcFaceBound = IfcFaceBound

var IfcFaceOuterBound = /** @class */ (function() {
  /**
   *
   */
  function IfcFaceOuterBound(expressID, type, Bound, Orientation) {
    this.expressID = expressID
    this.type = type
    this.Bound = Bound
    this.Orientation = Orientation
  }
  IfcFaceOuterBound.FromTape = function(expressID, type, tape) {
    let Bound
    Bound = tape[0]
    let Orientation
    Orientation = tape[1]
    return new IfcFaceOuterBound(expressID, type, Bound, Orientation)
  }
  IfcFaceOuterBound.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Bound)
    return args
  }
  return IfcFaceOuterBound
}())
exports.IfcFaceOuterBound = IfcFaceOuterBound

var IfcFaceSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID
    this.type = type
    this.Bounds = Bounds
    this.FaceSurface = FaceSurface
    this.SameSense = SameSense
  }
  IfcFaceSurface.FromTape = function(expressID, type, tape) {
    let Bounds
    Bounds = []
    let Bounds_index = 0
    while (Bounds_index < tape[0].length) {
      Bounds.push(tape[0][Bounds_index++])
    }
    let FaceSurface
    FaceSurface = tape[1]
    let SameSense
    SameSense = tape[2]
    return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense)
  }
  IfcFaceSurface.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Bounds.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.FaceSurface)
    return args
  }
  return IfcFaceSurface
}())
exports.IfcFaceSurface = IfcFaceSurface

var IfcFacetedBrep = /** @class */ (function() {
  /**
   *
   */
  function IfcFacetedBrep(expressID, type, Outer) {
    this.expressID = expressID
    this.type = type
    this.Outer = Outer
  }
  IfcFacetedBrep.FromTape = function(expressID, type, tape) {
    let Outer
    Outer = tape[0]
    return new IfcFacetedBrep(expressID, type, Outer)
  }
  IfcFacetedBrep.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Outer)
    return args
  }
  return IfcFacetedBrep
}())
exports.IfcFacetedBrep = IfcFacetedBrep

var IfcFacetedBrepWithVoids = /** @class */ (function() {
  /**
   *
   */
  function IfcFacetedBrepWithVoids(expressID, type, Outer, Voids) {
    this.expressID = expressID
    this.type = type
    this.Outer = Outer
    this.Voids = Voids
  }
  IfcFacetedBrepWithVoids.FromTape = function(expressID, type, tape) {
    let Outer
    Outer = tape[0]
    let Voids
    Voids = []
    let Voids_index = 0
    while (Voids_index < tape[1].length) {
      Voids.push(tape[1][Voids_index++])
    }
    return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids)
  }
  IfcFacetedBrepWithVoids.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Outer)
    args.push(SET_BEGIN)
    this.Voids.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcFacetedBrepWithVoids
}())
exports.IfcFacetedBrepWithVoids = IfcFacetedBrepWithVoids

var IfcFacility = /** @class */ (function() {
  /**
   *
   */
  function IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
  }
  IfcFacility.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
  }
  IfcFacility.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFacility
}())
exports.IfcFacility = IfcFacility

var IfcFacilityPart = /** @class */ (function() {
  /**
   *
   */
  function IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
  }
  IfcFacilityPart.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
  }
  IfcFacilityPart.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFacilityPart
}())
exports.IfcFacilityPart = IfcFacilityPart

var IfcFailureConnectionCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TensionFailureX = TensionFailureX
    this.TensionFailureY = TensionFailureY
    this.TensionFailureZ = TensionFailureZ
    this.CompressionFailureX = CompressionFailureX
    this.CompressionFailureY = CompressionFailureY
    this.CompressionFailureZ = CompressionFailureZ
  }
  IfcFailureConnectionCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TensionFailureX
    if (tape[1]) {
      TensionFailureX = tape[1]
    } else {
      TensionFailureX = null
    }
    let TensionFailureY
    if (tape[2]) {
      TensionFailureY = tape[2]
    } else {
      TensionFailureY = null
    }
    let TensionFailureZ
    if (tape[3]) {
      TensionFailureZ = tape[3]
    } else {
      TensionFailureZ = null
    }
    let CompressionFailureX
    if (tape[4]) {
      CompressionFailureX = tape[4]
    } else {
      CompressionFailureX = null
    }
    let CompressionFailureY
    if (tape[5]) {
      CompressionFailureY = tape[5]
    } else {
      CompressionFailureY = null
    }
    let CompressionFailureZ
    if (tape[6]) {
      CompressionFailureZ = tape[6]
    } else {
      CompressionFailureZ = null
    }
    return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ)
  }
  IfcFailureConnectionCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TensionFailureX) {
      args.push(REAL)
      args.push(this.TensionFailureX)
    } else {
      args.push(EMPTY)
    }
    if (this.TensionFailureY) {
      args.push(REAL)
      args.push(this.TensionFailureY)
    } else {
      args.push(EMPTY)
    }
    if (this.TensionFailureZ) {
      args.push(REAL)
      args.push(this.TensionFailureZ)
    } else {
      args.push(EMPTY)
    }
    if (this.CompressionFailureX) {
      args.push(REAL)
      args.push(this.CompressionFailureX)
    } else {
      args.push(EMPTY)
    }
    if (this.CompressionFailureY) {
      args.push(REAL)
      args.push(this.CompressionFailureY)
    } else {
      args.push(EMPTY)
    }
    if (this.CompressionFailureZ) {
      args.push(REAL)
      args.push(this.CompressionFailureZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFailureConnectionCondition
}())
exports.IfcFailureConnectionCondition = IfcFailureConnectionCondition

var IfcFan = /** @class */ (function() {
  /**
   *
   */
  function IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFan.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFanTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFan.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFan
}())
exports.IfcFan = IfcFan

var IfcFanType = /** @class */ (function() {
  /**
   *
   */
  function IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFanType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFanTypeEnum(tape[9])
    return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFanType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFanType
}())
exports.IfcFanType = IfcFanType

var IfcFastener = /** @class */ (function() {
  /**
   *
   */
  function IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFastener.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFastenerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFastener.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFastener
}())
exports.IfcFastener = IfcFastener

var IfcFastenerType = /** @class */ (function() {
  /**
   *
   */
  function IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFastenerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFastenerTypeEnum(tape[9])
    return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFastenerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFastenerType
}())
exports.IfcFastenerType = IfcFastenerType

var IfcFeatureElement = /** @class */ (function() {
  /**
   *
   */
  function IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFeatureElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFeatureElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFeatureElement
}())
exports.IfcFeatureElement = IfcFeatureElement

var IfcFeatureElementAddition = /** @class */ (function() {
  /**
   *
   */
  function IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFeatureElementAddition.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFeatureElementAddition.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFeatureElementAddition
}())
exports.IfcFeatureElementAddition = IfcFeatureElementAddition

var IfcFeatureElementSubtraction = /** @class */ (function() {
  /**
   *
   */
  function IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFeatureElementSubtraction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFeatureElementSubtraction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFeatureElementSubtraction
}())
exports.IfcFeatureElementSubtraction = IfcFeatureElementSubtraction

var IfcFillAreaStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.FillStyles = FillStyles
    this.ModelorDraughting = ModelorDraughting
  }
  IfcFillAreaStyle.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let FillStyles
    FillStyles = []
    let FillStyles_index = 0
    while (FillStyles_index < tape[1].length) {
      FillStyles.push(ParseType(tape[1][FillStyles_index++], tape[1][FillStyles_index++][0]))
    }
    let ModelorDraughting
    if (tape[2]) {
      ModelorDraughting = tape[2]
    } else {
      ModelorDraughting = null
    }
    return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting)
  }
  IfcFillAreaStyle.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.ModelorDraughting) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFillAreaStyle
}())
exports.IfcFillAreaStyle = IfcFillAreaStyle

var IfcFillAreaStyleHatching = /** @class */ (function() {
  /**
   *
   */
  function IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
    this.expressID = expressID
    this.type = type
    this.HatchLineAppearance = HatchLineAppearance
    this.StartOfNextHatchLine = StartOfNextHatchLine
    this.PointOfReferenceHatchLine = PointOfReferenceHatchLine
    this.PatternStart = PatternStart
    this.HatchLineAngle = HatchLineAngle
  }
  IfcFillAreaStyleHatching.FromTape = function(expressID, type, tape) {
    let HatchLineAppearance
    HatchLineAppearance = tape[0]
    let StartOfNextHatchLine
    StartOfNextHatchLine = ParseType(tape[1], tape[2][0])
    let PointOfReferenceHatchLine
    if (tape[2]) {
      PointOfReferenceHatchLine = tape[2]
    } else {
      PointOfReferenceHatchLine = null
    }
    let PatternStart
    if (tape[3]) {
      PatternStart = tape[3]
    } else {
      PatternStart = null
    }
    let HatchLineAngle
    HatchLineAngle = tape[4]
    return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle)
  }
  IfcFillAreaStyleHatching.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.HatchLineAppearance)
    if (this.PointOfReferenceHatchLine) {
      args.push(REF)
      args.push(this.PointOfReferenceHatchLine)
    } else {
      args.push(EMPTY)
    }
    if (this.PatternStart) {
      args.push(REF)
      args.push(this.PatternStart)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.HatchLineAngle)
    return args
  }
  return IfcFillAreaStyleHatching
}())
exports.IfcFillAreaStyleHatching = IfcFillAreaStyleHatching

var IfcFillAreaStyleTiles = /** @class */ (function() {
  /**
   *
   */
  function IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale) {
    this.expressID = expressID
    this.type = type
    this.TilingPattern = TilingPattern
    this.Tiles = Tiles
    this.TilingScale = TilingScale
  }
  IfcFillAreaStyleTiles.FromTape = function(expressID, type, tape) {
    let TilingPattern
    TilingPattern = []
    let TilingPattern_index = 0
    while (TilingPattern_index < tape[0].length) {
      TilingPattern.push(tape[0][TilingPattern_index++])
    }
    let Tiles
    Tiles = []
    let Tiles_index = 0
    while (Tiles_index < tape[1].length) {
      Tiles.push(tape[1][Tiles_index++])
    }
    let TilingScale
    TilingScale = tape[2]
    return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale)
  }
  IfcFillAreaStyleTiles.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.TilingPattern.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(SET_BEGIN)
    this.Tiles.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcFillAreaStyleTiles
}())
exports.IfcFillAreaStyleTiles = IfcFillAreaStyleTiles

var IfcFilter = /** @class */ (function() {
  /**
   *
   */
  function IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFilter.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFilterTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFilter.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFilter
}())
exports.IfcFilter = IfcFilter

var IfcFilterType = /** @class */ (function() {
  /**
   *
   */
  function IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFilterType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFilterTypeEnum(tape[9])
    return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFilterType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFilterType
}())
exports.IfcFilterType = IfcFilterType

var IfcFireSuppressionTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFireSuppressionTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFireSuppressionTerminalTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFireSuppressionTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFireSuppressionTerminal
}())
exports.IfcFireSuppressionTerminal = IfcFireSuppressionTerminal

var IfcFireSuppressionTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFireSuppressionTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFireSuppressionTerminalTypeEnum(tape[9])
    return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFireSuppressionTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFireSuppressionTerminalType
}())
exports.IfcFireSuppressionTerminalType = IfcFireSuppressionTerminalType

var IfcFixedReferenceSweptAreaSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.Directrix = Directrix
    this.StartParam = StartParam
    this.EndParam = EndParam
    this.FixedReference = FixedReference
  }
  IfcFixedReferenceSweptAreaSolid.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let Directrix
    Directrix = tape[2]
    let StartParam
    if (tape[3]) {
      StartParam = tape[3]
    } else {
      StartParam = null
    }
    let EndParam
    if (tape[4]) {
      EndParam = tape[4]
    } else {
      EndParam = null
    }
    let FixedReference
    FixedReference = tape[5]
    return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference)
  }
  IfcFixedReferenceSweptAreaSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Directrix)
    if (this.StartParam) {
      args.push(REAL)
      args.push(this.StartParam)
    } else {
      args.push(EMPTY)
    }
    if (this.EndParam) {
      args.push(REAL)
      args.push(this.EndParam)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.FixedReference)
    return args
  }
  return IfcFixedReferenceSweptAreaSolid
}())
exports.IfcFixedReferenceSweptAreaSolid = IfcFixedReferenceSweptAreaSolid

var IfcFlowController = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowController.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowController.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowController
}())
exports.IfcFlowController = IfcFlowController

var IfcFlowControllerType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowControllerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowControllerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowControllerType
}())
exports.IfcFlowControllerType = IfcFlowControllerType

var IfcFlowFitting = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowFitting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowFitting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowFitting
}())
exports.IfcFlowFitting = IfcFlowFitting

var IfcFlowFittingType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowFittingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowFittingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowFittingType
}())
exports.IfcFlowFittingType = IfcFlowFittingType

var IfcFlowInstrument = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFlowInstrument.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFlowInstrumentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFlowInstrument.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowInstrument
}())
exports.IfcFlowInstrument = IfcFlowInstrument

var IfcFlowInstrumentType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFlowInstrumentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFlowInstrumentTypeEnum(tape[9])
    return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFlowInstrumentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFlowInstrumentType
}())
exports.IfcFlowInstrumentType = IfcFlowInstrumentType

var IfcFlowMeter = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFlowMeter.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFlowMeterTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFlowMeter.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowMeter
}())
exports.IfcFlowMeter = IfcFlowMeter

var IfcFlowMeterType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFlowMeterType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFlowMeterTypeEnum(tape[9])
    return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFlowMeterType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFlowMeterType
}())
exports.IfcFlowMeterType = IfcFlowMeterType

var IfcFlowMovingDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowMovingDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowMovingDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowMovingDevice
}())
exports.IfcFlowMovingDevice = IfcFlowMovingDevice

var IfcFlowMovingDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowMovingDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowMovingDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowMovingDeviceType
}())
exports.IfcFlowMovingDeviceType = IfcFlowMovingDeviceType

var IfcFlowSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowSegment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowSegment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowSegment
}())
exports.IfcFlowSegment = IfcFlowSegment

var IfcFlowSegmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowSegmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowSegmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowSegmentType
}())
exports.IfcFlowSegmentType = IfcFlowSegmentType

var IfcFlowStorageDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowStorageDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowStorageDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowStorageDevice
}())
exports.IfcFlowStorageDevice = IfcFlowStorageDevice

var IfcFlowStorageDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowStorageDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowStorageDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowStorageDeviceType
}())
exports.IfcFlowStorageDeviceType = IfcFlowStorageDeviceType

var IfcFlowTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowTerminal
}())
exports.IfcFlowTerminal = IfcFlowTerminal

var IfcFlowTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowTerminalType
}())
exports.IfcFlowTerminalType = IfcFlowTerminalType

var IfcFlowTreatmentDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFlowTreatmentDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFlowTreatmentDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowTreatmentDevice
}())
exports.IfcFlowTreatmentDevice = IfcFlowTreatmentDevice

var IfcFlowTreatmentDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFlowTreatmentDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFlowTreatmentDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFlowTreatmentDeviceType
}())
exports.IfcFlowTreatmentDeviceType = IfcFlowTreatmentDeviceType

var IfcFooting = /** @class */ (function() {
  /**
   *
   */
  function IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFooting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFootingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFooting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFooting
}())
exports.IfcFooting = IfcFooting

var IfcFootingType = /** @class */ (function() {
  /**
   *
   */
  function IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcFootingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcFootingTypeEnum(tape[9])
    return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcFootingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcFootingType
}())
exports.IfcFootingType = IfcFootingType

var IfcFurnishingElement = /** @class */ (function() {
  /**
   *
   */
  function IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcFurnishingElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcFurnishingElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFurnishingElement
}())
exports.IfcFurnishingElement = IfcFurnishingElement

var IfcFurnishingElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcFurnishingElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcFurnishingElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFurnishingElementType
}())
exports.IfcFurnishingElementType = IfcFurnishingElementType

var IfcFurniture = /** @class */ (function() {
  /**
   *
   */
  function IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcFurniture.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcFurnitureTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcFurniture.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFurniture
}())
exports.IfcFurniture = IfcFurniture

var IfcFurnitureType = /** @class */ (function() {
  /**
   *
   */
  function IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.AssemblyPlace = AssemblyPlace
    this.PredefinedType = PredefinedType
  }
  IfcFurnitureType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let AssemblyPlace
    AssemblyPlace = new IfcAssemblyPlaceEnum(tape[9])
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcFurnitureTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType)
  }
  IfcFurnitureType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.AssemblyPlace.value)
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcFurnitureType
}())
exports.IfcFurnitureType = IfcFurnitureType

var IfcGeographicElement = /** @class */ (function() {
  /**
   *
   */
  function IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcGeographicElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcGeographicElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcGeographicElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGeographicElement
}())
exports.IfcGeographicElement = IfcGeographicElement

var IfcGeographicElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcGeographicElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcGeographicElementTypeEnum(tape[9])
    return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcGeographicElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcGeographicElementType
}())
exports.IfcGeographicElementType = IfcGeographicElementType

var IfcGeometricCurveSet = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricCurveSet(expressID, type, Elements) {
    this.expressID = expressID
    this.type = type
    this.Elements = Elements
  }
  IfcGeometricCurveSet.FromTape = function(expressID, type, tape) {
    let Elements
    Elements = []
    let Elements_index = 0
    while (Elements_index < tape[0].length) {
      Elements.push(ParseType(tape[0][Elements_index++], tape[0][Elements_index++][0]))
    }
    return new IfcGeometricCurveSet(expressID, type, Elements)
  }
  IfcGeometricCurveSet.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcGeometricCurveSet
}())
exports.IfcGeometricCurveSet = IfcGeometricCurveSet

var IfcGeometricRepresentationContext = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
    this.expressID = expressID
    this.type = type
    this.ContextIdentifier = ContextIdentifier
    this.ContextType = ContextType
    this.CoordinateSpaceDimension = CoordinateSpaceDimension
    this.Precision = Precision
    this.WorldCoordinateSystem = WorldCoordinateSystem
    this.TrueNorth = TrueNorth
  }
  IfcGeometricRepresentationContext.FromTape = function(expressID, type, tape) {
    let ContextIdentifier
    if (tape[0]) {
      ContextIdentifier = tape[0]
    } else {
      ContextIdentifier = null
    }
    let ContextType
    if (tape[1]) {
      ContextType = tape[1]
    } else {
      ContextType = null
    }
    let CoordinateSpaceDimension
    CoordinateSpaceDimension = tape[2]
    let Precision
    if (tape[3]) {
      Precision = tape[3]
    } else {
      Precision = null
    }
    let WorldCoordinateSystem
    WorldCoordinateSystem = ParseType(tape[4], tape[5][0])
    let TrueNorth
    if (tape[5]) {
      TrueNorth = tape[5]
    } else {
      TrueNorth = null
    }
    return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth)
  }
  IfcGeometricRepresentationContext.prototype.ToTape = function() {
    const args = []
    if (this.ContextIdentifier) {
      args.push(STRING)
      args.push(this.ContextIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.ContextType) {
      args.push(STRING)
      args.push(this.ContextType)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.CoordinateSpaceDimension)
    if (this.Precision) {
      args.push(REAL)
      args.push(this.Precision)
    } else {
      args.push(EMPTY)
    }
    if (this.TrueNorth) {
      args.push(REF)
      args.push(this.TrueNorth)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGeometricRepresentationContext
}())
exports.IfcGeometricRepresentationContext = IfcGeometricRepresentationContext

var IfcGeometricRepresentationItem = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricRepresentationItem(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcGeometricRepresentationItem.FromTape = function(expressID, type, tape) {
    return new IfcGeometricRepresentationItem(expressID, type)
  }
  IfcGeometricRepresentationItem.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcGeometricRepresentationItem
}())
exports.IfcGeometricRepresentationItem = IfcGeometricRepresentationItem

var IfcGeometricRepresentationSubContext = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
    this.expressID = expressID
    this.type = type
    this.ContextIdentifier = ContextIdentifier
    this.ContextType = ContextType
    this.CoordinateSpaceDimension = CoordinateSpaceDimension
    this.Precision = Precision
    this.WorldCoordinateSystem = WorldCoordinateSystem
    this.TrueNorth = TrueNorth
    this.ParentContext = ParentContext
    this.TargetScale = TargetScale
    this.TargetView = TargetView
    this.UserDefinedTargetView = UserDefinedTargetView
  }
  IfcGeometricRepresentationSubContext.FromTape = function(expressID, type, tape) {
    let ContextIdentifier
    if (tape[0]) {
      ContextIdentifier = tape[0]
    } else {
      ContextIdentifier = null
    }
    let ContextType
    if (tape[1]) {
      ContextType = tape[1]
    } else {
      ContextType = null
    }
    let CoordinateSpaceDimension
    CoordinateSpaceDimension = tape[2]
    let Precision
    if (tape[3]) {
      Precision = tape[3]
    } else {
      Precision = null
    }
    let WorldCoordinateSystem
    WorldCoordinateSystem = ParseType(tape[4], tape[5][0])
    let TrueNorth
    if (tape[5]) {
      TrueNorth = tape[5]
    } else {
      TrueNorth = null
    }
    let ParentContext
    ParentContext = tape[6]
    let TargetScale
    if (tape[7]) {
      TargetScale = tape[7]
    } else {
      TargetScale = null
    }
    let TargetView
    TargetView = new IfcGeometricProjectionEnum(tape[8])
    let UserDefinedTargetView
    if (tape[9]) {
      UserDefinedTargetView = tape[9]
    } else {
      UserDefinedTargetView = null
    }
    return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView)
  }
  IfcGeometricRepresentationSubContext.prototype.ToTape = function() {
    const args = []
    if (this.ContextIdentifier) {
      args.push(STRING)
      args.push(this.ContextIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.ContextType) {
      args.push(STRING)
      args.push(this.ContextType)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.CoordinateSpaceDimension)
    if (this.Precision) {
      args.push(REAL)
      args.push(this.Precision)
    } else {
      args.push(EMPTY)
    }
    if (this.TrueNorth) {
      args.push(REF)
      args.push(this.TrueNorth)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ParentContext)
    if (this.TargetScale) {
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.TargetView.value)
    if (this.UserDefinedTargetView) {
      args.push(STRING)
      args.push(this.UserDefinedTargetView)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGeometricRepresentationSubContext
}())
exports.IfcGeometricRepresentationSubContext = IfcGeometricRepresentationSubContext

var IfcGeometricSet = /** @class */ (function() {
  /**
   *
   */
  function IfcGeometricSet(expressID, type, Elements) {
    this.expressID = expressID
    this.type = type
    this.Elements = Elements
  }
  IfcGeometricSet.FromTape = function(expressID, type, tape) {
    let Elements
    Elements = []
    let Elements_index = 0
    while (Elements_index < tape[0].length) {
      Elements.push(ParseType(tape[0][Elements_index++], tape[0][Elements_index++][0]))
    }
    return new IfcGeometricSet(expressID, type, Elements)
  }
  IfcGeometricSet.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcGeometricSet
}())
exports.IfcGeometricSet = IfcGeometricSet

var IfcGrid = /** @class */ (function() {
  /**
   *
   */
  function IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.UAxes = UAxes
    this.VAxes = VAxes
    this.WAxes = WAxes
    this.PredefinedType = PredefinedType
  }
  IfcGrid.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let UAxes
    UAxes = []
    let UAxes_index = 0
    while (UAxes_index < tape[7].length) {
      UAxes.push(tape[7][UAxes_index++])
    }
    let VAxes
    VAxes = []
    let VAxes_index = 0
    while (VAxes_index < tape[8].length) {
      VAxes.push(tape[8][VAxes_index++])
    }
    let WAxes
    if (tape[9]) {
      WAxes = []
      let WAxes_index = 0
      while (WAxes_index < tape[9].length) {
        WAxes.push(tape[9][WAxes_index++])
      }
    } else {
      WAxes = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcGridTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType)
  }
  IfcGrid.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.UAxes.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(SET_BEGIN)
    this.VAxes.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.WAxes) {
      args.push(SET_BEGIN)
      this.WAxes.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGrid
}())
exports.IfcGrid = IfcGrid

var IfcGridAxis = /** @class */ (function() {
  /**
   *
   */
  function IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense) {
    this.expressID = expressID
    this.type = type
    this.AxisTag = AxisTag
    this.AxisCurve = AxisCurve
    this.SameSense = SameSense
  }
  IfcGridAxis.FromTape = function(expressID, type, tape) {
    let AxisTag
    if (tape[0]) {
      AxisTag = tape[0]
    } else {
      AxisTag = null
    }
    let AxisCurve
    AxisCurve = tape[1]
    let SameSense
    SameSense = tape[2]
    return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense)
  }
  IfcGridAxis.prototype.ToTape = function() {
    const args = []
    if (this.AxisTag) {
      args.push(STRING)
      args.push(this.AxisTag)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AxisCurve)
    return args
  }
  return IfcGridAxis
}())
exports.IfcGridAxis = IfcGridAxis

var IfcGridPlacement = /** @class */ (function() {
  /**
   *
   */
  function IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
    this.expressID = expressID
    this.type = type
    this.PlacementRelTo = PlacementRelTo
    this.PlacementLocation = PlacementLocation
    this.PlacementRefDirection = PlacementRefDirection
  }
  IfcGridPlacement.FromTape = function(expressID, type, tape) {
    let PlacementRelTo
    if (tape[0]) {
      PlacementRelTo = tape[0]
    } else {
      PlacementRelTo = null
    }
    let PlacementLocation
    PlacementLocation = tape[1]
    let PlacementRefDirection
    if (tape[2]) {
      PlacementRefDirection = ParseType(tape[2], tape[3][0])
    } else {
      PlacementRefDirection = null
    }
    return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection)
  }
  IfcGridPlacement.prototype.ToTape = function() {
    const args = []
    if (this.PlacementRelTo) {
      args.push(REF)
      args.push(this.PlacementRelTo)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.PlacementLocation)
    if (this.PlacementRefDirection) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGridPlacement
}())
exports.IfcGridPlacement = IfcGridPlacement

var IfcGroup = /** @class */ (function() {
  /**
   *
   */
  function IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
  }
  IfcGroup.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType)
  }
  IfcGroup.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcGroup
}())
exports.IfcGroup = IfcGroup

var IfcHalfSpaceSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag) {
    this.expressID = expressID
    this.type = type
    this.BaseSurface = BaseSurface
    this.AgreementFlag = AgreementFlag
  }
  IfcHalfSpaceSolid.FromTape = function(expressID, type, tape) {
    let BaseSurface
    BaseSurface = tape[0]
    let AgreementFlag
    AgreementFlag = tape[1]
    return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag)
  }
  IfcHalfSpaceSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BaseSurface)
    return args
  }
  return IfcHalfSpaceSolid
}())
exports.IfcHalfSpaceSolid = IfcHalfSpaceSolid

var IfcHeatExchanger = /** @class */ (function() {
  /**
   *
   */
  function IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcHeatExchanger.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcHeatExchangerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcHeatExchanger.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcHeatExchanger
}())
exports.IfcHeatExchanger = IfcHeatExchanger

var IfcHeatExchangerType = /** @class */ (function() {
  /**
   *
   */
  function IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcHeatExchangerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcHeatExchangerTypeEnum(tape[9])
    return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcHeatExchangerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcHeatExchangerType
}())
exports.IfcHeatExchangerType = IfcHeatExchangerType

var IfcHumidifier = /** @class */ (function() {
  /**
   *
   */
  function IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcHumidifier.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcHumidifierTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcHumidifier.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcHumidifier
}())
exports.IfcHumidifier = IfcHumidifier

var IfcHumidifierType = /** @class */ (function() {
  /**
   *
   */
  function IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcHumidifierType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcHumidifierTypeEnum(tape[9])
    return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcHumidifierType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcHumidifierType
}())
exports.IfcHumidifierType = IfcHumidifierType

var IfcIShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.OverallWidth = OverallWidth
    this.OverallDepth = OverallDepth
    this.WebThickness = WebThickness
    this.FlangeThickness = FlangeThickness
    this.FilletRadius = FilletRadius
    this.FlangeEdgeRadius = FlangeEdgeRadius
    this.FlangeSlope = FlangeSlope
  }
  IfcIShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let OverallWidth
    OverallWidth = tape[3]
    let OverallDepth
    OverallDepth = tape[4]
    let WebThickness
    WebThickness = tape[5]
    let FlangeThickness
    FlangeThickness = tape[6]
    let FilletRadius
    if (tape[7]) {
      FilletRadius = tape[7]
    } else {
      FilletRadius = null
    }
    let FlangeEdgeRadius
    if (tape[8]) {
      FlangeEdgeRadius = tape[8]
    } else {
      FlangeEdgeRadius = null
    }
    let FlangeSlope
    if (tape[9]) {
      FlangeSlope = tape[9]
    } else {
      FlangeSlope = null
    }
    return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope)
  }
  IfcIShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.FlangeEdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.FlangeSlope) {
      args.push(REAL)
      args.push(this.FlangeSlope)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcIShapeProfileDef
}())
exports.IfcIShapeProfileDef = IfcIShapeProfileDef

var IfcImageTexture = /** @class */ (function() {
  /**
   *
   */
  function IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
    this.expressID = expressID
    this.type = type
    this.RepeatS = RepeatS
    this.RepeatT = RepeatT
    this.Mode = Mode
    this.TextureTransform = TextureTransform
    this.Parameter = Parameter
    this.URLReference = URLReference
  }
  IfcImageTexture.FromTape = function(expressID, type, tape) {
    let RepeatS
    RepeatS = tape[0]
    let RepeatT
    RepeatT = tape[1]
    let Mode
    if (tape[2]) {
      Mode = tape[2]
    } else {
      Mode = null
    }
    let TextureTransform
    if (tape[3]) {
      TextureTransform = tape[3]
    } else {
      TextureTransform = null
    }
    let Parameter
    if (tape[4]) {
      Parameter = []
      let Parameter_index = 0
      while (Parameter_index < tape[4].length) {
        Parameter.push(tape[4][Parameter_index++])
      }
    } else {
      Parameter = null
    }
    let URLReference
    URLReference = tape[5]
    return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference)
  }
  IfcImageTexture.prototype.ToTape = function() {
    const args = []
    if (this.Mode) {
      args.push(STRING)
      args.push(this.Mode)
    } else {
      args.push(EMPTY)
    }
    if (this.TextureTransform) {
      args.push(REF)
      args.push(this.TextureTransform)
    } else {
      args.push(EMPTY)
    }
    if (this.Parameter) {
      args.push(STRING)
      args.push.apply(args, this.Parameter)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.URLReference)
    return args
  }
  return IfcImageTexture
}())
exports.IfcImageTexture = IfcImageTexture

var IfcIndexedColourMap = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
    this.expressID = expressID
    this.type = type
    this.MappedTo = MappedTo
    this.Opacity = Opacity
    this.Colours = Colours
    this.ColourIndex = ColourIndex
  }
  IfcIndexedColourMap.FromTape = function(expressID, type, tape) {
    let MappedTo
    MappedTo = tape[0]
    let Opacity
    if (tape[1]) {
      Opacity = tape[1]
    } else {
      Opacity = null
    }
    let Colours
    Colours = tape[2]
    let ColourIndex
    ColourIndex = []
    let ColourIndex_index = 0
    while (ColourIndex_index < tape[3].length) {
      ColourIndex.push(tape[3][ColourIndex_index++])
    }
    return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex)
  }
  IfcIndexedColourMap.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.MappedTo)
    if (this.Opacity) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Colours)
    return args
  }
  return IfcIndexedColourMap
}())
exports.IfcIndexedColourMap = IfcIndexedColourMap

var IfcIndexedPolyCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Points = Points
    this.Segments = Segments
    this.SelfIntersect = SelfIntersect
  }
  IfcIndexedPolyCurve.FromTape = function(expressID, type, tape) {
    let Points
    Points = tape[0]
    let Segments
    if (tape[1]) {
      Segments = []
      let Segments_index = 0
      while (Segments_index < tape[1].length) {
        Segments.push(ParseType(tape[1][Segments_index++], tape[1][Segments_index++][0]))
      }
    } else {
      Segments = null
    }
    let SelfIntersect
    if (tape[2]) {
      SelfIntersect = tape[2]
    } else {
      SelfIntersect = null
    }
    return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect)
  }
  IfcIndexedPolyCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Points)
    if (this.Segments) {
    } else {
      args.push(EMPTY)
    }
    if (this.SelfIntersect) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcIndexedPolyCurve
}())
exports.IfcIndexedPolyCurve = IfcIndexedPolyCurve

var IfcIndexedPolygonalFace = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedPolygonalFace(expressID, type, CoordIndex) {
    this.expressID = expressID
    this.type = type
    this.CoordIndex = CoordIndex
  }
  IfcIndexedPolygonalFace.FromTape = function(expressID, type, tape) {
    let CoordIndex
    CoordIndex = []
    let CoordIndex_index = 0
    while (CoordIndex_index < tape[0].length) {
      CoordIndex.push(tape[0][CoordIndex_index++])
    }
    return new IfcIndexedPolygonalFace(expressID, type, CoordIndex)
  }
  IfcIndexedPolygonalFace.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcIndexedPolygonalFace
}())
exports.IfcIndexedPolygonalFace = IfcIndexedPolygonalFace

var IfcIndexedPolygonalFaceWithVoids = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices) {
    this.expressID = expressID
    this.type = type
    this.CoordIndex = CoordIndex
    this.InnerCoordIndices = InnerCoordIndices
  }
  IfcIndexedPolygonalFaceWithVoids.FromTape = function(expressID, type, tape) {
    let CoordIndex
    CoordIndex = []
    let CoordIndex_index = 0
    while (CoordIndex_index < tape[0].length) {
      CoordIndex.push(tape[0][CoordIndex_index++])
    }
    let InnerCoordIndices
    InnerCoordIndices = []
    let InnerCoordIndices_index = 0
    while (InnerCoordIndices_index < tape[1].length) {
      InnerCoordIndices.push(tape[1][InnerCoordIndices_index++])
    }
    return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices)
  }
  IfcIndexedPolygonalFaceWithVoids.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcIndexedPolygonalFaceWithVoids
}())
exports.IfcIndexedPolygonalFaceWithVoids = IfcIndexedPolygonalFaceWithVoids

var IfcIndexedTextureMap = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords) {
    this.expressID = expressID
    this.type = type
    this.Maps = Maps
    this.MappedTo = MappedTo
    this.TexCoords = TexCoords
  }
  IfcIndexedTextureMap.FromTape = function(expressID, type, tape) {
    let Maps
    Maps = []
    let Maps_index = 0
    while (Maps_index < tape[0].length) {
      Maps.push(tape[0][Maps_index++])
    }
    let MappedTo
    MappedTo = tape[1]
    let TexCoords
    TexCoords = tape[2]
    return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords)
  }
  IfcIndexedTextureMap.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Maps.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.MappedTo)
    args.push(REF)
    args.push(this.TexCoords)
    return args
  }
  return IfcIndexedTextureMap
}())
exports.IfcIndexedTextureMap = IfcIndexedTextureMap

var IfcIndexedTriangleTextureMap = /** @class */ (function() {
  /**
   *
   */
  function IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
    this.expressID = expressID
    this.type = type
    this.Maps = Maps
    this.MappedTo = MappedTo
    this.TexCoords = TexCoords
    this.TexCoordIndex = TexCoordIndex
  }
  IfcIndexedTriangleTextureMap.FromTape = function(expressID, type, tape) {
    let Maps
    Maps = []
    let Maps_index = 0
    while (Maps_index < tape[0].length) {
      Maps.push(tape[0][Maps_index++])
    }
    let MappedTo
    MappedTo = tape[1]
    let TexCoords
    TexCoords = tape[2]
    let TexCoordIndex
    if (tape[3]) {
      TexCoordIndex = []
      let TexCoordIndex_index = 0
      while (TexCoordIndex_index < tape[3].length) {
        TexCoordIndex.push(tape[3][TexCoordIndex_index++])
      }
    } else {
      TexCoordIndex = null
    }
    return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex)
  }
  IfcIndexedTriangleTextureMap.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Maps.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.MappedTo)
    args.push(REF)
    args.push(this.TexCoords)
    if (this.TexCoordIndex) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcIndexedTriangleTextureMap
}())
exports.IfcIndexedTriangleTextureMap = IfcIndexedTriangleTextureMap

var IfcInterceptor = /** @class */ (function() {
  /**
   *
   */
  function IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcInterceptor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcInterceptorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcInterceptor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcInterceptor
}())
exports.IfcInterceptor = IfcInterceptor

var IfcInterceptorType = /** @class */ (function() {
  /**
   *
   */
  function IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcInterceptorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcInterceptorTypeEnum(tape[9])
    return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcInterceptorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcInterceptorType
}())
exports.IfcInterceptorType = IfcInterceptorType

var IfcIntersectionCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID
    this.type = type
    this.Curve3D = Curve3D
    this.AssociatedGeometry = AssociatedGeometry
    this.MasterRepresentation = MasterRepresentation
  }
  IfcIntersectionCurve.FromTape = function(expressID, type, tape) {
    let Curve3D
    Curve3D = tape[0]
    let AssociatedGeometry
    AssociatedGeometry = []
    let AssociatedGeometry_index = 0
    while (AssociatedGeometry_index < tape[1].length) {
      AssociatedGeometry.push(tape[1][AssociatedGeometry_index++])
    }
    let MasterRepresentation
    MasterRepresentation = new IfcPreferredSurfaceCurveRepresentation(tape[2])
    return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation)
  }
  IfcIntersectionCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Curve3D)
    args.push(SET_BEGIN)
    this.AssociatedGeometry.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.MasterRepresentation.value)
    return args
  }
  return IfcIntersectionCurve
}())
exports.IfcIntersectionCurve = IfcIntersectionCurve

var IfcInventory = /** @class */ (function() {
  /**
   *
   */
  function IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.PredefinedType = PredefinedType
    this.Jurisdiction = Jurisdiction
    this.ResponsiblePersons = ResponsiblePersons
    this.LastUpdateDate = LastUpdateDate
    this.CurrentValue = CurrentValue
    this.OriginalValue = OriginalValue
  }
  IfcInventory.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let PredefinedType
    if (tape[5]) {
      PredefinedType = new IfcInventoryTypeEnum(tape[5])
    } else {
      PredefinedType = null
    }
    let Jurisdiction
    if (tape[6]) {
      Jurisdiction = ParseType(tape[6], tape[7][0])
    } else {
      Jurisdiction = null
    }
    let ResponsiblePersons
    if (tape[7]) {
      ResponsiblePersons = []
      let ResponsiblePersons_index = 0
      while (ResponsiblePersons_index < tape[7].length) {
        ResponsiblePersons.push(tape[7][ResponsiblePersons_index++])
      }
    } else {
      ResponsiblePersons = null
    }
    let LastUpdateDate
    if (tape[8]) {
      LastUpdateDate = tape[8]
    } else {
      LastUpdateDate = null
    }
    let CurrentValue
    if (tape[9]) {
      CurrentValue = tape[9]
    } else {
      CurrentValue = null
    }
    let OriginalValue
    if (tape[10]) {
      OriginalValue = tape[10]
    } else {
      OriginalValue = null
    }
    return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue)
  }
  IfcInventory.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Jurisdiction) {
    } else {
      args.push(EMPTY)
    }
    if (this.ResponsiblePersons) {
      args.push(SET_BEGIN)
      this.ResponsiblePersons.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.LastUpdateDate) {
      args.push(STRING)
      args.push(this.LastUpdateDate)
    } else {
      args.push(EMPTY)
    }
    if (this.CurrentValue) {
      args.push(REF)
      args.push(this.CurrentValue)
    } else {
      args.push(EMPTY)
    }
    if (this.OriginalValue) {
      args.push(REF)
      args.push(this.OriginalValue)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcInventory
}())
exports.IfcInventory = IfcInventory

var IfcIrregularTimeSeries = /** @class */ (function() {
  /**
   *
   */
  function IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.StartTime = StartTime
    this.EndTime = EndTime
    this.TimeSeriesDataType = TimeSeriesDataType
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.Unit = Unit
    this.Values = Values
  }
  IfcIrregularTimeSeries.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let StartTime
    StartTime = tape[2]
    let EndTime
    EndTime = tape[3]
    let TimeSeriesDataType
    TimeSeriesDataType = new IfcTimeSeriesDataTypeEnum(tape[4])
    let DataOrigin
    DataOrigin = new IfcDataOriginEnum(tape[5])
    let UserDefinedDataOrigin
    if (tape[6]) {
      UserDefinedDataOrigin = tape[6]
    } else {
      UserDefinedDataOrigin = null
    }
    let Unit
    if (tape[7]) {
      Unit = ParseType(tape[7], tape[8][0])
    } else {
      Unit = null
    }
    let Values
    Values = []
    let Values_index = 0
    while (Values_index < tape[8].length) {
      Values.push(tape[8][Values_index++])
    }
    return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values)
  }
  IfcIrregularTimeSeries.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    args.push(STRING)
    args.push(this.EndTime)
    args.push(ENUM)
    args.push(this.TimeSeriesDataType.value)
    args.push(ENUM)
    args.push(this.DataOrigin.value)
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Values.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcIrregularTimeSeries
}())
exports.IfcIrregularTimeSeries = IfcIrregularTimeSeries

var IfcIrregularTimeSeriesValue = /** @class */ (function() {
  /**
   *
   */
  function IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues) {
    this.expressID = expressID
    this.type = type
    this.TimeStamp = TimeStamp
    this.ListValues = ListValues
  }
  IfcIrregularTimeSeriesValue.FromTape = function(expressID, type, tape) {
    let TimeStamp
    TimeStamp = tape[0]
    let ListValues
    ListValues = []
    let ListValues_index = 0
    while (ListValues_index < tape[1].length) {
      ListValues.push(ParseType(tape[1][ListValues_index++], tape[1][ListValues_index++][0]))
    }
    return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues)
  }
  IfcIrregularTimeSeriesValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.TimeStamp)
    return args
  }
  return IfcIrregularTimeSeriesValue
}())
exports.IfcIrregularTimeSeriesValue = IfcIrregularTimeSeriesValue

var IfcJunctionBox = /** @class */ (function() {
  /**
   *
   */
  function IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcJunctionBox.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcJunctionBoxTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcJunctionBox.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcJunctionBox
}())
exports.IfcJunctionBox = IfcJunctionBox

var IfcJunctionBoxType = /** @class */ (function() {
  /**
   *
   */
  function IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcJunctionBoxType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcJunctionBoxTypeEnum(tape[9])
    return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcJunctionBoxType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcJunctionBoxType
}())
exports.IfcJunctionBoxType = IfcJunctionBoxType

var IfcLShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Depth = Depth
    this.Width = Width
    this.Thickness = Thickness
    this.FilletRadius = FilletRadius
    this.EdgeRadius = EdgeRadius
    this.LegSlope = LegSlope
  }
  IfcLShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Depth
    Depth = tape[3]
    let Width
    if (tape[4]) {
      Width = tape[4]
    } else {
      Width = null
    }
    let Thickness
    Thickness = tape[5]
    let FilletRadius
    if (tape[6]) {
      FilletRadius = tape[6]
    } else {
      FilletRadius = null
    }
    let EdgeRadius
    if (tape[7]) {
      EdgeRadius = tape[7]
    } else {
      EdgeRadius = null
    }
    let LegSlope
    if (tape[8]) {
      LegSlope = tape[8]
    } else {
      LegSlope = null
    }
    return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope)
  }
  IfcLShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.Width) {
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.EdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.LegSlope) {
      args.push(REAL)
      args.push(this.LegSlope)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLShapeProfileDef
}())
exports.IfcLShapeProfileDef = IfcLShapeProfileDef

var IfcLaborResource = /** @class */ (function() {
  /**
   *
   */
  function IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcLaborResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcLaborResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcLaborResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLaborResource
}())
exports.IfcLaborResource = IfcLaborResource

var IfcLaborResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcLaborResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcLaborResourceTypeEnum(tape[11])
    return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcLaborResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcLaborResourceType
}())
exports.IfcLaborResourceType = IfcLaborResourceType

var IfcLagTime = /** @class */ (function() {
  /**
   *
   */
  function IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.LagValue = LagValue
    this.DurationType = DurationType
  }
  IfcLagTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let LagValue
    LagValue = ParseType(tape[3], tape[4][0])
    let DurationType
    DurationType = new IfcTaskDurationEnum(tape[4])
    return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType)
  }
  IfcLagTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.DurationType.value)
    return args
  }
  return IfcLagTime
}())
exports.IfcLagTime = IfcLagTime

var IfcLamp = /** @class */ (function() {
  /**
   *
   */
  function IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcLamp.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcLampTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcLamp.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLamp
}())
exports.IfcLamp = IfcLamp

var IfcLampType = /** @class */ (function() {
  /**
   *
   */
  function IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcLampType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcLampTypeEnum(tape[9])
    return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcLampType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcLampType
}())
exports.IfcLampType = IfcLampType

var IfcLibraryInformation = /** @class */ (function() {
  /**
   *
   */
  function IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Version = Version
    this.Publisher = Publisher
    this.VersionDate = VersionDate
    this.Location = Location
    this.Description = Description
  }
  IfcLibraryInformation.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Version
    if (tape[1]) {
      Version = tape[1]
    } else {
      Version = null
    }
    let Publisher
    if (tape[2]) {
      Publisher = ParseType(tape[2], tape[3][0])
    } else {
      Publisher = null
    }
    let VersionDate
    if (tape[3]) {
      VersionDate = tape[3]
    } else {
      VersionDate = null
    }
    let Location
    if (tape[4]) {
      Location = tape[4]
    } else {
      Location = null
    }
    let Description
    if (tape[5]) {
      Description = tape[5]
    } else {
      Description = null
    }
    return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description)
  }
  IfcLibraryInformation.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Version) {
      args.push(STRING)
      args.push(this.Version)
    } else {
      args.push(EMPTY)
    }
    if (this.Publisher) {
    } else {
      args.push(EMPTY)
    }
    if (this.VersionDate) {
      args.push(STRING)
      args.push(this.VersionDate)
    } else {
      args.push(EMPTY)
    }
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLibraryInformation
}())
exports.IfcLibraryInformation = IfcLibraryInformation

var IfcLibraryReference = /** @class */ (function() {
  /**
   *
   */
  function IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
    this.Identification = Identification
    this.Name = Name
    this.Description = Description
    this.Language = Language
    this.ReferencedLibrary = ReferencedLibrary
  }
  IfcLibraryReference.FromTape = function(expressID, type, tape) {
    let Location
    if (tape[0]) {
      Location = tape[0]
    } else {
      Location = null
    }
    let Identification
    if (tape[1]) {
      Identification = tape[1]
    } else {
      Identification = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let Language
    if (tape[4]) {
      Language = tape[4]
    } else {
      Language = null
    }
    let ReferencedLibrary
    if (tape[5]) {
      ReferencedLibrary = tape[5]
    } else {
      ReferencedLibrary = null
    }
    return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary)
  }
  IfcLibraryReference.prototype.ToTape = function() {
    const args = []
    if (this.Location) {
      args.push(STRING)
      args.push(this.Location)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Language) {
    } else {
      args.push(EMPTY)
    }
    if (this.ReferencedLibrary) {
      args.push(REF)
      args.push(this.ReferencedLibrary)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLibraryReference
}())
exports.IfcLibraryReference = IfcLibraryReference

var IfcLightDistributionData = /** @class */ (function() {
  /**
   *
   */
  function IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
    this.expressID = expressID
    this.type = type
    this.MainPlaneAngle = MainPlaneAngle
    this.SecondaryPlaneAngle = SecondaryPlaneAngle
    this.LuminousIntensity = LuminousIntensity
  }
  IfcLightDistributionData.FromTape = function(expressID, type, tape) {
    let MainPlaneAngle
    MainPlaneAngle = tape[0]
    let SecondaryPlaneAngle
    SecondaryPlaneAngle = []
    let SecondaryPlaneAngle_index = 0
    while (SecondaryPlaneAngle_index < tape[1].length) {
      SecondaryPlaneAngle.push(tape[1][SecondaryPlaneAngle_index++])
    }
    let LuminousIntensity
    LuminousIntensity = []
    let LuminousIntensity_index = 0
    while (LuminousIntensity_index < tape[2].length) {
      LuminousIntensity.push(tape[2][LuminousIntensity_index++])
    }
    return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity)
  }
  IfcLightDistributionData.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.MainPlaneAngle)
    args.push(REAL)
    args.push.apply(args, this.SecondaryPlaneAngle)
    args.push(REAL)
    args.push.apply(args, this.LuminousIntensity)
    return args
  }
  return IfcLightDistributionData
}())
exports.IfcLightDistributionData = IfcLightDistributionData

var IfcLightFixture = /** @class */ (function() {
  /**
   *
   */
  function IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcLightFixture.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcLightFixtureTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcLightFixture.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLightFixture
}())
exports.IfcLightFixture = IfcLightFixture

var IfcLightFixtureType = /** @class */ (function() {
  /**
   *
   */
  function IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcLightFixtureType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcLightFixtureTypeEnum(tape[9])
    return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcLightFixtureType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcLightFixtureType
}())
exports.IfcLightFixtureType = IfcLightFixtureType

var IfcLightIntensityDistribution = /** @class */ (function() {
  /**
   *
   */
  function IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData) {
    this.expressID = expressID
    this.type = type
    this.LightDistributionCurve = LightDistributionCurve
    this.DistributionData = DistributionData
  }
  IfcLightIntensityDistribution.FromTape = function(expressID, type, tape) {
    let LightDistributionCurve
    LightDistributionCurve = new IfcLightDistributionCurveEnum(tape[0])
    let DistributionData
    DistributionData = []
    let DistributionData_index = 0
    while (DistributionData_index < tape[1].length) {
      DistributionData.push(tape[1][DistributionData_index++])
    }
    return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData)
  }
  IfcLightIntensityDistribution.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.LightDistributionCurve.value)
    args.push(SET_BEGIN)
    this.DistributionData.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcLightIntensityDistribution
}())
exports.IfcLightIntensityDistribution = IfcLightIntensityDistribution

var IfcLightSource = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
  }
  IfcLightSource.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity)
  }
  IfcLightSource.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLightSource
}())
exports.IfcLightSource = IfcLightSource

var IfcLightSourceAmbient = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
  }
  IfcLightSourceAmbient.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity)
  }
  IfcLightSourceAmbient.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLightSourceAmbient
}())
exports.IfcLightSourceAmbient = IfcLightSourceAmbient

var IfcLightSourceDirectional = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
    this.Orientation = Orientation
  }
  IfcLightSourceDirectional.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    let Orientation
    Orientation = tape[4]
    return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation)
  }
  IfcLightSourceDirectional.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Orientation)
    return args
  }
  return IfcLightSourceDirectional
}())
exports.IfcLightSourceDirectional = IfcLightSourceDirectional

var IfcLightSourceGoniometric = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
    this.Position = Position
    this.ColourAppearance = ColourAppearance
    this.ColourTemperature = ColourTemperature
    this.LuminousFlux = LuminousFlux
    this.LightEmissionSource = LightEmissionSource
    this.LightDistributionDataSource = LightDistributionDataSource
  }
  IfcLightSourceGoniometric.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    let Position
    Position = tape[4]
    let ColourAppearance
    if (tape[5]) {
      ColourAppearance = tape[5]
    } else {
      ColourAppearance = null
    }
    let ColourTemperature
    ColourTemperature = tape[6]
    let LuminousFlux
    LuminousFlux = tape[7]
    let LightEmissionSource
    LightEmissionSource = new IfcLightEmissionSourceEnum(tape[8])
    let LightDistributionDataSource
    LightDistributionDataSource = ParseType(tape[9], tape[10][0])
    return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource)
  }
  IfcLightSourceGoniometric.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Position)
    if (this.ColourAppearance) {
      args.push(REF)
      args.push(this.ColourAppearance)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.ColourTemperature)
    args.push(REAL)
    args.push(this.LuminousFlux)
    args.push(ENUM)
    args.push(this.LightEmissionSource.value)
    return args
  }
  return IfcLightSourceGoniometric
}())
exports.IfcLightSourceGoniometric = IfcLightSourceGoniometric

var IfcLightSourcePositional = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
    this.Position = Position
    this.Radius = Radius
    this.ConstantAttenuation = ConstantAttenuation
    this.DistanceAttenuation = DistanceAttenuation
    this.QuadricAttenuation = QuadricAttenuation
  }
  IfcLightSourcePositional.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    let Position
    Position = tape[4]
    let Radius
    Radius = tape[5]
    let ConstantAttenuation
    ConstantAttenuation = tape[6]
    let DistanceAttenuation
    DistanceAttenuation = tape[7]
    let QuadricAttenuation
    QuadricAttenuation = tape[8]
    return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation)
  }
  IfcLightSourcePositional.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Position)
    args.push(REAL)
    args.push(this.ConstantAttenuation)
    args.push(REAL)
    args.push(this.DistanceAttenuation)
    args.push(REAL)
    args.push(this.QuadricAttenuation)
    return args
  }
  return IfcLightSourcePositional
}())
exports.IfcLightSourcePositional = IfcLightSourcePositional

var IfcLightSourceSpot = /** @class */ (function() {
  /**
   *
   */
  function IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LightColour = LightColour
    this.AmbientIntensity = AmbientIntensity
    this.Intensity = Intensity
    this.Position = Position
    this.Radius = Radius
    this.ConstantAttenuation = ConstantAttenuation
    this.DistanceAttenuation = DistanceAttenuation
    this.QuadricAttenuation = QuadricAttenuation
    this.Orientation = Orientation
    this.ConcentrationExponent = ConcentrationExponent
    this.SpreadAngle = SpreadAngle
    this.BeamWidthAngle = BeamWidthAngle
  }
  IfcLightSourceSpot.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LightColour
    LightColour = tape[1]
    let AmbientIntensity
    if (tape[2]) {
      AmbientIntensity = tape[2]
    } else {
      AmbientIntensity = null
    }
    let Intensity
    if (tape[3]) {
      Intensity = tape[3]
    } else {
      Intensity = null
    }
    let Position
    Position = tape[4]
    let Radius
    Radius = tape[5]
    let ConstantAttenuation
    ConstantAttenuation = tape[6]
    let DistanceAttenuation
    DistanceAttenuation = tape[7]
    let QuadricAttenuation
    QuadricAttenuation = tape[8]
    let Orientation
    Orientation = tape[9]
    let ConcentrationExponent
    if (tape[10]) {
      ConcentrationExponent = tape[10]
    } else {
      ConcentrationExponent = null
    }
    let SpreadAngle
    SpreadAngle = tape[11]
    let BeamWidthAngle
    BeamWidthAngle = tape[12]
    return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle)
  }
  IfcLightSourceSpot.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.LightColour)
    if (this.AmbientIntensity) {
    } else {
      args.push(EMPTY)
    }
    if (this.Intensity) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Position)
    args.push(REAL)
    args.push(this.ConstantAttenuation)
    args.push(REAL)
    args.push(this.DistanceAttenuation)
    args.push(REAL)
    args.push(this.QuadricAttenuation)
    args.push(REF)
    args.push(this.Orientation)
    if (this.ConcentrationExponent) {
      args.push(REAL)
      args.push(this.ConcentrationExponent)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLightSourceSpot
}())
exports.IfcLightSourceSpot = IfcLightSourceSpot

var IfcLine = /** @class */ (function() {
  /**
   *
   */
  function IfcLine(expressID, type, Pnt, Dir) {
    this.expressID = expressID
    this.type = type
    this.Pnt = Pnt
    this.Dir = Dir
  }
  IfcLine.FromTape = function(expressID, type, tape) {
    let Pnt
    Pnt = tape[0]
    let Dir
    Dir = tape[1]
    return new IfcLine(expressID, type, Pnt, Dir)
  }
  IfcLine.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Pnt)
    args.push(REF)
    args.push(this.Dir)
    return args
  }
  return IfcLine
}())
exports.IfcLine = IfcLine

var IfcLineSegment2D = /** @class */ (function() {
  /**
   *
   */
  function IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID
    this.type = type
    this.StartPoint = StartPoint
    this.StartDirection = StartDirection
    this.SegmentLength = SegmentLength
  }
  IfcLineSegment2D.FromTape = function(expressID, type, tape) {
    let StartPoint
    StartPoint = tape[0]
    let StartDirection
    StartDirection = tape[1]
    let SegmentLength
    SegmentLength = tape[2]
    return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength)
  }
  IfcLineSegment2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.StartPoint)
    args.push(REAL)
    args.push(this.StartDirection)
    return args
  }
  return IfcLineSegment2D
}())
exports.IfcLineSegment2D = IfcLineSegment2D

var IfcLinearPlacement = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
    this.expressID = expressID
    this.type = type
    this.PlacementRelTo = PlacementRelTo
    this.PlacementMeasuredAlong = PlacementMeasuredAlong
    this.Distance = Distance
    this.Orientation = Orientation
    this.CartesianPosition = CartesianPosition
  }
  IfcLinearPlacement.FromTape = function(expressID, type, tape) {
    let PlacementRelTo
    if (tape[0]) {
      PlacementRelTo = tape[0]
    } else {
      PlacementRelTo = null
    }
    let PlacementMeasuredAlong
    PlacementMeasuredAlong = tape[1]
    let Distance
    Distance = tape[2]
    let Orientation
    if (tape[3]) {
      Orientation = tape[3]
    } else {
      Orientation = null
    }
    let CartesianPosition
    if (tape[4]) {
      CartesianPosition = tape[4]
    } else {
      CartesianPosition = null
    }
    return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition)
  }
  IfcLinearPlacement.prototype.ToTape = function() {
    const args = []
    if (this.PlacementRelTo) {
      args.push(REF)
      args.push(this.PlacementRelTo)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.PlacementMeasuredAlong)
    args.push(REF)
    args.push(this.Distance)
    if (this.Orientation) {
      args.push(REF)
      args.push(this.Orientation)
    } else {
      args.push(EMPTY)
    }
    if (this.CartesianPosition) {
      args.push(REF)
      args.push(this.CartesianPosition)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLinearPlacement
}())
exports.IfcLinearPlacement = IfcLinearPlacement

var IfcLinearPositioningElement = /** @class */ (function() {
  /**
   *
   */
  function IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Axis = Axis
  }
  IfcLinearPositioningElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Axis
    Axis = tape[7]
    return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis)
  }
  IfcLinearPositioningElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Axis)
    return args
  }
  return IfcLinearPositioningElement
}())
exports.IfcLinearPositioningElement = IfcLinearPositioningElement

var IfcLocalPlacement = /** @class */ (function() {
  /**
   *
   */
  function IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement) {
    this.expressID = expressID
    this.type = type
    this.PlacementRelTo = PlacementRelTo
    this.RelativePlacement = RelativePlacement
  }
  IfcLocalPlacement.FromTape = function(expressID, type, tape) {
    let PlacementRelTo
    if (tape[0]) {
      PlacementRelTo = tape[0]
    } else {
      PlacementRelTo = null
    }
    let RelativePlacement
    RelativePlacement = ParseType(tape[1], tape[2][0])
    return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement)
  }
  IfcLocalPlacement.prototype.ToTape = function() {
    const args = []
    if (this.PlacementRelTo) {
      args.push(REF)
      args.push(this.PlacementRelTo)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcLocalPlacement
}())
exports.IfcLocalPlacement = IfcLocalPlacement

var IfcLoop = /** @class */ (function() {
  /**
   *
   */
  function IfcLoop(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcLoop.FromTape = function(expressID, type, tape) {
    return new IfcLoop(expressID, type)
  }
  IfcLoop.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcLoop
}())
exports.IfcLoop = IfcLoop

var IfcManifoldSolidBrep = /** @class */ (function() {
  /**
   *
   */
  function IfcManifoldSolidBrep(expressID, type, Outer) {
    this.expressID = expressID
    this.type = type
    this.Outer = Outer
  }
  IfcManifoldSolidBrep.FromTape = function(expressID, type, tape) {
    let Outer
    Outer = tape[0]
    return new IfcManifoldSolidBrep(expressID, type, Outer)
  }
  IfcManifoldSolidBrep.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Outer)
    return args
  }
  return IfcManifoldSolidBrep
}())
exports.IfcManifoldSolidBrep = IfcManifoldSolidBrep

var IfcMapConversion = /** @class */ (function() {
  /**
   *
   */
  function IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
    this.expressID = expressID
    this.type = type
    this.SourceCRS = SourceCRS
    this.TargetCRS = TargetCRS
    this.Eastings = Eastings
    this.Northings = Northings
    this.OrthogonalHeight = OrthogonalHeight
    this.XAxisAbscissa = XAxisAbscissa
    this.XAxisOrdinate = XAxisOrdinate
    this.Scale = Scale
  }
  IfcMapConversion.FromTape = function(expressID, type, tape) {
    let SourceCRS
    SourceCRS = ParseType(tape[0], tape[1][0])
    let TargetCRS
    TargetCRS = tape[1]
    let Eastings
    Eastings = tape[2]
    let Northings
    Northings = tape[3]
    let OrthogonalHeight
    OrthogonalHeight = tape[4]
    let XAxisAbscissa
    if (tape[5]) {
      XAxisAbscissa = tape[5]
    } else {
      XAxisAbscissa = null
    }
    let XAxisOrdinate
    if (tape[6]) {
      XAxisOrdinate = tape[6]
    } else {
      XAxisOrdinate = null
    }
    let Scale
    if (tape[7]) {
      Scale = tape[7]
    } else {
      Scale = null
    }
    return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale)
  }
  IfcMapConversion.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.TargetCRS)
    args.push(REAL)
    args.push(this.Eastings)
    args.push(REAL)
    args.push(this.Northings)
    args.push(REAL)
    args.push(this.OrthogonalHeight)
    if (this.XAxisAbscissa) {
      args.push(REAL)
      args.push(this.XAxisAbscissa)
    } else {
      args.push(EMPTY)
    }
    if (this.XAxisOrdinate) {
      args.push(REAL)
      args.push(this.XAxisOrdinate)
    } else {
      args.push(EMPTY)
    }
    if (this.Scale) {
      args.push(REAL)
      args.push(this.Scale)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMapConversion
}())
exports.IfcMapConversion = IfcMapConversion

var IfcMappedItem = /** @class */ (function() {
  /**
   *
   */
  function IfcMappedItem(expressID, type, MappingSource, MappingTarget) {
    this.expressID = expressID
    this.type = type
    this.MappingSource = MappingSource
    this.MappingTarget = MappingTarget
  }
  IfcMappedItem.FromTape = function(expressID, type, tape) {
    let MappingSource
    MappingSource = tape[0]
    let MappingTarget
    MappingTarget = tape[1]
    return new IfcMappedItem(expressID, type, MappingSource, MappingTarget)
  }
  IfcMappedItem.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.MappingSource)
    args.push(REF)
    args.push(this.MappingTarget)
    return args
  }
  return IfcMappedItem
}())
exports.IfcMappedItem = IfcMappedItem

var IfcMaterial = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterial(expressID, type, Name, Description, Category) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Category = Category
  }
  IfcMaterial.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Category
    if (tape[2]) {
      Category = tape[2]
    } else {
      Category = null
    }
    return new IfcMaterial(expressID, type, Name, Description, Category)
  }
  IfcMaterial.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterial
}())
exports.IfcMaterial = IfcMaterial

var IfcMaterialClassificationRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial) {
    this.expressID = expressID
    this.type = type
    this.MaterialClassifications = MaterialClassifications
    this.ClassifiedMaterial = ClassifiedMaterial
  }
  IfcMaterialClassificationRelationship.FromTape = function(expressID, type, tape) {
    let MaterialClassifications
    MaterialClassifications = []
    let MaterialClassifications_index = 0
    while (MaterialClassifications_index < tape[0].length) {
      MaterialClassifications.push(ParseType(tape[0][MaterialClassifications_index++], tape[0][MaterialClassifications_index++][0]))
    }
    let ClassifiedMaterial
    ClassifiedMaterial = tape[1]
    return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial)
  }
  IfcMaterialClassificationRelationship.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ClassifiedMaterial)
    return args
  }
  return IfcMaterialClassificationRelationship
}())
exports.IfcMaterialClassificationRelationship = IfcMaterialClassificationRelationship

var IfcMaterialConstituent = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Material = Material
    this.Fraction = Fraction
    this.Category = Category
  }
  IfcMaterialConstituent.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Material
    Material = tape[2]
    let Fraction
    if (tape[3]) {
      Fraction = tape[3]
    } else {
      Fraction = null
    }
    let Category
    if (tape[4]) {
      Category = tape[4]
    } else {
      Category = null
    }
    return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category)
  }
  IfcMaterialConstituent.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Material)
    if (this.Fraction) {
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialConstituent
}())
exports.IfcMaterialConstituent = IfcMaterialConstituent

var IfcMaterialConstituentSet = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.MaterialConstituents = MaterialConstituents
  }
  IfcMaterialConstituentSet.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let MaterialConstituents
    if (tape[2]) {
      MaterialConstituents = []
      let MaterialConstituents_index = 0
      while (MaterialConstituents_index < tape[2].length) {
        MaterialConstituents.push(tape[2][MaterialConstituents_index++])
      }
    } else {
      MaterialConstituents = null
    }
    return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents)
  }
  IfcMaterialConstituentSet.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.MaterialConstituents) {
      args.push(SET_BEGIN)
      this.MaterialConstituents.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialConstituentSet
}())
exports.IfcMaterialConstituentSet = IfcMaterialConstituentSet

var IfcMaterialDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialDefinition(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcMaterialDefinition.FromTape = function(expressID, type, tape) {
    return new IfcMaterialDefinition(expressID, type)
  }
  IfcMaterialDefinition.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcMaterialDefinition
}())
exports.IfcMaterialDefinition = IfcMaterialDefinition

var IfcMaterialDefinitionRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Representations = Representations
    this.RepresentedMaterial = RepresentedMaterial
  }
  IfcMaterialDefinitionRepresentation.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Representations
    Representations = []
    let Representations_index = 0
    while (Representations_index < tape[2].length) {
      Representations.push(tape[2][Representations_index++])
    }
    let RepresentedMaterial
    RepresentedMaterial = tape[3]
    return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial)
  }
  IfcMaterialDefinitionRepresentation.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Representations.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RepresentedMaterial)
    return args
  }
  return IfcMaterialDefinitionRepresentation
}())
exports.IfcMaterialDefinitionRepresentation = IfcMaterialDefinitionRepresentation

var IfcMaterialLayer = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
    this.expressID = expressID
    this.type = type
    this.Material = Material
    this.LayerThickness = LayerThickness
    this.IsVentilated = IsVentilated
    this.Name = Name
    this.Description = Description
    this.Category = Category
    this.Priority = Priority
  }
  IfcMaterialLayer.FromTape = function(expressID, type, tape) {
    let Material
    if (tape[0]) {
      Material = tape[0]
    } else {
      Material = null
    }
    let LayerThickness
    LayerThickness = tape[1]
    let IsVentilated
    if (tape[2]) {
      IsVentilated = tape[2]
    } else {
      IsVentilated = null
    }
    let Name
    if (tape[3]) {
      Name = tape[3]
    } else {
      Name = null
    }
    let Description
    if (tape[4]) {
      Description = tape[4]
    } else {
      Description = null
    }
    let Category
    if (tape[5]) {
      Category = tape[5]
    } else {
      Category = null
    }
    let Priority
    if (tape[6]) {
      Priority = tape[6]
    } else {
      Priority = null
    }
    return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority)
  }
  IfcMaterialLayer.prototype.ToTape = function() {
    const args = []
    if (this.Material) {
      args.push(REF)
      args.push(this.Material)
    } else {
      args.push(EMPTY)
    }
    if (this.IsVentilated) {
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    if (this.Priority) {
      args.push(REAL)
      args.push(this.Priority)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialLayer
}())
exports.IfcMaterialLayer = IfcMaterialLayer

var IfcMaterialLayerSet = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description) {
    this.expressID = expressID
    this.type = type
    this.MaterialLayers = MaterialLayers
    this.LayerSetName = LayerSetName
    this.Description = Description
  }
  IfcMaterialLayerSet.FromTape = function(expressID, type, tape) {
    let MaterialLayers
    MaterialLayers = []
    let MaterialLayers_index = 0
    while (MaterialLayers_index < tape[0].length) {
      MaterialLayers.push(tape[0][MaterialLayers_index++])
    }
    let LayerSetName
    if (tape[1]) {
      LayerSetName = tape[1]
    } else {
      LayerSetName = null
    }
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description)
  }
  IfcMaterialLayerSet.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.MaterialLayers.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.LayerSetName) {
      args.push(STRING)
      args.push(this.LayerSetName)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialLayerSet
}())
exports.IfcMaterialLayerSet = IfcMaterialLayerSet

var IfcMaterialLayerSetUsage = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
    this.expressID = expressID
    this.type = type
    this.ForLayerSet = ForLayerSet
    this.LayerSetDirection = LayerSetDirection
    this.DirectionSense = DirectionSense
    this.OffsetFromReferenceLine = OffsetFromReferenceLine
    this.ReferenceExtent = ReferenceExtent
  }
  IfcMaterialLayerSetUsage.FromTape = function(expressID, type, tape) {
    let ForLayerSet
    ForLayerSet = tape[0]
    let LayerSetDirection
    LayerSetDirection = new IfcLayerSetDirectionEnum(tape[1])
    let DirectionSense
    DirectionSense = new IfcDirectionSenseEnum(tape[2])
    let OffsetFromReferenceLine
    OffsetFromReferenceLine = tape[3]
    let ReferenceExtent
    if (tape[4]) {
      ReferenceExtent = tape[4]
    } else {
      ReferenceExtent = null
    }
    return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent)
  }
  IfcMaterialLayerSetUsage.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ForLayerSet)
    args.push(ENUM)
    args.push(this.LayerSetDirection.value)
    args.push(ENUM)
    args.push(this.DirectionSense.value)
    args.push(REAL)
    args.push(this.OffsetFromReferenceLine)
    if (this.ReferenceExtent) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialLayerSetUsage
}())
exports.IfcMaterialLayerSetUsage = IfcMaterialLayerSetUsage

var IfcMaterialLayerWithOffsets = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
    this.expressID = expressID
    this.type = type
    this.Material = Material
    this.LayerThickness = LayerThickness
    this.IsVentilated = IsVentilated
    this.Name = Name
    this.Description = Description
    this.Category = Category
    this.Priority = Priority
    this.OffsetDirection = OffsetDirection
    this.OffsetValues = OffsetValues
  }
  IfcMaterialLayerWithOffsets.FromTape = function(expressID, type, tape) {
    let Material
    if (tape[0]) {
      Material = tape[0]
    } else {
      Material = null
    }
    let LayerThickness
    LayerThickness = tape[1]
    let IsVentilated
    if (tape[2]) {
      IsVentilated = tape[2]
    } else {
      IsVentilated = null
    }
    let Name
    if (tape[3]) {
      Name = tape[3]
    } else {
      Name = null
    }
    let Description
    if (tape[4]) {
      Description = tape[4]
    } else {
      Description = null
    }
    let Category
    if (tape[5]) {
      Category = tape[5]
    } else {
      Category = null
    }
    let Priority
    if (tape[6]) {
      Priority = tape[6]
    } else {
      Priority = null
    }
    let OffsetDirection
    OffsetDirection = new IfcLayerSetDirectionEnum(tape[7])
    let OffsetValues
    OffsetValues = tape[8]
    return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues)
  }
  IfcMaterialLayerWithOffsets.prototype.ToTape = function() {
    const args = []
    if (this.Material) {
      args.push(REF)
      args.push(this.Material)
    } else {
      args.push(EMPTY)
    }
    if (this.IsVentilated) {
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    if (this.Priority) {
      args.push(REAL)
      args.push(this.Priority)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.OffsetDirection.value)
    args.push(REAL)
    args.push(this.OffsetValues)
    return args
  }
  return IfcMaterialLayerWithOffsets
}())
exports.IfcMaterialLayerWithOffsets = IfcMaterialLayerWithOffsets

var IfcMaterialList = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialList(expressID, type, Materials) {
    this.expressID = expressID
    this.type = type
    this.Materials = Materials
  }
  IfcMaterialList.FromTape = function(expressID, type, tape) {
    let Materials
    Materials = []
    let Materials_index = 0
    while (Materials_index < tape[0].length) {
      Materials.push(tape[0][Materials_index++])
    }
    return new IfcMaterialList(expressID, type, Materials)
  }
  IfcMaterialList.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Materials.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcMaterialList
}())
exports.IfcMaterialList = IfcMaterialList

var IfcMaterialProfile = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Material = Material
    this.Profile = Profile
    this.Priority = Priority
    this.Category = Category
  }
  IfcMaterialProfile.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Material
    if (tape[2]) {
      Material = tape[2]
    } else {
      Material = null
    }
    let Profile
    Profile = tape[3]
    let Priority
    if (tape[4]) {
      Priority = tape[4]
    } else {
      Priority = null
    }
    let Category
    if (tape[5]) {
      Category = tape[5]
    } else {
      Category = null
    }
    return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category)
  }
  IfcMaterialProfile.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Material) {
      args.push(REF)
      args.push(this.Material)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Profile)
    if (this.Priority) {
      args.push(REAL)
      args.push(this.Priority)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialProfile
}())
exports.IfcMaterialProfile = IfcMaterialProfile

var IfcMaterialProfileSet = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.MaterialProfiles = MaterialProfiles
    this.CompositeProfile = CompositeProfile
  }
  IfcMaterialProfileSet.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let MaterialProfiles
    MaterialProfiles = []
    let MaterialProfiles_index = 0
    while (MaterialProfiles_index < tape[2].length) {
      MaterialProfiles.push(tape[2][MaterialProfiles_index++])
    }
    let CompositeProfile
    if (tape[3]) {
      CompositeProfile = tape[3]
    } else {
      CompositeProfile = null
    }
    return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile)
  }
  IfcMaterialProfileSet.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.MaterialProfiles.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.CompositeProfile) {
      args.push(REF)
      args.push(this.CompositeProfile)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialProfileSet
}())
exports.IfcMaterialProfileSet = IfcMaterialProfileSet

var IfcMaterialProfileSetUsage = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
    this.expressID = expressID
    this.type = type
    this.ForProfileSet = ForProfileSet
    this.CardinalPoint = CardinalPoint
    this.ReferenceExtent = ReferenceExtent
  }
  IfcMaterialProfileSetUsage.FromTape = function(expressID, type, tape) {
    let ForProfileSet
    ForProfileSet = tape[0]
    let CardinalPoint
    if (tape[1]) {
      CardinalPoint = tape[1]
    } else {
      CardinalPoint = null
    }
    let ReferenceExtent
    if (tape[2]) {
      ReferenceExtent = tape[2]
    } else {
      ReferenceExtent = null
    }
    return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent)
  }
  IfcMaterialProfileSetUsage.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ForProfileSet)
    if (this.CardinalPoint) {
      args.push(REAL)
      args.push(this.CardinalPoint)
    } else {
      args.push(EMPTY)
    }
    if (this.ReferenceExtent) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialProfileSetUsage
}())
exports.IfcMaterialProfileSetUsage = IfcMaterialProfileSetUsage

var IfcMaterialProfileSetUsageTapering = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
    this.expressID = expressID
    this.type = type
    this.ForProfileSet = ForProfileSet
    this.CardinalPoint = CardinalPoint
    this.ReferenceExtent = ReferenceExtent
    this.ForProfileEndSet = ForProfileEndSet
    this.CardinalEndPoint = CardinalEndPoint
  }
  IfcMaterialProfileSetUsageTapering.FromTape = function(expressID, type, tape) {
    let ForProfileSet
    ForProfileSet = tape[0]
    let CardinalPoint
    if (tape[1]) {
      CardinalPoint = tape[1]
    } else {
      CardinalPoint = null
    }
    let ReferenceExtent
    if (tape[2]) {
      ReferenceExtent = tape[2]
    } else {
      ReferenceExtent = null
    }
    let ForProfileEndSet
    ForProfileEndSet = tape[3]
    let CardinalEndPoint
    if (tape[4]) {
      CardinalEndPoint = tape[4]
    } else {
      CardinalEndPoint = null
    }
    return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint)
  }
  IfcMaterialProfileSetUsageTapering.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ForProfileSet)
    if (this.CardinalPoint) {
      args.push(REAL)
      args.push(this.CardinalPoint)
    } else {
      args.push(EMPTY)
    }
    if (this.ReferenceExtent) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ForProfileEndSet)
    if (this.CardinalEndPoint) {
      args.push(REAL)
      args.push(this.CardinalEndPoint)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialProfileSetUsageTapering
}())
exports.IfcMaterialProfileSetUsageTapering = IfcMaterialProfileSetUsageTapering

var IfcMaterialProfileWithOffsets = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Material = Material
    this.Profile = Profile
    this.Priority = Priority
    this.Category = Category
    this.OffsetValues = OffsetValues
  }
  IfcMaterialProfileWithOffsets.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Material
    if (tape[2]) {
      Material = tape[2]
    } else {
      Material = null
    }
    let Profile
    Profile = tape[3]
    let Priority
    if (tape[4]) {
      Priority = tape[4]
    } else {
      Priority = null
    }
    let Category
    if (tape[5]) {
      Category = tape[5]
    } else {
      Category = null
    }
    let OffsetValues
    OffsetValues = tape[6]
    return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues)
  }
  IfcMaterialProfileWithOffsets.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Material) {
      args.push(REF)
      args.push(this.Material)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Profile)
    if (this.Priority) {
      args.push(REAL)
      args.push(this.Priority)
    } else {
      args.push(EMPTY)
    }
    if (this.Category) {
      args.push(STRING)
      args.push(this.Category)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.OffsetValues)
    return args
  }
  return IfcMaterialProfileWithOffsets
}())
exports.IfcMaterialProfileWithOffsets = IfcMaterialProfileWithOffsets

var IfcMaterialProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialProperties(expressID, type, Name, Description, Properties, Material) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Properties = Properties
    this.Material = Material
  }
  IfcMaterialProperties.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Properties
    Properties = []
    let Properties_index = 0
    while (Properties_index < tape[2].length) {
      Properties.push(tape[2][Properties_index++])
    }
    let Material
    Material = tape[3]
    return new IfcMaterialProperties(expressID, type, Name, Description, Properties, Material)
  }
  IfcMaterialProperties.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Properties.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.Material)
    return args
  }
  return IfcMaterialProperties
}())
exports.IfcMaterialProperties = IfcMaterialProperties

var IfcMaterialRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingMaterial = RelatingMaterial
    this.RelatedMaterials = RelatedMaterials
    this.Expression = Expression
  }
  IfcMaterialRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingMaterial
    RelatingMaterial = tape[2]
    let RelatedMaterials
    RelatedMaterials = []
    let RelatedMaterials_index = 0
    while (RelatedMaterials_index < tape[3].length) {
      RelatedMaterials.push(tape[3][RelatedMaterials_index++])
    }
    let Expression
    if (tape[4]) {
      Expression = tape[4]
    } else {
      Expression = null
    }
    return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression)
  }
  IfcMaterialRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingMaterial)
    args.push(SET_BEGIN)
    this.RelatedMaterials.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.Expression) {
      args.push(STRING)
      args.push(this.Expression)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMaterialRelationship
}())
exports.IfcMaterialRelationship = IfcMaterialRelationship

var IfcMaterialUsageDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcMaterialUsageDefinition(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcMaterialUsageDefinition.FromTape = function(expressID, type, tape) {
    return new IfcMaterialUsageDefinition(expressID, type)
  }
  IfcMaterialUsageDefinition.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcMaterialUsageDefinition
}())
exports.IfcMaterialUsageDefinition = IfcMaterialUsageDefinition

var IfcMeasureWithUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent) {
    this.expressID = expressID
    this.type = type
    this.ValueComponent = ValueComponent
    this.UnitComponent = UnitComponent
  }
  IfcMeasureWithUnit.FromTape = function(expressID, type, tape) {
    let ValueComponent
    ValueComponent = ParseType(tape[0], tape[1][0])
    let UnitComponent
    UnitComponent = ParseType(tape[1], tape[2][0])
    return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent)
  }
  IfcMeasureWithUnit.prototype.ToTape = function() {
    const args = []
    args.push(LABEL)
    // @ts-ignore
    args.push(this.ValueComponent.t)
    args.push(SET_BEGIN)
    // @ts-ignore
    args.push(typeof this.ValueComponent.v === 'string' ? STRING : REAL)
    // @ts-ignore
    args.push(this.ValueComponent.v)
    args.push(SET_END)
    return args
  }
  return IfcMeasureWithUnit
}())
exports.IfcMeasureWithUnit = IfcMeasureWithUnit

var IfcMechanicalFastener = /** @class */ (function() {
  /**
   *
   */
  function IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.NominalDiameter = NominalDiameter
    this.NominalLength = NominalLength
    this.PredefinedType = PredefinedType
  }
  IfcMechanicalFastener.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let NominalDiameter
    if (tape[8]) {
      NominalDiameter = tape[8]
    } else {
      NominalDiameter = null
    }
    let NominalLength
    if (tape[9]) {
      NominalLength = tape[9]
    } else {
      NominalLength = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcMechanicalFastenerTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType)
  }
  IfcMechanicalFastener.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.NominalLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMechanicalFastener
}())
exports.IfcMechanicalFastener = IfcMechanicalFastener

var IfcMechanicalFastenerType = /** @class */ (function() {
  /**
   *
   */
  function IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.NominalDiameter = NominalDiameter
    this.NominalLength = NominalLength
  }
  IfcMechanicalFastenerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcMechanicalFastenerTypeEnum(tape[9])
    let NominalDiameter
    if (tape[10]) {
      NominalDiameter = tape[10]
    } else {
      NominalDiameter = null
    }
    let NominalLength
    if (tape[11]) {
      NominalLength = tape[11]
    } else {
      NominalLength = null
    }
    return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength)
  }
  IfcMechanicalFastenerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.NominalLength) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMechanicalFastenerType
}())
exports.IfcMechanicalFastenerType = IfcMechanicalFastenerType

var IfcMedicalDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcMedicalDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcMedicalDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcMedicalDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMedicalDevice
}())
exports.IfcMedicalDevice = IfcMedicalDevice

var IfcMedicalDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcMedicalDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcMedicalDeviceTypeEnum(tape[9])
    return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcMedicalDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcMedicalDeviceType
}())
exports.IfcMedicalDeviceType = IfcMedicalDeviceType

var IfcMember = /** @class */ (function() {
  /**
   *
   */
  function IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcMember.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcMemberTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcMember.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMember
}())
exports.IfcMember = IfcMember

var IfcMemberStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcMemberStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcMemberTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcMemberStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMemberStandardCase
}())
exports.IfcMemberStandardCase = IfcMemberStandardCase

var IfcMemberType = /** @class */ (function() {
  /**
   *
   */
  function IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcMemberType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcMemberTypeEnum(tape[9])
    return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcMemberType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcMemberType
}())
exports.IfcMemberType = IfcMemberType

var IfcMetric = /** @class */ (function() {
  /**
   *
   */
  function IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.ConstraintGrade = ConstraintGrade
    this.ConstraintSource = ConstraintSource
    this.CreatingActor = CreatingActor
    this.CreationTime = CreationTime
    this.UserDefinedGrade = UserDefinedGrade
    this.Benchmark = Benchmark
    this.ValueSource = ValueSource
    this.DataValue = DataValue
    this.ReferencePath = ReferencePath
  }
  IfcMetric.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let ConstraintGrade
    ConstraintGrade = new IfcConstraintEnum(tape[2])
    let ConstraintSource
    if (tape[3]) {
      ConstraintSource = tape[3]
    } else {
      ConstraintSource = null
    }
    let CreatingActor
    if (tape[4]) {
      CreatingActor = ParseType(tape[4], tape[5][0])
    } else {
      CreatingActor = null
    }
    let CreationTime
    if (tape[5]) {
      CreationTime = tape[5]
    } else {
      CreationTime = null
    }
    let UserDefinedGrade
    if (tape[6]) {
      UserDefinedGrade = tape[6]
    } else {
      UserDefinedGrade = null
    }
    let Benchmark
    Benchmark = new IfcBenchmarkEnum(tape[7])
    let ValueSource
    if (tape[8]) {
      ValueSource = tape[8]
    } else {
      ValueSource = null
    }
    let DataValue
    if (tape[9]) {
      DataValue = ParseType(tape[9], tape[10][0])
    } else {
      DataValue = null
    }
    let ReferencePath
    if (tape[10]) {
      ReferencePath = tape[10]
    } else {
      ReferencePath = null
    }
    return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath)
  }
  IfcMetric.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ConstraintGrade.value)
    if (this.ConstraintSource) {
      args.push(STRING)
      args.push(this.ConstraintSource)
    } else {
      args.push(EMPTY)
    }
    if (this.CreatingActor) {
    } else {
      args.push(EMPTY)
    }
    if (this.CreationTime) {
      args.push(STRING)
      args.push(this.CreationTime)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedGrade) {
      args.push(STRING)
      args.push(this.UserDefinedGrade)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.Benchmark.value)
    if (this.ValueSource) {
      args.push(STRING)
      args.push(this.ValueSource)
    } else {
      args.push(EMPTY)
    }
    if (this.DataValue) {
    } else {
      args.push(EMPTY)
    }
    if (this.ReferencePath) {
      args.push(REF)
      args.push(this.ReferencePath)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMetric
}())
exports.IfcMetric = IfcMetric

var IfcMirroredProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.ParentProfile = ParentProfile
    this.Operator = Operator
    this.Label = Label
  }
  IfcMirroredProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let ParentProfile
    ParentProfile = tape[2]
    let Operator
    Operator = tape[3]
    let Label
    if (tape[4]) {
      Label = tape[4]
    } else {
      Label = null
    }
    return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label)
  }
  IfcMirroredProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ParentProfile)
    args.push(REF)
    args.push(this.Operator)
    if (this.Label) {
      args.push(STRING)
      args.push(this.Label)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMirroredProfileDef
}())
exports.IfcMirroredProfileDef = IfcMirroredProfileDef

var IfcMonetaryUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcMonetaryUnit(expressID, type, Currency) {
    this.expressID = expressID
    this.type = type
    this.Currency = Currency
  }
  IfcMonetaryUnit.FromTape = function(expressID, type, tape) {
    let Currency
    Currency = tape[0]
    return new IfcMonetaryUnit(expressID, type, Currency)
  }
  IfcMonetaryUnit.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Currency)
    return args
  }
  return IfcMonetaryUnit
}())
exports.IfcMonetaryUnit = IfcMonetaryUnit

var IfcMotorConnection = /** @class */ (function() {
  /**
   *
   */
  function IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcMotorConnection.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcMotorConnectionTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcMotorConnection.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcMotorConnection
}())
exports.IfcMotorConnection = IfcMotorConnection

var IfcMotorConnectionType = /** @class */ (function() {
  /**
   *
   */
  function IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcMotorConnectionType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcMotorConnectionTypeEnum(tape[9])
    return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcMotorConnectionType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcMotorConnectionType
}())
exports.IfcMotorConnectionType = IfcMotorConnectionType

var IfcNamedUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcNamedUnit(expressID, type, Dimensions, UnitType) {
    this.expressID = expressID
    this.type = type
    this.Dimensions = Dimensions
    this.UnitType = UnitType
  }
  IfcNamedUnit.FromTape = function(expressID, type, tape) {
    let Dimensions
    Dimensions = tape[0]
    let UnitType
    UnitType = new IfcUnitEnum(tape[1])
    return new IfcNamedUnit(expressID, type, Dimensions, UnitType)
  }
  IfcNamedUnit.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Dimensions)
    args.push(ENUM)
    args.push(this.UnitType.value)
    return args
  }
  return IfcNamedUnit
}())
exports.IfcNamedUnit = IfcNamedUnit

var IfcObject = /** @class */ (function() {
  /**
   *
   */
  function IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
  }
  IfcObject.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType)
  }
  IfcObject.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcObject
}())
exports.IfcObject = IfcObject

var IfcObjectDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcObjectDefinition.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcObjectDefinition.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcObjectDefinition
}())
exports.IfcObjectDefinition = IfcObjectDefinition

var IfcObjectPlacement = /** @class */ (function() {
  /**
   *
   */
  function IfcObjectPlacement(expressID, type, PlacementRelTo) {
    this.expressID = expressID
    this.type = type
    this.PlacementRelTo = PlacementRelTo
  }
  IfcObjectPlacement.FromTape = function(expressID, type, tape) {
    let PlacementRelTo
    if (tape[0]) {
      PlacementRelTo = tape[0]
    } else {
      PlacementRelTo = null
    }
    return new IfcObjectPlacement(expressID, type, PlacementRelTo)
  }
  IfcObjectPlacement.prototype.ToTape = function() {
    const args = []
    if (this.PlacementRelTo) {
      args.push(REF)
      args.push(this.PlacementRelTo)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcObjectPlacement
}())
exports.IfcObjectPlacement = IfcObjectPlacement

var IfcObjective = /** @class */ (function() {
  /**
   *
   */
  function IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.ConstraintGrade = ConstraintGrade
    this.ConstraintSource = ConstraintSource
    this.CreatingActor = CreatingActor
    this.CreationTime = CreationTime
    this.UserDefinedGrade = UserDefinedGrade
    this.BenchmarkValues = BenchmarkValues
    this.LogicalAggregator = LogicalAggregator
    this.ObjectiveQualifier = ObjectiveQualifier
    this.UserDefinedQualifier = UserDefinedQualifier
  }
  IfcObjective.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let ConstraintGrade
    ConstraintGrade = new IfcConstraintEnum(tape[2])
    let ConstraintSource
    if (tape[3]) {
      ConstraintSource = tape[3]
    } else {
      ConstraintSource = null
    }
    let CreatingActor
    if (tape[4]) {
      CreatingActor = ParseType(tape[4], tape[5][0])
    } else {
      CreatingActor = null
    }
    let CreationTime
    if (tape[5]) {
      CreationTime = tape[5]
    } else {
      CreationTime = null
    }
    let UserDefinedGrade
    if (tape[6]) {
      UserDefinedGrade = tape[6]
    } else {
      UserDefinedGrade = null
    }
    let BenchmarkValues
    if (tape[7]) {
      BenchmarkValues = []
      let BenchmarkValues_index = 0
      while (BenchmarkValues_index < tape[7].length) {
        BenchmarkValues.push(tape[7][BenchmarkValues_index++])
      }
    } else {
      BenchmarkValues = null
    }
    let LogicalAggregator
    if (tape[8]) {
      LogicalAggregator = new IfcLogicalOperatorEnum(tape[8])
    } else {
      LogicalAggregator = null
    }
    let ObjectiveQualifier
    ObjectiveQualifier = new IfcObjectiveEnum(tape[9])
    let UserDefinedQualifier
    if (tape[10]) {
      UserDefinedQualifier = tape[10]
    } else {
      UserDefinedQualifier = null
    }
    return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier)
  }
  IfcObjective.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ConstraintGrade.value)
    if (this.ConstraintSource) {
      args.push(STRING)
      args.push(this.ConstraintSource)
    } else {
      args.push(EMPTY)
    }
    if (this.CreatingActor) {
    } else {
      args.push(EMPTY)
    }
    if (this.CreationTime) {
      args.push(STRING)
      args.push(this.CreationTime)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedGrade) {
      args.push(STRING)
      args.push(this.UserDefinedGrade)
    } else {
      args.push(EMPTY)
    }
    if (this.BenchmarkValues) {
      args.push(SET_BEGIN)
      this.BenchmarkValues.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.LogicalAggregator) {
      args.push(ENUM)
      args.push(this.LogicalAggregator.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ObjectiveQualifier.value)
    if (this.UserDefinedQualifier) {
      args.push(STRING)
      args.push(this.UserDefinedQualifier)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcObjective
}())
exports.IfcObjective = IfcObjective

var IfcOccupant = /** @class */ (function() {
  /**
   *
   */
  function IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.TheActor = TheActor
    this.PredefinedType = PredefinedType
  }
  IfcOccupant.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let TheActor
    TheActor = ParseType(tape[5], tape[6][0])
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcOccupantTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType)
  }
  IfcOccupant.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOccupant
}())
exports.IfcOccupant = IfcOccupant

var IfcOffsetCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcOffsetCurve(expressID, type, BasisCurve) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
  }
  IfcOffsetCurve.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    return new IfcOffsetCurve(expressID, type, BasisCurve)
  }
  IfcOffsetCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    return args
  }
  return IfcOffsetCurve
}())
exports.IfcOffsetCurve = IfcOffsetCurve

var IfcOffsetCurve2D = /** @class */ (function() {
  /**
   *
   */
  function IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
    this.Distance = Distance
    this.SelfIntersect = SelfIntersect
  }
  IfcOffsetCurve2D.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    let Distance
    Distance = tape[1]
    let SelfIntersect
    SelfIntersect = tape[2]
    return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect)
  }
  IfcOffsetCurve2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    args.push(REAL)
    args.push(this.Distance)
    return args
  }
  return IfcOffsetCurve2D
}())
exports.IfcOffsetCurve2D = IfcOffsetCurve2D

var IfcOffsetCurve3D = /** @class */ (function() {
  /**
   *
   */
  function IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
    this.Distance = Distance
    this.SelfIntersect = SelfIntersect
    this.RefDirection = RefDirection
  }
  IfcOffsetCurve3D.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    let Distance
    Distance = tape[1]
    let SelfIntersect
    SelfIntersect = tape[2]
    let RefDirection
    RefDirection = tape[3]
    return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection)
  }
  IfcOffsetCurve3D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    args.push(REAL)
    args.push(this.Distance)
    args.push(REF)
    args.push(this.RefDirection)
    return args
  }
  return IfcOffsetCurve3D
}())
exports.IfcOffsetCurve3D = IfcOffsetCurve3D

var IfcOffsetCurveByDistances = /** @class */ (function() {
  /**
   *
   */
  function IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
    this.OffsetValues = OffsetValues
    this.Tag = Tag
  }
  IfcOffsetCurveByDistances.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    let OffsetValues
    OffsetValues = []
    let OffsetValues_index = 0
    while (OffsetValues_index < tape[1].length) {
      OffsetValues.push(tape[1][OffsetValues_index++])
    }
    let Tag
    if (tape[2]) {
      Tag = tape[2]
    } else {
      Tag = null
    }
    return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag)
  }
  IfcOffsetCurveByDistances.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    args.push(SET_BEGIN)
    this.OffsetValues.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOffsetCurveByDistances
}())
exports.IfcOffsetCurveByDistances = IfcOffsetCurveByDistances

var IfcOpenShell = /** @class */ (function() {
  /**
   *
   */
  function IfcOpenShell(expressID, type, CfsFaces) {
    this.expressID = expressID
    this.type = type
    this.CfsFaces = CfsFaces
  }
  IfcOpenShell.FromTape = function(expressID, type, tape) {
    let CfsFaces
    CfsFaces = []
    let CfsFaces_index = 0
    while (CfsFaces_index < tape[0].length) {
      CfsFaces.push(tape[0][CfsFaces_index++])
    }
    return new IfcOpenShell(expressID, type, CfsFaces)
  }
  IfcOpenShell.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.CfsFaces.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcOpenShell
}())
exports.IfcOpenShell = IfcOpenShell

var IfcOpeningElement = /** @class */ (function() {
  /**
   *
   */
  function IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcOpeningElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcOpeningElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcOpeningElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOpeningElement
}())
exports.IfcOpeningElement = IfcOpeningElement

var IfcOpeningStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcOpeningStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcOpeningElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcOpeningStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOpeningStandardCase
}())
exports.IfcOpeningStandardCase = IfcOpeningStandardCase

var IfcOrganization = /** @class */ (function() {
  /**
   *
   */
  function IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses) {
    this.expressID = expressID
    this.type = type
    this.Identification = Identification
    this.Name = Name
    this.Description = Description
    this.Roles = Roles
    this.Addresses = Addresses
  }
  IfcOrganization.FromTape = function(expressID, type, tape) {
    let Identification
    if (tape[0]) {
      Identification = tape[0]
    } else {
      Identification = null
    }
    let Name
    Name = tape[1]
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    let Roles
    if (tape[3]) {
      Roles = []
      let Roles_index = 0
      while (Roles_index < tape[3].length) {
        Roles.push(tape[3][Roles_index++])
      }
    } else {
      Roles = null
    }
    let Addresses
    if (tape[4]) {
      Addresses = []
      let Addresses_index = 0
      while (Addresses_index < tape[4].length) {
        Addresses.push(tape[4][Addresses_index++])
      }
    } else {
      Addresses = null
    }
    return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses)
  }
  IfcOrganization.prototype.ToTape = function() {
    const args = []
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Roles) {
      args.push(SET_BEGIN)
      this.Roles.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Addresses) {
      args.push(SET_BEGIN)
      this.Addresses.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOrganization
}())
exports.IfcOrganization = IfcOrganization

var IfcOrganizationRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingOrganization = RelatingOrganization
    this.RelatedOrganizations = RelatedOrganizations
  }
  IfcOrganizationRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingOrganization
    RelatingOrganization = tape[2]
    let RelatedOrganizations
    RelatedOrganizations = []
    let RelatedOrganizations_index = 0
    while (RelatedOrganizations_index < tape[3].length) {
      RelatedOrganizations.push(tape[3][RelatedOrganizations_index++])
    }
    return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations)
  }
  IfcOrganizationRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingOrganization)
    args.push(SET_BEGIN)
    this.RelatedOrganizations.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcOrganizationRelationship
}())
exports.IfcOrganizationRelationship = IfcOrganizationRelationship

var IfcOrientationExpression = /** @class */ (function() {
  /**
   *
   */
  function IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
    this.expressID = expressID
    this.type = type
    this.LateralAxisDirection = LateralAxisDirection
    this.VerticalAxisDirection = VerticalAxisDirection
  }
  IfcOrientationExpression.FromTape = function(expressID, type, tape) {
    let LateralAxisDirection
    LateralAxisDirection = tape[0]
    let VerticalAxisDirection
    VerticalAxisDirection = tape[1]
    return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection)
  }
  IfcOrientationExpression.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.LateralAxisDirection)
    args.push(REF)
    args.push(this.VerticalAxisDirection)
    return args
  }
  return IfcOrientationExpression
}())
exports.IfcOrientationExpression = IfcOrientationExpression

var IfcOrientedEdge = /** @class */ (function() {
  /**
   *
   */
  function IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
    this.expressID = expressID
    this.type = type
    this.EdgeStart = EdgeStart
    this.EdgeEnd = EdgeEnd
    this.EdgeElement = EdgeElement
    this.Orientation = Orientation
  }
  IfcOrientedEdge.FromTape = function(expressID, type, tape) {
    let EdgeStart
    EdgeStart = tape[0]
    let EdgeEnd
    EdgeEnd = tape[1]
    let EdgeElement
    EdgeElement = tape[2]
    let Orientation
    Orientation = tape[3]
    return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation)
  }
  IfcOrientedEdge.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.EdgeStart)
    args.push(REF)
    args.push(this.EdgeEnd)
    args.push(REF)
    args.push(this.EdgeElement)
    return args
  }
  return IfcOrientedEdge
}())
exports.IfcOrientedEdge = IfcOrientedEdge

var IfcOuterBoundaryCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID
    this.type = type
    this.Segments = Segments
    this.SelfIntersect = SelfIntersect
  }
  IfcOuterBoundaryCurve.FromTape = function(expressID, type, tape) {
    let Segments
    Segments = []
    let Segments_index = 0
    while (Segments_index < tape[0].length) {
      Segments.push(tape[0][Segments_index++])
    }
    let SelfIntersect
    SelfIntersect = tape[1]
    return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect)
  }
  IfcOuterBoundaryCurve.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Segments.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcOuterBoundaryCurve
}())
exports.IfcOuterBoundaryCurve = IfcOuterBoundaryCurve

var IfcOutlet = /** @class */ (function() {
  /**
   *
   */
  function IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcOutlet.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcOutletTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcOutlet.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcOutlet
}())
exports.IfcOutlet = IfcOutlet

var IfcOutletType = /** @class */ (function() {
  /**
   *
   */
  function IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcOutletType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcOutletTypeEnum(tape[9])
    return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcOutletType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcOutletType
}())
exports.IfcOutletType = IfcOutletType

var IfcOwnerHistory = /** @class */ (function() {
  /**
   *
   */
  function IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
    this.expressID = expressID
    this.type = type
    this.OwningUser = OwningUser
    this.OwningApplication = OwningApplication
    this.State = State
    this.ChangeAction = ChangeAction
    this.LastModifiedDate = LastModifiedDate
    this.LastModifyingUser = LastModifyingUser
    this.LastModifyingApplication = LastModifyingApplication
    this.CreationDate = CreationDate
  }
  IfcOwnerHistory.FromTape = function(expressID, type, tape) {
    let OwningUser
    OwningUser = tape[0]
    let OwningApplication
    OwningApplication = tape[1]
    let State
    if (tape[2]) {
      State = new IfcStateEnum(tape[2])
    } else {
      State = null
    }
    let ChangeAction
    if (tape[3]) {
      ChangeAction = new IfcChangeActionEnum(tape[3])
    } else {
      ChangeAction = null
    }
    let LastModifiedDate
    if (tape[4]) {
      LastModifiedDate = tape[4]
    } else {
      LastModifiedDate = null
    }
    let LastModifyingUser
    if (tape[5]) {
      LastModifyingUser = tape[5]
    } else {
      LastModifyingUser = null
    }
    let LastModifyingApplication
    if (tape[6]) {
      LastModifyingApplication = tape[6]
    } else {
      LastModifyingApplication = null
    }
    let CreationDate
    CreationDate = tape[7]
    return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate)
  }
  IfcOwnerHistory.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.OwningUser)
    args.push(REF)
    args.push(this.OwningApplication)
    if (this.State) {
      args.push(ENUM)
      args.push(this.State.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ChangeAction) {
      args.push(ENUM)
      args.push(this.ChangeAction.value)
    } else {
      args.push(EMPTY)
    }
    if (this.LastModifiedDate) {
      args.push(REAL)
      args.push(this.LastModifiedDate)
    } else {
      args.push(EMPTY)
    }
    if (this.LastModifyingUser) {
      args.push(REF)
      args.push(this.LastModifyingUser)
    } else {
      args.push(EMPTY)
    }
    if (this.LastModifyingApplication) {
      args.push(REF)
      args.push(this.LastModifyingApplication)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.CreationDate)
    return args
  }
  return IfcOwnerHistory
}())
exports.IfcOwnerHistory = IfcOwnerHistory

var IfcParameterizedProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
  }
  IfcParameterizedProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position)
  }
  IfcParameterizedProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcParameterizedProfileDef
}())
exports.IfcParameterizedProfileDef = IfcParameterizedProfileDef

var IfcPath = /** @class */ (function() {
  /**
   *
   */
  function IfcPath(expressID, type, EdgeList) {
    this.expressID = expressID
    this.type = type
    this.EdgeList = EdgeList
  }
  IfcPath.FromTape = function(expressID, type, tape) {
    let EdgeList
    EdgeList = []
    let EdgeList_index = 0
    while (EdgeList_index < tape[0].length) {
      EdgeList.push(tape[0][EdgeList_index++])
    }
    return new IfcPath(expressID, type, EdgeList)
  }
  IfcPath.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.EdgeList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPath
}())
exports.IfcPath = IfcPath

var IfcPcurve = /** @class */ (function() {
  /**
   *
   */
  function IfcPcurve(expressID, type, BasisSurface, ReferenceCurve) {
    this.expressID = expressID
    this.type = type
    this.BasisSurface = BasisSurface
    this.ReferenceCurve = ReferenceCurve
  }
  IfcPcurve.FromTape = function(expressID, type, tape) {
    let BasisSurface
    BasisSurface = tape[0]
    let ReferenceCurve
    ReferenceCurve = tape[1]
    return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve)
  }
  IfcPcurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisSurface)
    args.push(REF)
    args.push(this.ReferenceCurve)
    return args
  }
  return IfcPcurve
}())
exports.IfcPcurve = IfcPcurve

var IfcPerformanceHistory = /** @class */ (function() {
  /**
   *
   */
  function IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LifeCyclePhase = LifeCyclePhase
    this.PredefinedType = PredefinedType
  }
  IfcPerformanceHistory.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LifeCyclePhase
    LifeCyclePhase = tape[6]
    let PredefinedType
    if (tape[7]) {
      PredefinedType = new IfcPerformanceHistoryTypeEnum(tape[7])
    } else {
      PredefinedType = null
    }
    return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType)
  }
  IfcPerformanceHistory.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.LifeCyclePhase)
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPerformanceHistory
}())
exports.IfcPerformanceHistory = IfcPerformanceHistory

var IfcPermeableCoveringProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.OperationType = OperationType
    this.PanelPosition = PanelPosition
    this.FrameDepth = FrameDepth
    this.FrameThickness = FrameThickness
    this.ShapeAspectStyle = ShapeAspectStyle
  }
  IfcPermeableCoveringProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let OperationType
    OperationType = new IfcPermeableCoveringOperationEnum(tape[4])
    let PanelPosition
    PanelPosition = new IfcWindowPanelPositionEnum(tape[5])
    let FrameDepth
    if (tape[6]) {
      FrameDepth = tape[6]
    } else {
      FrameDepth = null
    }
    let FrameThickness
    if (tape[7]) {
      FrameThickness = tape[7]
    } else {
      FrameThickness = null
    }
    let ShapeAspectStyle
    if (tape[8]) {
      ShapeAspectStyle = tape[8]
    } else {
      ShapeAspectStyle = null
    }
    return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle)
  }
  IfcPermeableCoveringProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.OperationType.value)
    args.push(ENUM)
    args.push(this.PanelPosition.value)
    if (this.FrameDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.FrameThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.ShapeAspectStyle) {
      args.push(REF)
      args.push(this.ShapeAspectStyle)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPermeableCoveringProperties
}())
exports.IfcPermeableCoveringProperties = IfcPermeableCoveringProperties

var IfcPermit = /** @class */ (function() {
  /**
   *
   */
  function IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.PredefinedType = PredefinedType
    this.Status = Status
    this.LongDescription = LongDescription
  }
  IfcPermit.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcPermitTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    let Status
    if (tape[7]) {
      Status = tape[7]
    } else {
      Status = null
    }
    let LongDescription
    if (tape[8]) {
      LongDescription = tape[8]
    } else {
      LongDescription = null
    }
    return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription)
  }
  IfcPermit.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPermit
}())
exports.IfcPermit = IfcPermit

var IfcPerson = /** @class */ (function() {
  /**
   *
   */
  function IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
    this.expressID = expressID
    this.type = type
    this.Identification = Identification
    this.FamilyName = FamilyName
    this.GivenName = GivenName
    this.MiddleNames = MiddleNames
    this.PrefixTitles = PrefixTitles
    this.SuffixTitles = SuffixTitles
    this.Roles = Roles
    this.Addresses = Addresses
  }
  IfcPerson.FromTape = function(expressID, type, tape) {
    let Identification
    if (tape[0]) {
      Identification = tape[0]
    } else {
      Identification = null
    }
    let FamilyName
    if (tape[1]) {
      FamilyName = tape[1]
    } else {
      FamilyName = null
    }
    let GivenName
    if (tape[2]) {
      GivenName = tape[2]
    } else {
      GivenName = null
    }
    let MiddleNames
    if (tape[3]) {
      MiddleNames = []
      let MiddleNames_index = 0
      while (MiddleNames_index < tape[3].length) {
        MiddleNames.push(tape[3][MiddleNames_index++])
      }
    } else {
      MiddleNames = null
    }
    let PrefixTitles
    if (tape[4]) {
      PrefixTitles = []
      let PrefixTitles_index = 0
      while (PrefixTitles_index < tape[4].length) {
        PrefixTitles.push(tape[4][PrefixTitles_index++])
      }
    } else {
      PrefixTitles = null
    }
    let SuffixTitles
    if (tape[5]) {
      SuffixTitles = []
      let SuffixTitles_index = 0
      while (SuffixTitles_index < tape[5].length) {
        SuffixTitles.push(tape[5][SuffixTitles_index++])
      }
    } else {
      SuffixTitles = null
    }
    let Roles
    if (tape[6]) {
      Roles = []
      let Roles_index = 0
      while (Roles_index < tape[6].length) {
        Roles.push(tape[6][Roles_index++])
      }
    } else {
      Roles = null
    }
    let Addresses
    if (tape[7]) {
      Addresses = []
      let Addresses_index = 0
      while (Addresses_index < tape[7].length) {
        Addresses.push(tape[7][Addresses_index++])
      }
    } else {
      Addresses = null
    }
    return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses)
  }
  IfcPerson.prototype.ToTape = function() {
    const args = []
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.FamilyName) {
      args.push(STRING)
      args.push(this.FamilyName)
    } else {
      args.push(EMPTY)
    }
    if (this.GivenName) {
      args.push(STRING)
      args.push(this.GivenName)
    } else {
      args.push(EMPTY)
    }
    if (this.MiddleNames) {
      args.push(STRING)
      args.push.apply(args, this.MiddleNames)
    } else {
      args.push(EMPTY)
    }
    if (this.PrefixTitles) {
      args.push(STRING)
      args.push.apply(args, this.PrefixTitles)
    } else {
      args.push(EMPTY)
    }
    if (this.SuffixTitles) {
      args.push(STRING)
      args.push.apply(args, this.SuffixTitles)
    } else {
      args.push(EMPTY)
    }
    if (this.Roles) {
      args.push(SET_BEGIN)
      this.Roles.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Addresses) {
      args.push(SET_BEGIN)
      this.Addresses.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPerson
}())
exports.IfcPerson = IfcPerson

var IfcPersonAndOrganization = /** @class */ (function() {
  /**
   *
   */
  function IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles) {
    this.expressID = expressID
    this.type = type
    this.ThePerson = ThePerson
    this.TheOrganization = TheOrganization
    this.Roles = Roles
  }
  IfcPersonAndOrganization.FromTape = function(expressID, type, tape) {
    let ThePerson
    ThePerson = tape[0]
    let TheOrganization
    TheOrganization = tape[1]
    let Roles
    if (tape[2]) {
      Roles = []
      let Roles_index = 0
      while (Roles_index < tape[2].length) {
        Roles.push(tape[2][Roles_index++])
      }
    } else {
      Roles = null
    }
    return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles)
  }
  IfcPersonAndOrganization.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ThePerson)
    args.push(REF)
    args.push(this.TheOrganization)
    if (this.Roles) {
      args.push(SET_BEGIN)
      this.Roles.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPersonAndOrganization
}())
exports.IfcPersonAndOrganization = IfcPersonAndOrganization

var IfcPhysicalComplexQuantity = /** @class */ (function() {
  /**
   *
   */
  function IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.HasQuantities = HasQuantities
    this.Discrimination = Discrimination
    this.Quality = Quality
    this.Usage = Usage
  }
  IfcPhysicalComplexQuantity.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let HasQuantities
    HasQuantities = []
    let HasQuantities_index = 0
    while (HasQuantities_index < tape[2].length) {
      HasQuantities.push(tape[2][HasQuantities_index++])
    }
    let Discrimination
    Discrimination = tape[3]
    let Quality
    if (tape[4]) {
      Quality = tape[4]
    } else {
      Quality = null
    }
    let Usage
    if (tape[5]) {
      Usage = tape[5]
    } else {
      Usage = null
    }
    return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage)
  }
  IfcPhysicalComplexQuantity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.HasQuantities.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(STRING)
    args.push(this.Discrimination)
    if (this.Quality) {
      args.push(STRING)
      args.push(this.Quality)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(STRING)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPhysicalComplexQuantity
}())
exports.IfcPhysicalComplexQuantity = IfcPhysicalComplexQuantity

var IfcPhysicalQuantity = /** @class */ (function() {
  /**
   *
   */
  function IfcPhysicalQuantity(expressID, type, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
  }
  IfcPhysicalQuantity.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    return new IfcPhysicalQuantity(expressID, type, Name, Description)
  }
  IfcPhysicalQuantity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPhysicalQuantity
}())
exports.IfcPhysicalQuantity = IfcPhysicalQuantity

var IfcPhysicalSimpleQuantity = /** @class */ (function() {
  /**
   *
   */
  function IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
  }
  IfcPhysicalSimpleQuantity.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit)
  }
  IfcPhysicalSimpleQuantity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPhysicalSimpleQuantity
}())
exports.IfcPhysicalSimpleQuantity = IfcPhysicalSimpleQuantity

var IfcPile = /** @class */ (function() {
  /**
   *
   */
  function IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
    this.ConstructionType = ConstructionType
  }
  IfcPile.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPileTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    let ConstructionType
    if (tape[9]) {
      ConstructionType = new IfcPileConstructionEnum(tape[9])
    } else {
      ConstructionType = null
    }
    return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType)
  }
  IfcPile.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ConstructionType) {
      args.push(ENUM)
      args.push(this.ConstructionType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPile
}())
exports.IfcPile = IfcPile

var IfcPileType = /** @class */ (function() {
  /**
   *
   */
  function IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcPileType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcPileTypeEnum(tape[9])
    return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcPileType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcPileType
}())
exports.IfcPileType = IfcPileType

var IfcPipeFitting = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcPipeFitting.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPipeFittingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcPipeFitting.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPipeFitting
}())
exports.IfcPipeFitting = IfcPipeFitting

var IfcPipeFittingType = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcPipeFittingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcPipeFittingTypeEnum(tape[9])
    return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcPipeFittingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcPipeFittingType
}())
exports.IfcPipeFittingType = IfcPipeFittingType

var IfcPipeSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcPipeSegment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPipeSegmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcPipeSegment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPipeSegment
}())
exports.IfcPipeSegment = IfcPipeSegment

var IfcPipeSegmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcPipeSegmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcPipeSegmentTypeEnum(tape[9])
    return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcPipeSegmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcPipeSegmentType
}())
exports.IfcPipeSegmentType = IfcPipeSegmentType

var IfcPixelTexture = /** @class */ (function() {
  /**
   *
   */
  function IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
    this.expressID = expressID
    this.type = type
    this.RepeatS = RepeatS
    this.RepeatT = RepeatT
    this.Mode = Mode
    this.TextureTransform = TextureTransform
    this.Parameter = Parameter
    this.Width = Width
    this.Height = Height
    this.ColourComponents = ColourComponents
    this.Pixel = Pixel
  }
  IfcPixelTexture.FromTape = function(expressID, type, tape) {
    let RepeatS
    RepeatS = tape[0]
    let RepeatT
    RepeatT = tape[1]
    let Mode
    if (tape[2]) {
      Mode = tape[2]
    } else {
      Mode = null
    }
    let TextureTransform
    if (tape[3]) {
      TextureTransform = tape[3]
    } else {
      TextureTransform = null
    }
    let Parameter
    if (tape[4]) {
      Parameter = []
      let Parameter_index = 0
      while (Parameter_index < tape[4].length) {
        Parameter.push(tape[4][Parameter_index++])
      }
    } else {
      Parameter = null
    }
    let Width
    Width = tape[5]
    let Height
    Height = tape[6]
    let ColourComponents
    ColourComponents = tape[7]
    let Pixel
    Pixel = []
    let Pixel_index = 0
    while (Pixel_index < tape[8].length) {
      Pixel.push(tape[8][Pixel_index++])
    }
    return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel)
  }
  IfcPixelTexture.prototype.ToTape = function() {
    const args = []
    if (this.Mode) {
      args.push(STRING)
      args.push(this.Mode)
    } else {
      args.push(EMPTY)
    }
    if (this.TextureTransform) {
      args.push(REF)
      args.push(this.TextureTransform)
    } else {
      args.push(EMPTY)
    }
    if (this.Parameter) {
      args.push(STRING)
      args.push.apply(args, this.Parameter)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.Width)
    args.push(REAL)
    args.push(this.Height)
    args.push(REAL)
    args.push(this.ColourComponents)
    args.push(REAL)
    args.push.apply(args, this.Pixel)
    return args
  }
  return IfcPixelTexture
}())
exports.IfcPixelTexture = IfcPixelTexture

var IfcPlacement = /** @class */ (function() {
  /**
   *
   */
  function IfcPlacement(expressID, type, Location) {
    this.expressID = expressID
    this.type = type
    this.Location = Location
  }
  IfcPlacement.FromTape = function(expressID, type, tape) {
    let Location
    Location = tape[0]
    return new IfcPlacement(expressID, type, Location)
  }
  IfcPlacement.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Location)
    return args
  }
  return IfcPlacement
}())
exports.IfcPlacement = IfcPlacement

var IfcPlanarBox = /** @class */ (function() {
  /**
   *
   */
  function IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement) {
    this.expressID = expressID
    this.type = type
    this.SizeInX = SizeInX
    this.SizeInY = SizeInY
    this.Placement = Placement
  }
  IfcPlanarBox.FromTape = function(expressID, type, tape) {
    let SizeInX
    SizeInX = tape[0]
    let SizeInY
    SizeInY = tape[1]
    let Placement
    Placement = ParseType(tape[2], tape[3][0])
    return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement)
  }
  IfcPlanarBox.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.SizeInX)
    args.push(REAL)
    args.push(this.SizeInY)
    return args
  }
  return IfcPlanarBox
}())
exports.IfcPlanarBox = IfcPlanarBox

var IfcPlanarExtent = /** @class */ (function() {
  /**
   *
   */
  function IfcPlanarExtent(expressID, type, SizeInX, SizeInY) {
    this.expressID = expressID
    this.type = type
    this.SizeInX = SizeInX
    this.SizeInY = SizeInY
  }
  IfcPlanarExtent.FromTape = function(expressID, type, tape) {
    let SizeInX
    SizeInX = tape[0]
    let SizeInY
    SizeInY = tape[1]
    return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY)
  }
  IfcPlanarExtent.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.SizeInX)
    args.push(REAL)
    args.push(this.SizeInY)
    return args
  }
  return IfcPlanarExtent
}())
exports.IfcPlanarExtent = IfcPlanarExtent

var IfcPlane = /** @class */ (function() {
  /**
   *
   */
  function IfcPlane(expressID, type, Position) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
  }
  IfcPlane.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    return new IfcPlane(expressID, type, Position)
  }
  IfcPlane.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcPlane
}())
exports.IfcPlane = IfcPlane

var IfcPlate = /** @class */ (function() {
  /**
   *
   */
  function IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcPlate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPlateTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcPlate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPlate
}())
exports.IfcPlate = IfcPlate

var IfcPlateStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcPlateStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPlateTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcPlateStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPlateStandardCase
}())
exports.IfcPlateStandardCase = IfcPlateStandardCase

var IfcPlateType = /** @class */ (function() {
  /**
   *
   */
  function IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcPlateType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcPlateTypeEnum(tape[9])
    return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcPlateType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcPlateType
}())
exports.IfcPlateType = IfcPlateType

var IfcPoint = /** @class */ (function() {
  /**
   *
   */
  function IfcPoint(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcPoint.FromTape = function(expressID, type, tape) {
    return new IfcPoint(expressID, type)
  }
  IfcPoint.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcPoint
}())
exports.IfcPoint = IfcPoint

var IfcPointOnCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcPointOnCurve(expressID, type, BasisCurve, PointParameter) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
    this.PointParameter = PointParameter
  }
  IfcPointOnCurve.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    let PointParameter
    PointParameter = tape[1]
    return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter)
  }
  IfcPointOnCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    args.push(REAL)
    args.push(this.PointParameter)
    return args
  }
  return IfcPointOnCurve
}())
exports.IfcPointOnCurve = IfcPointOnCurve

var IfcPointOnSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
    this.expressID = expressID
    this.type = type
    this.BasisSurface = BasisSurface
    this.PointParameterU = PointParameterU
    this.PointParameterV = PointParameterV
  }
  IfcPointOnSurface.FromTape = function(expressID, type, tape) {
    let BasisSurface
    BasisSurface = tape[0]
    let PointParameterU
    PointParameterU = tape[1]
    let PointParameterV
    PointParameterV = tape[2]
    return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV)
  }
  IfcPointOnSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisSurface)
    args.push(REAL)
    args.push(this.PointParameterU)
    args.push(REAL)
    args.push(this.PointParameterV)
    return args
  }
  return IfcPointOnSurface
}())
exports.IfcPointOnSurface = IfcPointOnSurface

var IfcPolyLoop = /** @class */ (function() {
  /**
   *
   */
  function IfcPolyLoop(expressID, type, Polygon) {
    this.expressID = expressID
    this.type = type
    this.Polygon = Polygon
  }
  IfcPolyLoop.FromTape = function(expressID, type, tape) {
    let Polygon
    Polygon = []
    let Polygon_index = 0
    while (Polygon_index < tape[0].length) {
      Polygon.push(tape[0][Polygon_index++])
    }
    return new IfcPolyLoop(expressID, type, Polygon)
  }
  IfcPolyLoop.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Polygon.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPolyLoop
}())
exports.IfcPolyLoop = IfcPolyLoop

var IfcPolygonalBoundedHalfSpace = /** @class */ (function() {
  /**
   *
   */
  function IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
    this.expressID = expressID
    this.type = type
    this.BaseSurface = BaseSurface
    this.AgreementFlag = AgreementFlag
    this.Position = Position
    this.PolygonalBoundary = PolygonalBoundary
  }
  IfcPolygonalBoundedHalfSpace.FromTape = function(expressID, type, tape) {
    let BaseSurface
    BaseSurface = tape[0]
    let AgreementFlag
    AgreementFlag = tape[1]
    let Position
    Position = tape[2]
    let PolygonalBoundary
    PolygonalBoundary = tape[3]
    return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary)
  }
  IfcPolygonalBoundedHalfSpace.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BaseSurface)
    args.push(REF)
    args.push(this.Position)
    args.push(REF)
    args.push(this.PolygonalBoundary)
    return args
  }
  return IfcPolygonalBoundedHalfSpace
}())
exports.IfcPolygonalBoundedHalfSpace = IfcPolygonalBoundedHalfSpace

var IfcPolygonalFaceSet = /** @class */ (function() {
  /**
   *
   */
  function IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
    this.Closed = Closed
    this.Faces = Faces
    this.PnIndex = PnIndex
  }
  IfcPolygonalFaceSet.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = tape[0]
    let Closed
    if (tape[1]) {
      Closed = tape[1]
    } else {
      Closed = null
    }
    let Faces
    Faces = []
    let Faces_index = 0
    while (Faces_index < tape[2].length) {
      Faces.push(tape[2][Faces_index++])
    }
    let PnIndex
    if (tape[3]) {
      PnIndex = []
      let PnIndex_index = 0
      while (PnIndex_index < tape[3].length) {
        PnIndex.push(tape[3][PnIndex_index++])
      }
    } else {
      PnIndex = null
    }
    return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex)
  }
  IfcPolygonalFaceSet.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Coordinates)
    if (this.Closed) {
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Faces.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.PnIndex) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPolygonalFaceSet
}())
exports.IfcPolygonalFaceSet = IfcPolygonalFaceSet

var IfcPolyline = /** @class */ (function() {
  /**
   *
   */
  function IfcPolyline(expressID, type, Points) {
    this.expressID = expressID
    this.type = type
    this.Points = Points
  }
  IfcPolyline.FromTape = function(expressID, type, tape) {
    let Points
    Points = []
    let Points_index = 0
    while (Points_index < tape[0].length) {
      Points.push(tape[0][Points_index++])
    }
    return new IfcPolyline(expressID, type, Points)
  }
  IfcPolyline.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Points.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPolyline
}())
exports.IfcPolyline = IfcPolyline

var IfcPort = /** @class */ (function() {
  /**
   *
   */
  function IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcPort.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcPort.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPort
}())
exports.IfcPort = IfcPort

var IfcPositioningElement = /** @class */ (function() {
  /**
   *
   */
  function IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcPositioningElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcPositioningElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPositioningElement
}())
exports.IfcPositioningElement = IfcPositioningElement

var IfcPostalAddress = /** @class */ (function() {
  /**
   *
   */
  function IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
    this.expressID = expressID
    this.type = type
    this.Purpose = Purpose
    this.Description = Description
    this.UserDefinedPurpose = UserDefinedPurpose
    this.InternalLocation = InternalLocation
    this.AddressLines = AddressLines
    this.PostalBox = PostalBox
    this.Town = Town
    this.Region = Region
    this.PostalCode = PostalCode
    this.Country = Country
  }
  IfcPostalAddress.FromTape = function(expressID, type, tape) {
    let Purpose
    if (tape[0]) {
      Purpose = new IfcAddressTypeEnum(tape[0])
    } else {
      Purpose = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UserDefinedPurpose
    if (tape[2]) {
      UserDefinedPurpose = tape[2]
    } else {
      UserDefinedPurpose = null
    }
    let InternalLocation
    if (tape[3]) {
      InternalLocation = tape[3]
    } else {
      InternalLocation = null
    }
    let AddressLines
    if (tape[4]) {
      AddressLines = []
      let AddressLines_index = 0
      while (AddressLines_index < tape[4].length) {
        AddressLines.push(tape[4][AddressLines_index++])
      }
    } else {
      AddressLines = null
    }
    let PostalBox
    if (tape[5]) {
      PostalBox = tape[5]
    } else {
      PostalBox = null
    }
    let Town
    if (tape[6]) {
      Town = tape[6]
    } else {
      Town = null
    }
    let Region
    if (tape[7]) {
      Region = tape[7]
    } else {
      Region = null
    }
    let PostalCode
    if (tape[8]) {
      PostalCode = tape[8]
    } else {
      PostalCode = null
    }
    let Country
    if (tape[9]) {
      Country = tape[9]
    } else {
      Country = null
    }
    return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country)
  }
  IfcPostalAddress.prototype.ToTape = function() {
    const args = []
    if (this.Purpose) {
      args.push(ENUM)
      args.push(this.Purpose.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPurpose) {
      args.push(STRING)
      args.push(this.UserDefinedPurpose)
    } else {
      args.push(EMPTY)
    }
    if (this.InternalLocation) {
      args.push(STRING)
      args.push(this.InternalLocation)
    } else {
      args.push(EMPTY)
    }
    if (this.AddressLines) {
      args.push(STRING)
      args.push.apply(args, this.AddressLines)
    } else {
      args.push(EMPTY)
    }
    if (this.PostalBox) {
      args.push(STRING)
      args.push(this.PostalBox)
    } else {
      args.push(EMPTY)
    }
    if (this.Town) {
      args.push(STRING)
      args.push(this.Town)
    } else {
      args.push(EMPTY)
    }
    if (this.Region) {
      args.push(STRING)
      args.push(this.Region)
    } else {
      args.push(EMPTY)
    }
    if (this.PostalCode) {
      args.push(STRING)
      args.push(this.PostalCode)
    } else {
      args.push(EMPTY)
    }
    if (this.Country) {
      args.push(STRING)
      args.push(this.Country)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPostalAddress
}())
exports.IfcPostalAddress = IfcPostalAddress

var IfcPreDefinedColour = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedColour(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcPreDefinedColour.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcPreDefinedColour(expressID, type, Name)
  }
  IfcPreDefinedColour.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcPreDefinedColour
}())
exports.IfcPreDefinedColour = IfcPreDefinedColour

var IfcPreDefinedCurveFont = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedCurveFont(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcPreDefinedCurveFont.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcPreDefinedCurveFont(expressID, type, Name)
  }
  IfcPreDefinedCurveFont.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcPreDefinedCurveFont
}())
exports.IfcPreDefinedCurveFont = IfcPreDefinedCurveFont

var IfcPreDefinedItem = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedItem(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcPreDefinedItem.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcPreDefinedItem(expressID, type, Name)
  }
  IfcPreDefinedItem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcPreDefinedItem
}())
exports.IfcPreDefinedItem = IfcPreDefinedItem

var IfcPreDefinedProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedProperties(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcPreDefinedProperties.FromTape = function(expressID, type, tape) {
    return new IfcPreDefinedProperties(expressID, type)
  }
  IfcPreDefinedProperties.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcPreDefinedProperties
}())
exports.IfcPreDefinedProperties = IfcPreDefinedProperties

var IfcPreDefinedPropertySet = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcPreDefinedPropertySet.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcPreDefinedPropertySet.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPreDefinedPropertySet
}())
exports.IfcPreDefinedPropertySet = IfcPreDefinedPropertySet

var IfcPreDefinedTextFont = /** @class */ (function() {
  /**
   *
   */
  function IfcPreDefinedTextFont(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcPreDefinedTextFont.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    return new IfcPreDefinedTextFont(expressID, type, Name)
  }
  IfcPreDefinedTextFont.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    return args
  }
  return IfcPreDefinedTextFont
}())
exports.IfcPreDefinedTextFont = IfcPreDefinedTextFont

var IfcPresentationItem = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentationItem(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcPresentationItem.FromTape = function(expressID, type, tape) {
    return new IfcPresentationItem(expressID, type)
  }
  IfcPresentationItem.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcPresentationItem
}())
exports.IfcPresentationItem = IfcPresentationItem

var IfcPresentationLayerAssignment = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.AssignedItems = AssignedItems
    this.Identifier = Identifier
  }
  IfcPresentationLayerAssignment.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let AssignedItems
    AssignedItems = []
    let AssignedItems_index = 0
    while (AssignedItems_index < tape[2].length) {
      AssignedItems.push(ParseType(tape[2][AssignedItems_index++], tape[2][AssignedItems_index++][0]))
    }
    let Identifier
    if (tape[3]) {
      Identifier = tape[3]
    } else {
      Identifier = null
    }
    return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier)
  }
  IfcPresentationLayerAssignment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Identifier) {
      args.push(STRING)
      args.push(this.Identifier)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPresentationLayerAssignment
}())
exports.IfcPresentationLayerAssignment = IfcPresentationLayerAssignment

var IfcPresentationLayerWithStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.AssignedItems = AssignedItems
    this.Identifier = Identifier
    this.LayerOn = LayerOn
    this.LayerFrozen = LayerFrozen
    this.LayerBlocked = LayerBlocked
    this.LayerStyles = LayerStyles
  }
  IfcPresentationLayerWithStyle.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let AssignedItems
    AssignedItems = []
    let AssignedItems_index = 0
    while (AssignedItems_index < tape[2].length) {
      AssignedItems.push(ParseType(tape[2][AssignedItems_index++], tape[2][AssignedItems_index++][0]))
    }
    let Identifier
    if (tape[3]) {
      Identifier = tape[3]
    } else {
      Identifier = null
    }
    let LayerOn
    LayerOn = tape[4]
    let LayerFrozen
    LayerFrozen = tape[5]
    let LayerBlocked
    LayerBlocked = tape[6]
    let LayerStyles
    LayerStyles = []
    let LayerStyles_index = 0
    while (LayerStyles_index < tape[7].length) {
      LayerStyles.push(tape[7][LayerStyles_index++])
    }
    return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles)
  }
  IfcPresentationLayerWithStyle.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Identifier) {
      args.push(STRING)
      args.push(this.Identifier)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.LayerStyles.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPresentationLayerWithStyle
}())
exports.IfcPresentationLayerWithStyle = IfcPresentationLayerWithStyle

var IfcPresentationStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentationStyle(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcPresentationStyle.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcPresentationStyle(expressID, type, Name)
  }
  IfcPresentationStyle.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPresentationStyle
}())
exports.IfcPresentationStyle = IfcPresentationStyle

var IfcPresentationStyleAssignment = /** @class */ (function() {
  /**
   *
   */
  function IfcPresentationStyleAssignment(expressID, type, Styles) {
    this.expressID = expressID
    this.type = type
    this.Styles = Styles
  }
  IfcPresentationStyleAssignment.FromTape = function(expressID, type, tape) {
    let Styles
    Styles = []
    let Styles_index = 0
    while (Styles_index < tape[0].length) {
      Styles.push(ParseType(tape[0][Styles_index++], tape[0][Styles_index++][0]))
    }
    return new IfcPresentationStyleAssignment(expressID, type, Styles)
  }
  IfcPresentationStyleAssignment.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcPresentationStyleAssignment
}())
exports.IfcPresentationStyleAssignment = IfcPresentationStyleAssignment

var IfcProcedure = /** @class */ (function() {
  /**
   *
   */
  function IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.PredefinedType = PredefinedType
  }
  IfcProcedure.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let PredefinedType
    if (tape[7]) {
      PredefinedType = new IfcProcedureTypeEnum(tape[7])
    } else {
      PredefinedType = null
    }
    return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType)
  }
  IfcProcedure.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProcedure
}())
exports.IfcProcedure = IfcProcedure

var IfcProcedureType = /** @class */ (function() {
  /**
   *
   */
  function IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ProcessType = ProcessType
    this.PredefinedType = PredefinedType
  }
  IfcProcedureType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ProcessType
    if (tape[8]) {
      ProcessType = tape[8]
    } else {
      ProcessType = null
    }
    let PredefinedType
    PredefinedType = new IfcProcedureTypeEnum(tape[9])
    return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType)
  }
  IfcProcedureType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ProcessType) {
      args.push(STRING)
      args.push(this.ProcessType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcProcedureType
}())
exports.IfcProcedureType = IfcProcedureType

var IfcProcess = /** @class */ (function() {
  /**
   *
   */
  function IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
  }
  IfcProcess.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
  }
  IfcProcess.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProcess
}())
exports.IfcProcess = IfcProcess

var IfcProduct = /** @class */ (function() {
  /**
   *
   */
  function IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcProduct.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcProduct.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProduct
}())
exports.IfcProduct = IfcProduct

var IfcProductDefinitionShape = /** @class */ (function() {
  /**
   *
   */
  function IfcProductDefinitionShape(expressID, type, Name, Description, Representations) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Representations = Representations
  }
  IfcProductDefinitionShape.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Representations
    Representations = []
    let Representations_index = 0
    while (Representations_index < tape[2].length) {
      Representations.push(tape[2][Representations_index++])
    }
    return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations)
  }
  IfcProductDefinitionShape.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Representations.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcProductDefinitionShape
}())
exports.IfcProductDefinitionShape = IfcProductDefinitionShape

var IfcProductRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcProductRepresentation(expressID, type, Name, Description, Representations) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Representations = Representations
  }
  IfcProductRepresentation.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Representations
    Representations = []
    let Representations_index = 0
    while (Representations_index < tape[2].length) {
      Representations.push(tape[2][Representations_index++])
    }
    return new IfcProductRepresentation(expressID, type, Name, Description, Representations)
  }
  IfcProductRepresentation.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Representations.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcProductRepresentation
}())
exports.IfcProductRepresentation = IfcProductRepresentation

var IfcProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcProfileDef(expressID, type, ProfileType, ProfileName) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
  }
  IfcProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    return new IfcProfileDef(expressID, type, ProfileType, ProfileName)
  }
  IfcProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProfileDef
}())
exports.IfcProfileDef = IfcProfileDef

var IfcProfileProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcProfileProperties(expressID, type, Name, Description, Properties, ProfileDefinition) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Properties = Properties
    this.ProfileDefinition = ProfileDefinition
  }
  IfcProfileProperties.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Properties
    Properties = []
    let Properties_index = 0
    while (Properties_index < tape[2].length) {
      Properties.push(tape[2][Properties_index++])
    }
    let ProfileDefinition
    ProfileDefinition = tape[3]
    return new IfcProfileProperties(expressID, type, Name, Description, Properties, ProfileDefinition)
  }
  IfcProfileProperties.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Properties.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.ProfileDefinition)
    return args
  }
  return IfcProfileProperties
}())
exports.IfcProfileProperties = IfcProfileProperties

var IfcProject = /** @class */ (function() {
  /**
   *
   */
  function IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
    this.Phase = Phase
    this.RepresentationContexts = RepresentationContexts
    this.UnitsInContext = UnitsInContext
  }
  IfcProject.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    let Phase
    if (tape[6]) {
      Phase = tape[6]
    } else {
      Phase = null
    }
    let RepresentationContexts
    if (tape[7]) {
      RepresentationContexts = []
      let RepresentationContexts_index = 0
      while (RepresentationContexts_index < tape[7].length) {
        RepresentationContexts.push(tape[7][RepresentationContexts_index++])
      }
    } else {
      RepresentationContexts = null
    }
    let UnitsInContext
    if (tape[8]) {
      UnitsInContext = tape[8]
    } else {
      UnitsInContext = null
    }
    return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
  }
  IfcProject.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.Phase) {
      args.push(STRING)
      args.push(this.Phase)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationContexts) {
      args.push(SET_BEGIN)
      this.RepresentationContexts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.UnitsInContext) {
      args.push(REF)
      args.push(this.UnitsInContext)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProject
}())
exports.IfcProject = IfcProject

var IfcProjectLibrary = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
    this.Phase = Phase
    this.RepresentationContexts = RepresentationContexts
    this.UnitsInContext = UnitsInContext
  }
  IfcProjectLibrary.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    let Phase
    if (tape[6]) {
      Phase = tape[6]
    } else {
      Phase = null
    }
    let RepresentationContexts
    if (tape[7]) {
      RepresentationContexts = []
      let RepresentationContexts_index = 0
      while (RepresentationContexts_index < tape[7].length) {
        RepresentationContexts.push(tape[7][RepresentationContexts_index++])
      }
    } else {
      RepresentationContexts = null
    }
    let UnitsInContext
    if (tape[8]) {
      UnitsInContext = tape[8]
    } else {
      UnitsInContext = null
    }
    return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
  }
  IfcProjectLibrary.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.Phase) {
      args.push(STRING)
      args.push(this.Phase)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationContexts) {
      args.push(SET_BEGIN)
      this.RepresentationContexts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.UnitsInContext) {
      args.push(REF)
      args.push(this.UnitsInContext)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProjectLibrary
}())
exports.IfcProjectLibrary = IfcProjectLibrary

var IfcProjectOrder = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.PredefinedType = PredefinedType
    this.Status = Status
    this.LongDescription = LongDescription
  }
  IfcProjectOrder.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let PredefinedType
    if (tape[6]) {
      PredefinedType = new IfcProjectOrderTypeEnum(tape[6])
    } else {
      PredefinedType = null
    }
    let Status
    if (tape[7]) {
      Status = tape[7]
    } else {
      Status = null
    }
    let LongDescription
    if (tape[8]) {
      LongDescription = tape[8]
    } else {
      LongDescription = null
    }
    return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription)
  }
  IfcProjectOrder.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProjectOrder
}())
exports.IfcProjectOrder = IfcProjectOrder

var IfcProjectedCRS = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.GeodeticDatum = GeodeticDatum
    this.VerticalDatum = VerticalDatum
    this.MapProjection = MapProjection
    this.MapZone = MapZone
    this.MapUnit = MapUnit
  }
  IfcProjectedCRS.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let GeodeticDatum
    if (tape[2]) {
      GeodeticDatum = tape[2]
    } else {
      GeodeticDatum = null
    }
    let VerticalDatum
    if (tape[3]) {
      VerticalDatum = tape[3]
    } else {
      VerticalDatum = null
    }
    let MapProjection
    if (tape[4]) {
      MapProjection = tape[4]
    } else {
      MapProjection = null
    }
    let MapZone
    if (tape[5]) {
      MapZone = tape[5]
    } else {
      MapZone = null
    }
    let MapUnit
    if (tape[6]) {
      MapUnit = tape[6]
    } else {
      MapUnit = null
    }
    return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit)
  }
  IfcProjectedCRS.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.GeodeticDatum) {
      args.push(STRING)
      args.push(this.GeodeticDatum)
    } else {
      args.push(EMPTY)
    }
    if (this.VerticalDatum) {
      args.push(STRING)
      args.push(this.VerticalDatum)
    } else {
      args.push(EMPTY)
    }
    if (this.MapProjection) {
      args.push(STRING)
      args.push(this.MapProjection)
    } else {
      args.push(EMPTY)
    }
    if (this.MapZone) {
      args.push(STRING)
      args.push(this.MapZone)
    } else {
      args.push(EMPTY)
    }
    if (this.MapUnit) {
      args.push(REF)
      args.push(this.MapUnit)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProjectedCRS
}())
exports.IfcProjectedCRS = IfcProjectedCRS

var IfcProjectionElement = /** @class */ (function() {
  /**
   *
   */
  function IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcProjectionElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcProjectionElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcProjectionElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProjectionElement
}())
exports.IfcProjectionElement = IfcProjectionElement

var IfcProperty = /** @class */ (function() {
  /**
   *
   */
  function IfcProperty(expressID, type, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
  }
  IfcProperty.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    return new IfcProperty(expressID, type, Name, Description)
  }
  IfcProperty.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProperty
}())
exports.IfcProperty = IfcProperty

var IfcPropertyAbstraction = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyAbstraction(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcPropertyAbstraction.FromTape = function(expressID, type, tape) {
    return new IfcPropertyAbstraction(expressID, type)
  }
  IfcPropertyAbstraction.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcPropertyAbstraction
}())
exports.IfcPropertyAbstraction = IfcPropertyAbstraction

var IfcPropertyBoundedValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.UpperBoundValue = UpperBoundValue
    this.LowerBoundValue = LowerBoundValue
    this.Unit = Unit
    this.SetPointValue = SetPointValue
  }
  IfcPropertyBoundedValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UpperBoundValue
    if (tape[2]) {
      UpperBoundValue = ParseType(tape[2], tape[3][0])
    } else {
      UpperBoundValue = null
    }
    let LowerBoundValue
    if (tape[3]) {
      LowerBoundValue = ParseType(tape[3], tape[4][0])
    } else {
      LowerBoundValue = null
    }
    let Unit
    if (tape[4]) {
      Unit = ParseType(tape[4], tape[5][0])
    } else {
      Unit = null
    }
    let SetPointValue
    if (tape[5]) {
      SetPointValue = ParseType(tape[5], tape[6][0])
    } else {
      SetPointValue = null
    }
    return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue)
  }
  IfcPropertyBoundedValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UpperBoundValue) {
      args.push(LABEL)
      // @ts-ignore
      args.push(this.UpperBoundValue.t)
      args.push(SET_BEGIN)
      // @ts-ignore
      args.push(typeof this.UpperBoundValue.v === 'string' ? STRING : REAL)
      // @ts-ignore
      args.push(this.UpperBoundValue.v)
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.LowerBoundValue) {
      args.push(LABEL)
      // @ts-ignore
      args.push(this.LowerBoundValue.t)
      args.push(SET_BEGIN)
      // @ts-ignore
      args.push(typeof this.LowerBoundValue.v === 'string' ? STRING : REAL)
      // @ts-ignore
      args.push(this.LowerBoundValue.v)
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    if (this.SetPointValue) {
      args.push(LABEL)
      // @ts-ignore
      args.push(this.SetPointValue.t)
      args.push(SET_BEGIN)
      // @ts-ignore
      args.push(typeof this.SetPointValue.v === 'string' ? STRING : REAL)
      // @ts-ignore
      args.push(this.SetPointValue.v)
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyBoundedValue
}())
exports.IfcPropertyBoundedValue = IfcPropertyBoundedValue

var IfcPropertyDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcPropertyDefinition.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcPropertyDefinition.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyDefinition
}())
exports.IfcPropertyDefinition = IfcPropertyDefinition

var IfcPropertyDependencyRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.DependingProperty = DependingProperty
    this.DependantProperty = DependantProperty
    this.Expression = Expression
  }
  IfcPropertyDependencyRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let DependingProperty
    DependingProperty = tape[2]
    let DependantProperty
    DependantProperty = tape[3]
    let Expression
    if (tape[4]) {
      Expression = tape[4]
    } else {
      Expression = null
    }
    return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression)
  }
  IfcPropertyDependencyRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.DependingProperty)
    args.push(REF)
    args.push(this.DependantProperty)
    if (this.Expression) {
      args.push(STRING)
      args.push(this.Expression)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyDependencyRelationship
}())
exports.IfcPropertyDependencyRelationship = IfcPropertyDependencyRelationship

var IfcPropertyEnumeratedValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.EnumerationValues = EnumerationValues
    this.EnumerationReference = EnumerationReference
  }
  IfcPropertyEnumeratedValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let EnumerationValues
    if (tape[2]) {
      EnumerationValues = []
      let EnumerationValues_index = 0
      while (EnumerationValues_index < tape[2].length) {
        EnumerationValues.push(ParseType(tape[2][EnumerationValues_index++], tape[2][EnumerationValues_index++][0]))
      }
    } else {
      EnumerationValues = null
    }
    let EnumerationReference
    if (tape[3]) {
      EnumerationReference = tape[3]
    } else {
      EnumerationReference = null
    }
    return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference)
  }
  IfcPropertyEnumeratedValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.EnumerationValues) {
    } else {
      args.push(EMPTY)
    }
    if (this.EnumerationReference) {
      args.push(REF)
      args.push(this.EnumerationReference)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyEnumeratedValue
}())
exports.IfcPropertyEnumeratedValue = IfcPropertyEnumeratedValue

var IfcPropertyEnumeration = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.EnumerationValues = EnumerationValues
    this.Unit = Unit
  }
  IfcPropertyEnumeration.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let EnumerationValues
    EnumerationValues = []
    let EnumerationValues_index = 0
    while (EnumerationValues_index < tape[1].length) {
      EnumerationValues.push(ParseType(tape[1][EnumerationValues_index++], tape[1][EnumerationValues_index++][0]))
    }
    let Unit
    if (tape[2]) {
      Unit = ParseType(tape[2], tape[3][0])
    } else {
      Unit = null
    }
    return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit)
  }
  IfcPropertyEnumeration.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyEnumeration
}())
exports.IfcPropertyEnumeration = IfcPropertyEnumeration

var IfcPropertyListValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.ListValues = ListValues
    this.Unit = Unit
  }
  IfcPropertyListValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let ListValues
    if (tape[2]) {
      ListValues = []
      let ListValues_index = 0
      while (ListValues_index < tape[2].length) {
        ListValues.push(ParseType(tape[2][ListValues_index++], tape[2][ListValues_index++][0]))
      }
    } else {
      ListValues = null
    }
    let Unit
    if (tape[3]) {
      Unit = ParseType(tape[3], tape[4][0])
    } else {
      Unit = null
    }
    return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit)
  }
  IfcPropertyListValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ListValues) {
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyListValue
}())
exports.IfcPropertyListValue = IfcPropertyListValue

var IfcPropertyReferenceValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.UsageName = UsageName
    this.PropertyReference = PropertyReference
  }
  IfcPropertyReferenceValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UsageName
    if (tape[2]) {
      UsageName = tape[2]
    } else {
      UsageName = null
    }
    let PropertyReference
    if (tape[3]) {
      PropertyReference = ParseType(tape[3], tape[4][0])
    } else {
      PropertyReference = null
    }
    return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference)
  }
  IfcPropertyReferenceValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UsageName) {
      args.push(STRING)
      args.push(this.UsageName)
    } else {
      args.push(EMPTY)
    }
    if (this.PropertyReference) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyReferenceValue
}())
exports.IfcPropertyReferenceValue = IfcPropertyReferenceValue

var IfcPropertySet = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.HasProperties = HasProperties
  }
  IfcPropertySet.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let HasProperties
    HasProperties = []
    let HasProperties_index = 0
    while (HasProperties_index < tape[4].length) {
      HasProperties.push(tape[4][HasProperties_index++])
    }
    return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties)
  }
  IfcPropertySet.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.HasProperties.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPropertySet
}())
exports.IfcPropertySet = IfcPropertySet

var IfcPropertySetDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcPropertySetDefinition.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcPropertySetDefinition.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertySetDefinition
}())
exports.IfcPropertySetDefinition = IfcPropertySetDefinition

var IfcPropertySetTemplate = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.TemplateType = TemplateType
    this.ApplicableEntity = ApplicableEntity
    this.HasPropertyTemplates = HasPropertyTemplates
  }
  IfcPropertySetTemplate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let TemplateType
    if (tape[4]) {
      TemplateType = new IfcPropertySetTemplateTypeEnum(tape[4])
    } else {
      TemplateType = null
    }
    let ApplicableEntity
    if (tape[5]) {
      ApplicableEntity = tape[5]
    } else {
      ApplicableEntity = null
    }
    let HasPropertyTemplates
    HasPropertyTemplates = []
    let HasPropertyTemplates_index = 0
    while (HasPropertyTemplates_index < tape[6].length) {
      HasPropertyTemplates.push(tape[6][HasPropertyTemplates_index++])
    }
    return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates)
  }
  IfcPropertySetTemplate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.TemplateType) {
      args.push(ENUM)
      args.push(this.TemplateType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableEntity) {
      args.push(STRING)
      args.push(this.ApplicableEntity)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.HasPropertyTemplates.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcPropertySetTemplate
}())
exports.IfcPropertySetTemplate = IfcPropertySetTemplate

var IfcPropertySingleValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.NominalValue = NominalValue
    this.Unit = Unit
  }
  IfcPropertySingleValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let NominalValue
    if (tape[2]) {
      NominalValue = ParseType(tape[2], tape[3][0])
    } else {
      NominalValue = null
    }
    let Unit
    if (tape[3]) {
      Unit = ParseType(tape[3], tape[4][0])
    } else {
      Unit = null
    }
    return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit)
  }
  IfcPropertySingleValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.NominalValue) {
      args.push(LABEL)
      // @ts-ignore
      args.push(this.NominalValue.t)
      args.push(SET_BEGIN)
      // @ts-ignore
      args.push(typeof this.NominalValue.v === 'string' ? STRING : REAL)
      // @ts-ignore
      args.push(this.NominalValue.v)
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertySingleValue
}())
exports.IfcPropertySingleValue = IfcPropertySingleValue

var IfcPropertyTableValue = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.DefiningValues = DefiningValues
    this.DefinedValues = DefinedValues
    this.Expression = Expression
    this.DefiningUnit = DefiningUnit
    this.DefinedUnit = DefinedUnit
    this.CurveInterpolation = CurveInterpolation
  }
  IfcPropertyTableValue.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let DefiningValues
    if (tape[2]) {
      DefiningValues = []
      let DefiningValues_index = 0
      while (DefiningValues_index < tape[2].length) {
        DefiningValues.push(ParseType(tape[2][DefiningValues_index++], tape[2][DefiningValues_index++][0]))
      }
    } else {
      DefiningValues = null
    }
    let DefinedValues
    if (tape[3]) {
      DefinedValues = []
      let DefinedValues_index = 0
      while (DefinedValues_index < tape[3].length) {
        DefinedValues.push(ParseType(tape[3][DefinedValues_index++], tape[3][DefinedValues_index++][0]))
      }
    } else {
      DefinedValues = null
    }
    let Expression
    if (tape[4]) {
      Expression = tape[4]
    } else {
      Expression = null
    }
    let DefiningUnit
    if (tape[5]) {
      DefiningUnit = ParseType(tape[5], tape[6][0])
    } else {
      DefiningUnit = null
    }
    let DefinedUnit
    if (tape[6]) {
      DefinedUnit = ParseType(tape[6], tape[7][0])
    } else {
      DefinedUnit = null
    }
    let CurveInterpolation
    if (tape[7]) {
      CurveInterpolation = new IfcCurveInterpolationEnum(tape[7])
    } else {
      CurveInterpolation = null
    }
    return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation)
  }
  IfcPropertyTableValue.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.DefiningValues) {
    } else {
      args.push(EMPTY)
    }
    if (this.DefinedValues) {
    } else {
      args.push(EMPTY)
    }
    if (this.Expression) {
      args.push(STRING)
      args.push(this.Expression)
    } else {
      args.push(EMPTY)
    }
    if (this.DefiningUnit) {
    } else {
      args.push(EMPTY)
    }
    if (this.DefinedUnit) {
    } else {
      args.push(EMPTY)
    }
    if (this.CurveInterpolation) {
      args.push(ENUM)
      args.push(this.CurveInterpolation.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyTableValue
}())
exports.IfcPropertyTableValue = IfcPropertyTableValue

var IfcPropertyTemplate = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcPropertyTemplate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcPropertyTemplate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyTemplate
}())
exports.IfcPropertyTemplate = IfcPropertyTemplate

var IfcPropertyTemplateDefinition = /** @class */ (function() {
  /**
   *
   */
  function IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcPropertyTemplateDefinition.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcPropertyTemplateDefinition.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPropertyTemplateDefinition
}())
exports.IfcPropertyTemplateDefinition = IfcPropertyTemplateDefinition

var IfcProtectiveDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcProtectiveDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcProtectiveDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcProtectiveDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProtectiveDevice
}())
exports.IfcProtectiveDevice = IfcProtectiveDevice

var IfcProtectiveDeviceTrippingUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcProtectiveDeviceTrippingUnit.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcProtectiveDeviceTrippingUnitTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcProtectiveDeviceTrippingUnit.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProtectiveDeviceTrippingUnit
}())
exports.IfcProtectiveDeviceTrippingUnit = IfcProtectiveDeviceTrippingUnit

var IfcProtectiveDeviceTrippingUnitType = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcProtectiveDeviceTrippingUnitType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcProtectiveDeviceTrippingUnitTypeEnum(tape[9])
    return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcProtectiveDeviceTrippingUnitType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcProtectiveDeviceTrippingUnitType
}())
exports.IfcProtectiveDeviceTrippingUnitType = IfcProtectiveDeviceTrippingUnitType

var IfcProtectiveDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcProtectiveDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcProtectiveDeviceTypeEnum(tape[9])
    return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcProtectiveDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcProtectiveDeviceType
}())
exports.IfcProtectiveDeviceType = IfcProtectiveDeviceType

var IfcProxy = /** @class */ (function() {
  /**
   *
   */
  function IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.ProxyType = ProxyType
    this.Tag = Tag
  }
  IfcProxy.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let ProxyType
    ProxyType = new IfcObjectTypeEnum(tape[7])
    let Tag
    if (tape[8]) {
      Tag = tape[8]
    } else {
      Tag = null
    }
    return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag)
  }
  IfcProxy.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ProxyType.value)
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcProxy
}())
exports.IfcProxy = IfcProxy

var IfcPump = /** @class */ (function() {
  /**
   *
   */
  function IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcPump.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcPumpTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcPump.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcPump
}())
exports.IfcPump = IfcPump

var IfcPumpType = /** @class */ (function() {
  /**
   *
   */
  function IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcPumpType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcPumpTypeEnum(tape[9])
    return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcPumpType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcPumpType
}())
exports.IfcPumpType = IfcPumpType

var IfcQuantityArea = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.AreaValue = AreaValue
    this.Formula = Formula
  }
  IfcQuantityArea.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let AreaValue
    AreaValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula)
  }
  IfcQuantityArea.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.AreaValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityArea
}())
exports.IfcQuantityArea = IfcQuantityArea

var IfcQuantityCount = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.CountValue = CountValue
    this.Formula = Formula
  }
  IfcQuantityCount.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let CountValue
    CountValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula)
  }
  IfcQuantityCount.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.CountValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityCount
}())
exports.IfcQuantityCount = IfcQuantityCount

var IfcQuantityLength = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.LengthValue = LengthValue
    this.Formula = Formula
  }
  IfcQuantityLength.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let LengthValue
    LengthValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula)
  }
  IfcQuantityLength.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.LengthValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityLength
}())
exports.IfcQuantityLength = IfcQuantityLength

var IfcQuantitySet = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcQuantitySet.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcQuantitySet.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantitySet
}())
exports.IfcQuantitySet = IfcQuantitySet

var IfcQuantityTime = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.TimeValue = TimeValue
    this.Formula = Formula
  }
  IfcQuantityTime.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let TimeValue
    TimeValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula)
  }
  IfcQuantityTime.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.TimeValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityTime
}())
exports.IfcQuantityTime = IfcQuantityTime

var IfcQuantityVolume = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.VolumeValue = VolumeValue
    this.Formula = Formula
  }
  IfcQuantityVolume.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let VolumeValue
    VolumeValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula)
  }
  IfcQuantityVolume.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.VolumeValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityVolume
}())
exports.IfcQuantityVolume = IfcQuantityVolume

var IfcQuantityWeight = /** @class */ (function() {
  /**
   *
   */
  function IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.WeightValue = WeightValue
    this.Formula = Formula
  }
  IfcQuantityWeight.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let Unit
    if (tape[2]) {
      Unit = tape[2]
    } else {
      Unit = null
    }
    let WeightValue
    WeightValue = tape[3]
    let Formula
    if (tape[4]) {
      Formula = tape[4]
    } else {
      Formula = null
    }
    return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula)
  }
  IfcQuantityWeight.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
      args.push(REF)
      args.push(this.Unit)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.WeightValue)
    if (this.Formula) {
      args.push(STRING)
      args.push(this.Formula)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcQuantityWeight
}())
exports.IfcQuantityWeight = IfcQuantityWeight

var IfcRailing = /** @class */ (function() {
  /**
   *
   */
  function IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcRailing.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcRailingTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcRailing.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRailing
}())
exports.IfcRailing = IfcRailing

var IfcRailingType = /** @class */ (function() {
  /**
   *
   */
  function IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcRailingType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcRailingTypeEnum(tape[9])
    return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcRailingType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcRailingType
}())
exports.IfcRailingType = IfcRailingType

var IfcRamp = /** @class */ (function() {
  /**
   *
   */
  function IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcRamp.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcRampTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcRamp.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRamp
}())
exports.IfcRamp = IfcRamp

var IfcRampFlight = /** @class */ (function() {
  /**
   *
   */
  function IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcRampFlight.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcRampFlightTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcRampFlight.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRampFlight
}())
exports.IfcRampFlight = IfcRampFlight

var IfcRampFlightType = /** @class */ (function() {
  /**
   *
   */
  function IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcRampFlightType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcRampFlightTypeEnum(tape[9])
    return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcRampFlightType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcRampFlightType
}())
exports.IfcRampFlightType = IfcRampFlightType

var IfcRampType = /** @class */ (function() {
  /**
   *
   */
  function IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcRampType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcRampTypeEnum(tape[9])
    return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcRampType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcRampType
}())
exports.IfcRampType = IfcRampType

var IfcRationalBSplineCurveWithKnots = /** @class */ (function() {
  /**
   *
   */
  function IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
    this.expressID = expressID
    this.type = type
    this.Degree = Degree
    this.ControlPointsList = ControlPointsList
    this.CurveForm = CurveForm
    this.ClosedCurve = ClosedCurve
    this.SelfIntersect = SelfIntersect
    this.KnotMultiplicities = KnotMultiplicities
    this.Knots = Knots
    this.KnotSpec = KnotSpec
    this.WeightsData = WeightsData
  }
  IfcRationalBSplineCurveWithKnots.FromTape = function(expressID, type, tape) {
    let Degree
    Degree = tape[0]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[1].length) {
      ControlPointsList.push(tape[1][ControlPointsList_index++])
    }
    let CurveForm
    CurveForm = new IfcBSplineCurveForm(tape[2])
    let ClosedCurve
    ClosedCurve = tape[3]
    let SelfIntersect
    SelfIntersect = tape[4]
    let KnotMultiplicities
    KnotMultiplicities = []
    let KnotMultiplicities_index = 0
    while (KnotMultiplicities_index < tape[5].length) {
      KnotMultiplicities.push(tape[5][KnotMultiplicities_index++])
    }
    let Knots
    Knots = []
    let Knots_index = 0
    while (Knots_index < tape[6].length) {
      Knots.push(tape[6][Knots_index++])
    }
    let KnotSpec
    KnotSpec = new IfcKnotType(tape[7])
    let WeightsData
    WeightsData = []
    let WeightsData_index = 0
    while (WeightsData_index < tape[8].length) {
      WeightsData.push(tape[8][WeightsData_index++])
    }
    return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData)
  }
  IfcRationalBSplineCurveWithKnots.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.Degree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.CurveForm.value)
    args.push(REAL)
    args.push.apply(args, this.KnotMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.Knots)
    args.push(ENUM)
    args.push(this.KnotSpec.value)
    args.push(REAL)
    args.push.apply(args, this.WeightsData)
    return args
  }
  return IfcRationalBSplineCurveWithKnots
}())
exports.IfcRationalBSplineCurveWithKnots = IfcRationalBSplineCurveWithKnots

var IfcRationalBSplineSurfaceWithKnots = /** @class */ (function() {
  /**
   *
   */
  function IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
    this.expressID = expressID
    this.type = type
    this.UDegree = UDegree
    this.VDegree = VDegree
    this.ControlPointsList = ControlPointsList
    this.SurfaceForm = SurfaceForm
    this.UClosed = UClosed
    this.VClosed = VClosed
    this.SelfIntersect = SelfIntersect
    this.UMultiplicities = UMultiplicities
    this.VMultiplicities = VMultiplicities
    this.UKnots = UKnots
    this.VKnots = VKnots
    this.KnotSpec = KnotSpec
    this.WeightsData = WeightsData
  }
  IfcRationalBSplineSurfaceWithKnots.FromTape = function(expressID, type, tape) {
    let UDegree
    UDegree = tape[0]
    let VDegree
    VDegree = tape[1]
    let ControlPointsList
    ControlPointsList = []
    let ControlPointsList_index = 0
    while (ControlPointsList_index < tape[2].length) {
      ControlPointsList.push(tape[2][ControlPointsList_index++])
    }
    let SurfaceForm
    SurfaceForm = new IfcBSplineSurfaceForm(tape[3])
    let UClosed
    UClosed = tape[4]
    let VClosed
    VClosed = tape[5]
    let SelfIntersect
    SelfIntersect = tape[6]
    let UMultiplicities
    UMultiplicities = []
    let UMultiplicities_index = 0
    while (UMultiplicities_index < tape[7].length) {
      UMultiplicities.push(tape[7][UMultiplicities_index++])
    }
    let VMultiplicities
    VMultiplicities = []
    let VMultiplicities_index = 0
    while (VMultiplicities_index < tape[8].length) {
      VMultiplicities.push(tape[8][VMultiplicities_index++])
    }
    let UKnots
    UKnots = []
    let UKnots_index = 0
    while (UKnots_index < tape[9].length) {
      UKnots.push(tape[9][UKnots_index++])
    }
    let VKnots
    VKnots = []
    let VKnots_index = 0
    while (VKnots_index < tape[10].length) {
      VKnots.push(tape[10][VKnots_index++])
    }
    let KnotSpec
    KnotSpec = new IfcKnotType(tape[11])
    let WeightsData
    WeightsData = []
    let WeightsData_index = 0
    while (WeightsData_index < tape[12].length) {
      WeightsData.push(tape[12][WeightsData_index++])
    }
    return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData)
  }
  IfcRationalBSplineSurfaceWithKnots.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.UDegree)
    args.push(REAL)
    args.push(this.VDegree)
    args.push(SET_BEGIN)
    this.ControlPointsList.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.SurfaceForm.value)
    args.push(REAL)
    args.push.apply(args, this.UMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.VMultiplicities)
    args.push(REAL)
    args.push.apply(args, this.UKnots)
    args.push(REAL)
    args.push.apply(args, this.VKnots)
    args.push(ENUM)
    args.push(this.KnotSpec.value)
    args.push(REAL)
    args.push.apply(args, this.WeightsData)
    return args
  }
  return IfcRationalBSplineSurfaceWithKnots
}())
exports.IfcRationalBSplineSurfaceWithKnots = IfcRationalBSplineSurfaceWithKnots

var IfcRectangleHollowProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.XDim = XDim
    this.YDim = YDim
    this.WallThickness = WallThickness
    this.InnerFilletRadius = InnerFilletRadius
    this.OuterFilletRadius = OuterFilletRadius
  }
  IfcRectangleHollowProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let XDim
    XDim = tape[3]
    let YDim
    YDim = tape[4]
    let WallThickness
    WallThickness = tape[5]
    let InnerFilletRadius
    if (tape[6]) {
      InnerFilletRadius = tape[6]
    } else {
      InnerFilletRadius = null
    }
    let OuterFilletRadius
    if (tape[7]) {
      OuterFilletRadius = tape[7]
    } else {
      OuterFilletRadius = null
    }
    return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius)
  }
  IfcRectangleHollowProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.InnerFilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.OuterFilletRadius) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRectangleHollowProfileDef
}())
exports.IfcRectangleHollowProfileDef = IfcRectangleHollowProfileDef

var IfcRectangleProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.XDim = XDim
    this.YDim = YDim
  }
  IfcRectangleProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let XDim
    XDim = tape[3]
    let YDim
    YDim = tape[4]
    return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim)
  }
  IfcRectangleProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRectangleProfileDef
}())
exports.IfcRectangleProfileDef = IfcRectangleProfileDef

var IfcRectangularPyramid = /** @class */ (function() {
  /**
   *
   */
  function IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.XLength = XLength
    this.YLength = YLength
    this.Height = Height
  }
  IfcRectangularPyramid.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let XLength
    XLength = tape[1]
    let YLength
    YLength = tape[2]
    let Height
    Height = tape[3]
    return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height)
  }
  IfcRectangularPyramid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcRectangularPyramid
}())
exports.IfcRectangularPyramid = IfcRectangularPyramid

var IfcRectangularTrimmedSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
    this.expressID = expressID
    this.type = type
    this.BasisSurface = BasisSurface
    this.U1 = U1
    this.V1 = V1
    this.U2 = U2
    this.V2 = V2
    this.Usense = Usense
    this.Vsense = Vsense
  }
  IfcRectangularTrimmedSurface.FromTape = function(expressID, type, tape) {
    let BasisSurface
    BasisSurface = tape[0]
    let U1
    U1 = tape[1]
    let V1
    V1 = tape[2]
    let U2
    U2 = tape[3]
    let V2
    V2 = tape[4]
    let Usense
    Usense = tape[5]
    let Vsense
    Vsense = tape[6]
    return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense)
  }
  IfcRectangularTrimmedSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisSurface)
    args.push(REAL)
    args.push(this.U1)
    args.push(REAL)
    args.push(this.V1)
    args.push(REAL)
    args.push(this.U2)
    args.push(REAL)
    args.push(this.V2)
    return args
  }
  return IfcRectangularTrimmedSurface
}())
exports.IfcRectangularTrimmedSurface = IfcRectangularTrimmedSurface

var IfcRecurrencePattern = /** @class */ (function() {
  /**
   *
   */
  function IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
    this.expressID = expressID
    this.type = type
    this.RecurrenceType = RecurrenceType
    this.DayComponent = DayComponent
    this.WeekdayComponent = WeekdayComponent
    this.MonthComponent = MonthComponent
    this.Position = Position
    this.Interval = Interval
    this.Occurrences = Occurrences
    this.TimePeriods = TimePeriods
  }
  IfcRecurrencePattern.FromTape = function(expressID, type, tape) {
    let RecurrenceType
    RecurrenceType = new IfcRecurrenceTypeEnum(tape[0])
    let DayComponent
    if (tape[1]) {
      DayComponent = []
      let DayComponent_index = 0
      while (DayComponent_index < tape[1].length) {
        DayComponent.push(tape[1][DayComponent_index++])
      }
    } else {
      DayComponent = null
    }
    let WeekdayComponent
    if (tape[2]) {
      WeekdayComponent = []
      let WeekdayComponent_index = 0
      while (WeekdayComponent_index < tape[2].length) {
        WeekdayComponent.push(tape[2][WeekdayComponent_index++])
      }
    } else {
      WeekdayComponent = null
    }
    let MonthComponent
    if (tape[3]) {
      MonthComponent = []
      let MonthComponent_index = 0
      while (MonthComponent_index < tape[3].length) {
        MonthComponent.push(tape[3][MonthComponent_index++])
      }
    } else {
      MonthComponent = null
    }
    let Position
    if (tape[4]) {
      Position = tape[4]
    } else {
      Position = null
    }
    let Interval
    if (tape[5]) {
      Interval = tape[5]
    } else {
      Interval = null
    }
    let Occurrences
    if (tape[6]) {
      Occurrences = tape[6]
    } else {
      Occurrences = null
    }
    let TimePeriods
    if (tape[7]) {
      TimePeriods = []
      let TimePeriods_index = 0
      while (TimePeriods_index < tape[7].length) {
        TimePeriods.push(tape[7][TimePeriods_index++])
      }
    } else {
      TimePeriods = null
    }
    return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods)
  }
  IfcRecurrencePattern.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.RecurrenceType.value)
    if (this.DayComponent) {
      args.push(REAL)
      args.push.apply(args, this.DayComponent)
    } else {
      args.push(EMPTY)
    }
    if (this.WeekdayComponent) {
      args.push(REAL)
      args.push.apply(args, this.WeekdayComponent)
    } else {
      args.push(EMPTY)
    }
    if (this.MonthComponent) {
      args.push(REAL)
      args.push.apply(args, this.MonthComponent)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REAL)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.Interval) {
      args.push(REAL)
      args.push(this.Interval)
    } else {
      args.push(EMPTY)
    }
    if (this.Occurrences) {
      args.push(REAL)
      args.push(this.Occurrences)
    } else {
      args.push(EMPTY)
    }
    if (this.TimePeriods) {
      args.push(SET_BEGIN)
      this.TimePeriods.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRecurrencePattern
}())
exports.IfcRecurrencePattern = IfcRecurrencePattern

var IfcReference = /** @class */ (function() {
  /**
   *
   */
  function IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
    this.expressID = expressID
    this.type = type
    this.TypeIdentifier = TypeIdentifier
    this.AttributeIdentifier = AttributeIdentifier
    this.InstanceName = InstanceName
    this.ListPositions = ListPositions
    this.InnerReference = InnerReference
  }
  IfcReference.FromTape = function(expressID, type, tape) {
    let TypeIdentifier
    if (tape[0]) {
      TypeIdentifier = tape[0]
    } else {
      TypeIdentifier = null
    }
    let AttributeIdentifier
    if (tape[1]) {
      AttributeIdentifier = tape[1]
    } else {
      AttributeIdentifier = null
    }
    let InstanceName
    if (tape[2]) {
      InstanceName = tape[2]
    } else {
      InstanceName = null
    }
    let ListPositions
    if (tape[3]) {
      ListPositions = []
      let ListPositions_index = 0
      while (ListPositions_index < tape[3].length) {
        ListPositions.push(tape[3][ListPositions_index++])
      }
    } else {
      ListPositions = null
    }
    let InnerReference
    if (tape[4]) {
      InnerReference = tape[4]
    } else {
      InnerReference = null
    }
    return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference)
  }
  IfcReference.prototype.ToTape = function() {
    const args = []
    if (this.TypeIdentifier) {
      args.push(STRING)
      args.push(this.TypeIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.AttributeIdentifier) {
      args.push(STRING)
      args.push(this.AttributeIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.InstanceName) {
      args.push(STRING)
      args.push(this.InstanceName)
    } else {
      args.push(EMPTY)
    }
    if (this.ListPositions) {
      args.push(REAL)
      args.push.apply(args, this.ListPositions)
    } else {
      args.push(EMPTY)
    }
    if (this.InnerReference) {
      args.push(REF)
      args.push(this.InnerReference)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReference
}())
exports.IfcReference = IfcReference

var IfcReferent = /** @class */ (function() {
  /**
   *
   */
  function IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.PredefinedType = PredefinedType
    this.RestartDistance = RestartDistance
  }
  IfcReferent.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let PredefinedType
    if (tape[7]) {
      PredefinedType = new IfcReferentTypeEnum(tape[7])
    } else {
      PredefinedType = null
    }
    let RestartDistance
    if (tape[8]) {
      RestartDistance = tape[8]
    } else {
      RestartDistance = null
    }
    return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance)
  }
  IfcReferent.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.RestartDistance) {
      args.push(REAL)
      args.push(this.RestartDistance)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReferent
}())
exports.IfcReferent = IfcReferent

var IfcRegularTimeSeries = /** @class */ (function() {
  /**
   *
   */
  function IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.StartTime = StartTime
    this.EndTime = EndTime
    this.TimeSeriesDataType = TimeSeriesDataType
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.Unit = Unit
    this.TimeStep = TimeStep
    this.Values = Values
  }
  IfcRegularTimeSeries.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let StartTime
    StartTime = tape[2]
    let EndTime
    EndTime = tape[3]
    let TimeSeriesDataType
    TimeSeriesDataType = new IfcTimeSeriesDataTypeEnum(tape[4])
    let DataOrigin
    DataOrigin = new IfcDataOriginEnum(tape[5])
    let UserDefinedDataOrigin
    if (tape[6]) {
      UserDefinedDataOrigin = tape[6]
    } else {
      UserDefinedDataOrigin = null
    }
    let Unit
    if (tape[7]) {
      Unit = ParseType(tape[7], tape[8][0])
    } else {
      Unit = null
    }
    let TimeStep
    TimeStep = tape[8]
    let Values
    Values = []
    let Values_index = 0
    while (Values_index < tape[9].length) {
      Values.push(tape[9][Values_index++])
    }
    return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values)
  }
  IfcRegularTimeSeries.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    args.push(STRING)
    args.push(this.EndTime)
    args.push(ENUM)
    args.push(this.TimeSeriesDataType.value)
    args.push(ENUM)
    args.push(this.DataOrigin.value)
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.TimeStep)
    args.push(SET_BEGIN)
    this.Values.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRegularTimeSeries
}())
exports.IfcRegularTimeSeries = IfcRegularTimeSeries

var IfcReinforcementBarProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
    this.expressID = expressID
    this.type = type
    this.TotalCrossSectionArea = TotalCrossSectionArea
    this.SteelGrade = SteelGrade
    this.BarSurface = BarSurface
    this.EffectiveDepth = EffectiveDepth
    this.NominalBarDiameter = NominalBarDiameter
    this.BarCount = BarCount
  }
  IfcReinforcementBarProperties.FromTape = function(expressID, type, tape) {
    let TotalCrossSectionArea
    TotalCrossSectionArea = tape[0]
    let SteelGrade
    SteelGrade = tape[1]
    let BarSurface
    if (tape[2]) {
      BarSurface = new IfcReinforcingBarSurfaceEnum(tape[2])
    } else {
      BarSurface = null
    }
    let EffectiveDepth
    if (tape[3]) {
      EffectiveDepth = tape[3]
    } else {
      EffectiveDepth = null
    }
    let NominalBarDiameter
    if (tape[4]) {
      NominalBarDiameter = tape[4]
    } else {
      NominalBarDiameter = null
    }
    let BarCount
    if (tape[5]) {
      BarCount = tape[5]
    } else {
      BarCount = null
    }
    return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount)
  }
  IfcReinforcementBarProperties.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.TotalCrossSectionArea)
    args.push(STRING)
    args.push(this.SteelGrade)
    if (this.BarSurface) {
      args.push(ENUM)
      args.push(this.BarSurface.value)
    } else {
      args.push(EMPTY)
    }
    if (this.EffectiveDepth) {
      args.push(REAL)
      args.push(this.EffectiveDepth)
    } else {
      args.push(EMPTY)
    }
    if (this.NominalBarDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.BarCount) {
      args.push(REAL)
      args.push(this.BarCount)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcementBarProperties
}())
exports.IfcReinforcementBarProperties = IfcReinforcementBarProperties

var IfcReinforcementDefinitionProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.DefinitionType = DefinitionType
    this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions
  }
  IfcReinforcementDefinitionProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let DefinitionType
    if (tape[4]) {
      DefinitionType = tape[4]
    } else {
      DefinitionType = null
    }
    let ReinforcementSectionDefinitions
    ReinforcementSectionDefinitions = []
    let ReinforcementSectionDefinitions_index = 0
    while (ReinforcementSectionDefinitions_index < tape[5].length) {
      ReinforcementSectionDefinitions.push(tape[5][ReinforcementSectionDefinitions_index++])
    }
    return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions)
  }
  IfcReinforcementDefinitionProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.DefinitionType) {
      args.push(STRING)
      args.push(this.DefinitionType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.ReinforcementSectionDefinitions.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcReinforcementDefinitionProperties
}())
exports.IfcReinforcementDefinitionProperties = IfcReinforcementDefinitionProperties

var IfcReinforcingBar = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
    this.NominalDiameter = NominalDiameter
    this.CrossSectionArea = CrossSectionArea
    this.BarLength = BarLength
    this.PredefinedType = PredefinedType
    this.BarSurface = BarSurface
  }
  IfcReinforcingBar.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    let NominalDiameter
    if (tape[9]) {
      NominalDiameter = tape[9]
    } else {
      NominalDiameter = null
    }
    let CrossSectionArea
    if (tape[10]) {
      CrossSectionArea = tape[10]
    } else {
      CrossSectionArea = null
    }
    let BarLength
    if (tape[11]) {
      BarLength = tape[11]
    } else {
      BarLength = null
    }
    let PredefinedType
    if (tape[12]) {
      PredefinedType = new IfcReinforcingBarTypeEnum(tape[12])
    } else {
      PredefinedType = null
    }
    let BarSurface
    if (tape[13]) {
      BarSurface = new IfcReinforcingBarSurfaceEnum(tape[13])
    } else {
      BarSurface = null
    }
    return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface)
  }
  IfcReinforcingBar.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.CrossSectionArea) {
      args.push(REAL)
      args.push(this.CrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.BarLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.BarSurface) {
      args.push(ENUM)
      args.push(this.BarSurface.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingBar
}())
exports.IfcReinforcingBar = IfcReinforcingBar

var IfcReinforcingBarType = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.NominalDiameter = NominalDiameter
    this.CrossSectionArea = CrossSectionArea
    this.BarLength = BarLength
    this.BarSurface = BarSurface
    this.BendingShapeCode = BendingShapeCode
    this.BendingParameters = BendingParameters
  }
  IfcReinforcingBarType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcReinforcingBarTypeEnum(tape[9])
    let NominalDiameter
    if (tape[10]) {
      NominalDiameter = tape[10]
    } else {
      NominalDiameter = null
    }
    let CrossSectionArea
    if (tape[11]) {
      CrossSectionArea = tape[11]
    } else {
      CrossSectionArea = null
    }
    let BarLength
    if (tape[12]) {
      BarLength = tape[12]
    } else {
      BarLength = null
    }
    let BarSurface
    if (tape[13]) {
      BarSurface = new IfcReinforcingBarSurfaceEnum(tape[13])
    } else {
      BarSurface = null
    }
    let BendingShapeCode
    if (tape[14]) {
      BendingShapeCode = tape[14]
    } else {
      BendingShapeCode = null
    }
    let BendingParameters
    if (tape[15]) {
      BendingParameters = []
      let BendingParameters_index = 0
      while (BendingParameters_index < tape[15].length) {
        BendingParameters.push(ParseType(tape[15][BendingParameters_index++], tape[15][BendingParameters_index++][0]))
      }
    } else {
      BendingParameters = null
    }
    return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters)
  }
  IfcReinforcingBarType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.CrossSectionArea) {
      args.push(REAL)
      args.push(this.CrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.BarLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.BarSurface) {
      args.push(ENUM)
      args.push(this.BarSurface.value)
    } else {
      args.push(EMPTY)
    }
    if (this.BendingShapeCode) {
      args.push(STRING)
      args.push(this.BendingShapeCode)
    } else {
      args.push(EMPTY)
    }
    if (this.BendingParameters) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingBarType
}())
exports.IfcReinforcingBarType = IfcReinforcingBarType

var IfcReinforcingElement = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
  }
  IfcReinforcingElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
  }
  IfcReinforcingElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingElement
}())
exports.IfcReinforcingElement = IfcReinforcingElement

var IfcReinforcingElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcReinforcingElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcReinforcingElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingElementType
}())
exports.IfcReinforcingElementType = IfcReinforcingElementType

var IfcReinforcingMesh = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
    this.MeshLength = MeshLength
    this.MeshWidth = MeshWidth
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea
    this.LongitudinalBarSpacing = LongitudinalBarSpacing
    this.TransverseBarSpacing = TransverseBarSpacing
    this.PredefinedType = PredefinedType
  }
  IfcReinforcingMesh.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    let MeshLength
    if (tape[9]) {
      MeshLength = tape[9]
    } else {
      MeshLength = null
    }
    let MeshWidth
    if (tape[10]) {
      MeshWidth = tape[10]
    } else {
      MeshWidth = null
    }
    let LongitudinalBarNominalDiameter
    if (tape[11]) {
      LongitudinalBarNominalDiameter = tape[11]
    } else {
      LongitudinalBarNominalDiameter = null
    }
    let TransverseBarNominalDiameter
    if (tape[12]) {
      TransverseBarNominalDiameter = tape[12]
    } else {
      TransverseBarNominalDiameter = null
    }
    let LongitudinalBarCrossSectionArea
    if (tape[13]) {
      LongitudinalBarCrossSectionArea = tape[13]
    } else {
      LongitudinalBarCrossSectionArea = null
    }
    let TransverseBarCrossSectionArea
    if (tape[14]) {
      TransverseBarCrossSectionArea = tape[14]
    } else {
      TransverseBarCrossSectionArea = null
    }
    let LongitudinalBarSpacing
    if (tape[15]) {
      LongitudinalBarSpacing = tape[15]
    } else {
      LongitudinalBarSpacing = null
    }
    let TransverseBarSpacing
    if (tape[16]) {
      TransverseBarSpacing = tape[16]
    } else {
      TransverseBarSpacing = null
    }
    let PredefinedType
    if (tape[17]) {
      PredefinedType = new IfcReinforcingMeshTypeEnum(tape[17])
    } else {
      PredefinedType = null
    }
    return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType)
  }
  IfcReinforcingMesh.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    if (this.MeshLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.MeshWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarNominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarNominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarCrossSectionArea) {
      args.push(REAL)
      args.push(this.LongitudinalBarCrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarCrossSectionArea) {
      args.push(REAL)
      args.push(this.TransverseBarCrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingMesh
}())
exports.IfcReinforcingMesh = IfcReinforcingMesh

var IfcReinforcingMeshType = /** @class */ (function() {
  /**
   *
   */
  function IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.MeshLength = MeshLength
    this.MeshWidth = MeshWidth
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea
    this.LongitudinalBarSpacing = LongitudinalBarSpacing
    this.TransverseBarSpacing = TransverseBarSpacing
    this.BendingShapeCode = BendingShapeCode
    this.BendingParameters = BendingParameters
  }
  IfcReinforcingMeshType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcReinforcingMeshTypeEnum(tape[9])
    let MeshLength
    if (tape[10]) {
      MeshLength = tape[10]
    } else {
      MeshLength = null
    }
    let MeshWidth
    if (tape[11]) {
      MeshWidth = tape[11]
    } else {
      MeshWidth = null
    }
    let LongitudinalBarNominalDiameter
    if (tape[12]) {
      LongitudinalBarNominalDiameter = tape[12]
    } else {
      LongitudinalBarNominalDiameter = null
    }
    let TransverseBarNominalDiameter
    if (tape[13]) {
      TransverseBarNominalDiameter = tape[13]
    } else {
      TransverseBarNominalDiameter = null
    }
    let LongitudinalBarCrossSectionArea
    if (tape[14]) {
      LongitudinalBarCrossSectionArea = tape[14]
    } else {
      LongitudinalBarCrossSectionArea = null
    }
    let TransverseBarCrossSectionArea
    if (tape[15]) {
      TransverseBarCrossSectionArea = tape[15]
    } else {
      TransverseBarCrossSectionArea = null
    }
    let LongitudinalBarSpacing
    if (tape[16]) {
      LongitudinalBarSpacing = tape[16]
    } else {
      LongitudinalBarSpacing = null
    }
    let TransverseBarSpacing
    if (tape[17]) {
      TransverseBarSpacing = tape[17]
    } else {
      TransverseBarSpacing = null
    }
    let BendingShapeCode
    if (tape[18]) {
      BendingShapeCode = tape[18]
    } else {
      BendingShapeCode = null
    }
    let BendingParameters
    if (tape[19]) {
      BendingParameters = []
      let BendingParameters_index = 0
      while (BendingParameters_index < tape[19].length) {
        BendingParameters.push(ParseType(tape[19][BendingParameters_index++], tape[19][BendingParameters_index++][0]))
      }
    } else {
      BendingParameters = null
    }
    return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters)
  }
  IfcReinforcingMeshType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.MeshLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.MeshWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarNominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarNominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarCrossSectionArea) {
      args.push(REAL)
      args.push(this.LongitudinalBarCrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarCrossSectionArea) {
      args.push(REAL)
      args.push(this.TransverseBarCrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.LongitudinalBarSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransverseBarSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.BendingShapeCode) {
      args.push(STRING)
      args.push(this.BendingShapeCode)
    } else {
      args.push(EMPTY)
    }
    if (this.BendingParameters) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcReinforcingMeshType
}())
exports.IfcReinforcingMeshType = IfcReinforcingMeshType

var IfcRelAggregates = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingObject = RelatingObject
    this.RelatedObjects = RelatedObjects
  }
  IfcRelAggregates.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingObject
    RelatingObject = tape[4]
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[5].length) {
      RelatedObjects.push(tape[5][RelatedObjects_index++])
    }
    return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects)
  }
  IfcRelAggregates.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingObject)
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelAggregates
}())
exports.IfcRelAggregates = IfcRelAggregates

var IfcRelAssigns = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
  }
  IfcRelAssigns.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
  }
  IfcRelAssigns.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssigns
}())
exports.IfcRelAssigns = IfcRelAssigns

var IfcRelAssignsToActor = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingActor = RelatingActor
    this.ActingRole = ActingRole
  }
  IfcRelAssignsToActor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingActor
    RelatingActor = tape[6]
    let ActingRole
    if (tape[7]) {
      ActingRole = tape[7]
    } else {
      ActingRole = null
    }
    return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole)
  }
  IfcRelAssignsToActor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingActor)
    if (this.ActingRole) {
      args.push(REF)
      args.push(this.ActingRole)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssignsToActor
}())
exports.IfcRelAssignsToActor = IfcRelAssignsToActor

var IfcRelAssignsToControl = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingControl = RelatingControl
  }
  IfcRelAssignsToControl.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingControl
    RelatingControl = tape[6]
    return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl)
  }
  IfcRelAssignsToControl.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingControl)
    return args
  }
  return IfcRelAssignsToControl
}())
exports.IfcRelAssignsToControl = IfcRelAssignsToControl

var IfcRelAssignsToGroup = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingGroup = RelatingGroup
  }
  IfcRelAssignsToGroup.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingGroup
    RelatingGroup = tape[6]
    return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup)
  }
  IfcRelAssignsToGroup.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingGroup)
    return args
  }
  return IfcRelAssignsToGroup
}())
exports.IfcRelAssignsToGroup = IfcRelAssignsToGroup

var IfcRelAssignsToGroupByFactor = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingGroup = RelatingGroup
    this.Factor = Factor
  }
  IfcRelAssignsToGroupByFactor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingGroup
    RelatingGroup = tape[6]
    let Factor
    Factor = tape[7]
    return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor)
  }
  IfcRelAssignsToGroupByFactor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingGroup)
    args.push(REAL)
    args.push(this.Factor)
    return args
  }
  return IfcRelAssignsToGroupByFactor
}())
exports.IfcRelAssignsToGroupByFactor = IfcRelAssignsToGroupByFactor

var IfcRelAssignsToProcess = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingProcess = RelatingProcess
    this.QuantityInProcess = QuantityInProcess
  }
  IfcRelAssignsToProcess.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingProcess
    RelatingProcess = ParseType(tape[6], tape[7][0])
    let QuantityInProcess
    if (tape[7]) {
      QuantityInProcess = tape[7]
    } else {
      QuantityInProcess = null
    }
    return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess)
  }
  IfcRelAssignsToProcess.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.QuantityInProcess) {
      args.push(REF)
      args.push(this.QuantityInProcess)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssignsToProcess
}())
exports.IfcRelAssignsToProcess = IfcRelAssignsToProcess

var IfcRelAssignsToProduct = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingProduct = RelatingProduct
  }
  IfcRelAssignsToProduct.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingProduct
    RelatingProduct = ParseType(tape[6], tape[7][0])
    return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct)
  }
  IfcRelAssignsToProduct.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssignsToProduct
}())
exports.IfcRelAssignsToProduct = IfcRelAssignsToProduct

var IfcRelAssignsToResource = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatedObjectsType = RelatedObjectsType
    this.RelatingResource = RelatingResource
  }
  IfcRelAssignsToResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatedObjectsType
    if (tape[5]) {
      RelatedObjectsType = new IfcObjectTypeEnum(tape[5])
    } else {
      RelatedObjectsType = null
    }
    let RelatingResource
    RelatingResource = ParseType(tape[6], tape[7][0])
    return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource)
  }
  IfcRelAssignsToResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.RelatedObjectsType) {
      args.push(ENUM)
      args.push(this.RelatedObjectsType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssignsToResource
}())
exports.IfcRelAssignsToResource = IfcRelAssignsToResource

var IfcRelAssociates = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
  }
  IfcRelAssociates.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects)
  }
  IfcRelAssociates.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssociates
}())
exports.IfcRelAssociates = IfcRelAssociates

var IfcRelAssociatesApproval = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingApproval = RelatingApproval
  }
  IfcRelAssociatesApproval.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let RelatingApproval
    RelatingApproval = tape[5]
    return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval)
  }
  IfcRelAssociatesApproval.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingApproval)
    return args
  }
  return IfcRelAssociatesApproval
}())
exports.IfcRelAssociatesApproval = IfcRelAssociatesApproval

var IfcRelAssociatesClassification = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingClassification = RelatingClassification
  }
  IfcRelAssociatesClassification.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let RelatingClassification
    RelatingClassification = ParseType(tape[5], tape[6][0])
    return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification)
  }
  IfcRelAssociatesClassification.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssociatesClassification
}())
exports.IfcRelAssociatesClassification = IfcRelAssociatesClassification

var IfcRelAssociatesConstraint = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.Intent = Intent
    this.RelatingConstraint = RelatingConstraint
  }
  IfcRelAssociatesConstraint.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let Intent
    if (tape[5]) {
      Intent = tape[5]
    } else {
      Intent = null
    }
    let RelatingConstraint
    RelatingConstraint = tape[6]
    return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint)
  }
  IfcRelAssociatesConstraint.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Intent) {
      args.push(STRING)
      args.push(this.Intent)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingConstraint)
    return args
  }
  return IfcRelAssociatesConstraint
}())
exports.IfcRelAssociatesConstraint = IfcRelAssociatesConstraint

var IfcRelAssociatesDocument = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingDocument = RelatingDocument
  }
  IfcRelAssociatesDocument.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let RelatingDocument
    RelatingDocument = ParseType(tape[5], tape[6][0])
    return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument)
  }
  IfcRelAssociatesDocument.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssociatesDocument
}())
exports.IfcRelAssociatesDocument = IfcRelAssociatesDocument

var IfcRelAssociatesLibrary = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingLibrary = RelatingLibrary
  }
  IfcRelAssociatesLibrary.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let RelatingLibrary
    RelatingLibrary = ParseType(tape[5], tape[6][0])
    return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary)
  }
  IfcRelAssociatesLibrary.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssociatesLibrary
}())
exports.IfcRelAssociatesLibrary = IfcRelAssociatesLibrary

var IfcRelAssociatesMaterial = /** @class */ (function() {
  /**
   *
   */
  function IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingMaterial = RelatingMaterial
  }
  IfcRelAssociatesMaterial.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(ParseType(tape[4][RelatedObjects_index++], tape[4][RelatedObjects_index++][0]))
    }
    let RelatingMaterial
    RelatingMaterial = ParseType(tape[5], tape[6][0])
    return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial)
  }
  IfcRelAssociatesMaterial.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelAssociatesMaterial
}())
exports.IfcRelAssociatesMaterial = IfcRelAssociatesMaterial

var IfcRelConnects = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcRelConnects.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcRelConnects.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelConnects
}())
exports.IfcRelConnects = IfcRelConnects

var IfcRelConnectsElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ConnectionGeometry = ConnectionGeometry
    this.RelatingElement = RelatingElement
    this.RelatedElement = RelatedElement
  }
  IfcRelConnectsElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ConnectionGeometry
    if (tape[4]) {
      ConnectionGeometry = tape[4]
    } else {
      ConnectionGeometry = null
    }
    let RelatingElement
    RelatingElement = tape[5]
    let RelatedElement
    RelatedElement = tape[6]
    return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
  }
  IfcRelConnectsElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingElement)
    args.push(REF)
    args.push(this.RelatedElement)
    return args
  }
  return IfcRelConnectsElements
}())
exports.IfcRelConnectsElements = IfcRelConnectsElements

var IfcRelConnectsPathElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ConnectionGeometry = ConnectionGeometry
    this.RelatingElement = RelatingElement
    this.RelatedElement = RelatedElement
    this.RelatingPriorities = RelatingPriorities
    this.RelatedPriorities = RelatedPriorities
    this.RelatedConnectionType = RelatedConnectionType
    this.RelatingConnectionType = RelatingConnectionType
  }
  IfcRelConnectsPathElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ConnectionGeometry
    if (tape[4]) {
      ConnectionGeometry = tape[4]
    } else {
      ConnectionGeometry = null
    }
    let RelatingElement
    RelatingElement = tape[5]
    let RelatedElement
    RelatedElement = tape[6]
    let RelatingPriorities
    RelatingPriorities = []
    let RelatingPriorities_index = 0
    while (RelatingPriorities_index < tape[7].length) {
      RelatingPriorities.push(tape[7][RelatingPriorities_index++])
    }
    let RelatedPriorities
    RelatedPriorities = []
    let RelatedPriorities_index = 0
    while (RelatedPriorities_index < tape[8].length) {
      RelatedPriorities.push(tape[8][RelatedPriorities_index++])
    }
    let RelatedConnectionType
    RelatedConnectionType = new IfcConnectionTypeEnum(tape[9])
    let RelatingConnectionType
    RelatingConnectionType = new IfcConnectionTypeEnum(tape[10])
    return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType)
  }
  IfcRelConnectsPathElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingElement)
    args.push(REF)
    args.push(this.RelatedElement)
    args.push(REAL)
    args.push.apply(args, this.RelatingPriorities)
    args.push(REAL)
    args.push.apply(args, this.RelatedPriorities)
    args.push(ENUM)
    args.push(this.RelatedConnectionType.value)
    args.push(ENUM)
    args.push(this.RelatingConnectionType.value)
    return args
  }
  return IfcRelConnectsPathElements
}())
exports.IfcRelConnectsPathElements = IfcRelConnectsPathElements

var IfcRelConnectsPortToElement = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingPort = RelatingPort
    this.RelatedElement = RelatedElement
  }
  IfcRelConnectsPortToElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingPort
    RelatingPort = tape[4]
    let RelatedElement
    RelatedElement = tape[5]
    return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement)
  }
  IfcRelConnectsPortToElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingPort)
    args.push(REF)
    args.push(this.RelatedElement)
    return args
  }
  return IfcRelConnectsPortToElement
}())
exports.IfcRelConnectsPortToElement = IfcRelConnectsPortToElement

var IfcRelConnectsPorts = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingPort = RelatingPort
    this.RelatedPort = RelatedPort
    this.RealizingElement = RealizingElement
  }
  IfcRelConnectsPorts.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingPort
    RelatingPort = tape[4]
    let RelatedPort
    RelatedPort = tape[5]
    let RealizingElement
    if (tape[6]) {
      RealizingElement = tape[6]
    } else {
      RealizingElement = null
    }
    return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement)
  }
  IfcRelConnectsPorts.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingPort)
    args.push(REF)
    args.push(this.RelatedPort)
    if (this.RealizingElement) {
      args.push(REF)
      args.push(this.RealizingElement)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelConnectsPorts
}())
exports.IfcRelConnectsPorts = IfcRelConnectsPorts

var IfcRelConnectsStructuralActivity = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingElement = RelatingElement
    this.RelatedStructuralActivity = RelatedStructuralActivity
  }
  IfcRelConnectsStructuralActivity.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingElement
    RelatingElement = ParseType(tape[4], tape[5][0])
    let RelatedStructuralActivity
    RelatedStructuralActivity = tape[5]
    return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity)
  }
  IfcRelConnectsStructuralActivity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatedStructuralActivity)
    return args
  }
  return IfcRelConnectsStructuralActivity
}())
exports.IfcRelConnectsStructuralActivity = IfcRelConnectsStructuralActivity

var IfcRelConnectsStructuralMember = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingStructuralMember = RelatingStructuralMember
    this.RelatedStructuralConnection = RelatedStructuralConnection
    this.AppliedCondition = AppliedCondition
    this.AdditionalConditions = AdditionalConditions
    this.SupportedLength = SupportedLength
    this.ConditionCoordinateSystem = ConditionCoordinateSystem
  }
  IfcRelConnectsStructuralMember.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingStructuralMember
    RelatingStructuralMember = tape[4]
    let RelatedStructuralConnection
    RelatedStructuralConnection = tape[5]
    let AppliedCondition
    if (tape[6]) {
      AppliedCondition = tape[6]
    } else {
      AppliedCondition = null
    }
    let AdditionalConditions
    if (tape[7]) {
      AdditionalConditions = tape[7]
    } else {
      AdditionalConditions = null
    }
    let SupportedLength
    if (tape[8]) {
      SupportedLength = tape[8]
    } else {
      SupportedLength = null
    }
    let ConditionCoordinateSystem
    if (tape[9]) {
      ConditionCoordinateSystem = tape[9]
    } else {
      ConditionCoordinateSystem = null
    }
    return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem)
  }
  IfcRelConnectsStructuralMember.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingStructuralMember)
    args.push(REF)
    args.push(this.RelatedStructuralConnection)
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    if (this.AdditionalConditions) {
      args.push(REF)
      args.push(this.AdditionalConditions)
    } else {
      args.push(EMPTY)
    }
    if (this.SupportedLength) {
      args.push(REAL)
      args.push(this.SupportedLength)
    } else {
      args.push(EMPTY)
    }
    if (this.ConditionCoordinateSystem) {
      args.push(REF)
      args.push(this.ConditionCoordinateSystem)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelConnectsStructuralMember
}())
exports.IfcRelConnectsStructuralMember = IfcRelConnectsStructuralMember

var IfcRelConnectsWithEccentricity = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingStructuralMember = RelatingStructuralMember
    this.RelatedStructuralConnection = RelatedStructuralConnection
    this.AppliedCondition = AppliedCondition
    this.AdditionalConditions = AdditionalConditions
    this.SupportedLength = SupportedLength
    this.ConditionCoordinateSystem = ConditionCoordinateSystem
    this.ConnectionConstraint = ConnectionConstraint
  }
  IfcRelConnectsWithEccentricity.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingStructuralMember
    RelatingStructuralMember = tape[4]
    let RelatedStructuralConnection
    RelatedStructuralConnection = tape[5]
    let AppliedCondition
    if (tape[6]) {
      AppliedCondition = tape[6]
    } else {
      AppliedCondition = null
    }
    let AdditionalConditions
    if (tape[7]) {
      AdditionalConditions = tape[7]
    } else {
      AdditionalConditions = null
    }
    let SupportedLength
    if (tape[8]) {
      SupportedLength = tape[8]
    } else {
      SupportedLength = null
    }
    let ConditionCoordinateSystem
    if (tape[9]) {
      ConditionCoordinateSystem = tape[9]
    } else {
      ConditionCoordinateSystem = null
    }
    let ConnectionConstraint
    ConnectionConstraint = tape[10]
    return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint)
  }
  IfcRelConnectsWithEccentricity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingStructuralMember)
    args.push(REF)
    args.push(this.RelatedStructuralConnection)
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    if (this.AdditionalConditions) {
      args.push(REF)
      args.push(this.AdditionalConditions)
    } else {
      args.push(EMPTY)
    }
    if (this.SupportedLength) {
      args.push(REAL)
      args.push(this.SupportedLength)
    } else {
      args.push(EMPTY)
    }
    if (this.ConditionCoordinateSystem) {
      args.push(REF)
      args.push(this.ConditionCoordinateSystem)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ConnectionConstraint)
    return args
  }
  return IfcRelConnectsWithEccentricity
}())
exports.IfcRelConnectsWithEccentricity = IfcRelConnectsWithEccentricity

var IfcRelConnectsWithRealizingElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ConnectionGeometry = ConnectionGeometry
    this.RelatingElement = RelatingElement
    this.RelatedElement = RelatedElement
    this.RealizingElements = RealizingElements
    this.ConnectionType = ConnectionType
  }
  IfcRelConnectsWithRealizingElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ConnectionGeometry
    if (tape[4]) {
      ConnectionGeometry = tape[4]
    } else {
      ConnectionGeometry = null
    }
    let RelatingElement
    RelatingElement = tape[5]
    let RelatedElement
    RelatedElement = tape[6]
    let RealizingElements
    RealizingElements = []
    let RealizingElements_index = 0
    while (RealizingElements_index < tape[7].length) {
      RealizingElements.push(tape[7][RealizingElements_index++])
    }
    let ConnectionType
    if (tape[8]) {
      ConnectionType = tape[8]
    } else {
      ConnectionType = null
    }
    return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType)
  }
  IfcRelConnectsWithRealizingElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingElement)
    args.push(REF)
    args.push(this.RelatedElement)
    args.push(SET_BEGIN)
    this.RealizingElements.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.ConnectionType) {
      args.push(STRING)
      args.push(this.ConnectionType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelConnectsWithRealizingElements
}())
exports.IfcRelConnectsWithRealizingElements = IfcRelConnectsWithRealizingElements

var IfcRelContainedInSpatialStructure = /** @class */ (function() {
  /**
   *
   */
  function IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedElements = RelatedElements
    this.RelatingStructure = RelatingStructure
  }
  IfcRelContainedInSpatialStructure.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedElements
    RelatedElements = []
    let RelatedElements_index = 0
    while (RelatedElements_index < tape[4].length) {
      RelatedElements.push(tape[4][RelatedElements_index++])
    }
    let RelatingStructure
    RelatingStructure = tape[5]
    return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure)
  }
  IfcRelContainedInSpatialStructure.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedElements.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingStructure)
    return args
  }
  return IfcRelContainedInSpatialStructure
}())
exports.IfcRelContainedInSpatialStructure = IfcRelContainedInSpatialStructure

var IfcRelCoversBldgElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingBuildingElement = RelatingBuildingElement
    this.RelatedCoverings = RelatedCoverings
  }
  IfcRelCoversBldgElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingBuildingElement
    RelatingBuildingElement = tape[4]
    let RelatedCoverings
    RelatedCoverings = []
    let RelatedCoverings_index = 0
    while (RelatedCoverings_index < tape[5].length) {
      RelatedCoverings.push(tape[5][RelatedCoverings_index++])
    }
    return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings)
  }
  IfcRelCoversBldgElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingBuildingElement)
    args.push(SET_BEGIN)
    this.RelatedCoverings.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelCoversBldgElements
}())
exports.IfcRelCoversBldgElements = IfcRelCoversBldgElements

var IfcRelCoversSpaces = /** @class */ (function() {
  /**
   *
   */
  function IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingSpace = RelatingSpace
    this.RelatedCoverings = RelatedCoverings
  }
  IfcRelCoversSpaces.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingSpace
    RelatingSpace = tape[4]
    let RelatedCoverings
    RelatedCoverings = []
    let RelatedCoverings_index = 0
    while (RelatedCoverings_index < tape[5].length) {
      RelatedCoverings.push(tape[5][RelatedCoverings_index++])
    }
    return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings)
  }
  IfcRelCoversSpaces.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingSpace)
    args.push(SET_BEGIN)
    this.RelatedCoverings.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelCoversSpaces
}())
exports.IfcRelCoversSpaces = IfcRelCoversSpaces

var IfcRelDeclares = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingContext = RelatingContext
    this.RelatedDefinitions = RelatedDefinitions
  }
  IfcRelDeclares.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingContext
    RelatingContext = tape[4]
    let RelatedDefinitions
    RelatedDefinitions = []
    let RelatedDefinitions_index = 0
    while (RelatedDefinitions_index < tape[5].length) {
      RelatedDefinitions.push(ParseType(tape[5][RelatedDefinitions_index++], tape[5][RelatedDefinitions_index++][0]))
    }
    return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions)
  }
  IfcRelDeclares.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingContext)
    return args
  }
  return IfcRelDeclares
}())
exports.IfcRelDeclares = IfcRelDeclares

var IfcRelDecomposes = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcRelDecomposes.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcRelDecomposes.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelDecomposes
}())
exports.IfcRelDecomposes = IfcRelDecomposes

var IfcRelDefines = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcRelDefines.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcRelDefines.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelDefines
}())
exports.IfcRelDefines = IfcRelDefines

var IfcRelDefinesByObject = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingObject = RelatingObject
  }
  IfcRelDefinesByObject.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatingObject
    RelatingObject = tape[5]
    return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject)
  }
  IfcRelDefinesByObject.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingObject)
    return args
  }
  return IfcRelDefinesByObject
}())
exports.IfcRelDefinesByObject = IfcRelDefinesByObject

var IfcRelDefinesByProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingPropertyDefinition = RelatingPropertyDefinition
  }
  IfcRelDefinesByProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatingPropertyDefinition
    RelatingPropertyDefinition = ParseType(tape[5], tape[6][0])
    return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition)
  }
  IfcRelDefinesByProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelDefinesByProperties
}())
exports.IfcRelDefinesByProperties = IfcRelDefinesByProperties

var IfcRelDefinesByTemplate = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedPropertySets = RelatedPropertySets
    this.RelatingTemplate = RelatingTemplate
  }
  IfcRelDefinesByTemplate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedPropertySets
    RelatedPropertySets = []
    let RelatedPropertySets_index = 0
    while (RelatedPropertySets_index < tape[4].length) {
      RelatedPropertySets.push(tape[4][RelatedPropertySets_index++])
    }
    let RelatingTemplate
    RelatingTemplate = tape[5]
    return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate)
  }
  IfcRelDefinesByTemplate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedPropertySets.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingTemplate)
    return args
  }
  return IfcRelDefinesByTemplate
}())
exports.IfcRelDefinesByTemplate = IfcRelDefinesByTemplate

var IfcRelDefinesByType = /** @class */ (function() {
  /**
   *
   */
  function IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedObjects = RelatedObjects
    this.RelatingType = RelatingType
  }
  IfcRelDefinesByType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[4].length) {
      RelatedObjects.push(tape[4][RelatedObjects_index++])
    }
    let RelatingType
    RelatingType = tape[5]
    return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType)
  }
  IfcRelDefinesByType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingType)
    return args
  }
  return IfcRelDefinesByType
}())
exports.IfcRelDefinesByType = IfcRelDefinesByType

var IfcRelFillsElement = /** @class */ (function() {
  /**
   *
   */
  function IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingOpeningElement = RelatingOpeningElement
    this.RelatedBuildingElement = RelatedBuildingElement
  }
  IfcRelFillsElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingOpeningElement
    RelatingOpeningElement = tape[4]
    let RelatedBuildingElement
    RelatedBuildingElement = tape[5]
    return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement)
  }
  IfcRelFillsElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingOpeningElement)
    args.push(REF)
    args.push(this.RelatedBuildingElement)
    return args
  }
  return IfcRelFillsElement
}())
exports.IfcRelFillsElement = IfcRelFillsElement

var IfcRelFlowControlElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedControlElements = RelatedControlElements
    this.RelatingFlowElement = RelatingFlowElement
  }
  IfcRelFlowControlElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedControlElements
    RelatedControlElements = []
    let RelatedControlElements_index = 0
    while (RelatedControlElements_index < tape[4].length) {
      RelatedControlElements.push(tape[4][RelatedControlElements_index++])
    }
    let RelatingFlowElement
    RelatingFlowElement = tape[5]
    return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement)
  }
  IfcRelFlowControlElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedControlElements.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingFlowElement)
    return args
  }
  return IfcRelFlowControlElements
}())
exports.IfcRelFlowControlElements = IfcRelFlowControlElements

var IfcRelInterferesElements = /** @class */ (function() {
  /**
   *
   */
  function IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingElement = RelatingElement
    this.RelatedElement = RelatedElement
    this.InterferenceGeometry = InterferenceGeometry
    this.InterferenceType = InterferenceType
    this.ImpliedOrder = ImpliedOrder
  }
  IfcRelInterferesElements.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingElement
    RelatingElement = tape[4]
    let RelatedElement
    RelatedElement = tape[5]
    let InterferenceGeometry
    if (tape[6]) {
      InterferenceGeometry = tape[6]
    } else {
      InterferenceGeometry = null
    }
    let InterferenceType
    if (tape[7]) {
      InterferenceType = tape[7]
    } else {
      InterferenceType = null
    }
    let ImpliedOrder
    ImpliedOrder = tape[8]
    return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder)
  }
  IfcRelInterferesElements.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingElement)
    args.push(REF)
    args.push(this.RelatedElement)
    if (this.InterferenceGeometry) {
      args.push(REF)
      args.push(this.InterferenceGeometry)
    } else {
      args.push(EMPTY)
    }
    if (this.InterferenceType) {
      args.push(STRING)
      args.push(this.InterferenceType)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ImpliedOrder)
    return args
  }
  return IfcRelInterferesElements
}())
exports.IfcRelInterferesElements = IfcRelInterferesElements

var IfcRelNests = /** @class */ (function() {
  /**
   *
   */
  function IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingObject = RelatingObject
    this.RelatedObjects = RelatedObjects
  }
  IfcRelNests.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingObject
    RelatingObject = tape[4]
    let RelatedObjects
    RelatedObjects = []
    let RelatedObjects_index = 0
    while (RelatedObjects_index < tape[5].length) {
      RelatedObjects.push(tape[5][RelatedObjects_index++])
    }
    return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects)
  }
  IfcRelNests.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingObject)
    args.push(SET_BEGIN)
    this.RelatedObjects.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelNests
}())
exports.IfcRelNests = IfcRelNests

var IfcRelPositions = /** @class */ (function() {
  /**
   *
   */
  function IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingPositioningElement = RelatingPositioningElement
    this.RelatedProducts = RelatedProducts
  }
  IfcRelPositions.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingPositioningElement
    RelatingPositioningElement = tape[4]
    let RelatedProducts
    RelatedProducts = []
    let RelatedProducts_index = 0
    while (RelatedProducts_index < tape[5].length) {
      RelatedProducts.push(tape[5][RelatedProducts_index++])
    }
    return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts)
  }
  IfcRelPositions.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingPositioningElement)
    args.push(SET_BEGIN)
    this.RelatedProducts.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelPositions
}())
exports.IfcRelPositions = IfcRelPositions

var IfcRelProjectsElement = /** @class */ (function() {
  /**
   *
   */
  function IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingElement = RelatingElement
    this.RelatedFeatureElement = RelatedFeatureElement
  }
  IfcRelProjectsElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingElement
    RelatingElement = tape[4]
    let RelatedFeatureElement
    RelatedFeatureElement = tape[5]
    return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement)
  }
  IfcRelProjectsElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingElement)
    args.push(REF)
    args.push(this.RelatedFeatureElement)
    return args
  }
  return IfcRelProjectsElement
}())
exports.IfcRelProjectsElement = IfcRelProjectsElement

var IfcRelReferencedInSpatialStructure = /** @class */ (function() {
  /**
   *
   */
  function IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatedElements = RelatedElements
    this.RelatingStructure = RelatingStructure
  }
  IfcRelReferencedInSpatialStructure.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatedElements
    RelatedElements = []
    let RelatedElements_index = 0
    while (RelatedElements_index < tape[4].length) {
      RelatedElements.push(tape[4][RelatedElements_index++])
    }
    let RelatingStructure
    RelatingStructure = tape[5]
    return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure)
  }
  IfcRelReferencedInSpatialStructure.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.RelatedElements.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.RelatingStructure)
    return args
  }
  return IfcRelReferencedInSpatialStructure
}())
exports.IfcRelReferencedInSpatialStructure = IfcRelReferencedInSpatialStructure

var IfcRelSequence = /** @class */ (function() {
  /**
   *
   */
  function IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingProcess = RelatingProcess
    this.RelatedProcess = RelatedProcess
    this.TimeLag = TimeLag
    this.SequenceType = SequenceType
    this.UserDefinedSequenceType = UserDefinedSequenceType
  }
  IfcRelSequence.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingProcess
    RelatingProcess = tape[4]
    let RelatedProcess
    RelatedProcess = tape[5]
    let TimeLag
    if (tape[6]) {
      TimeLag = tape[6]
    } else {
      TimeLag = null
    }
    let SequenceType
    if (tape[7]) {
      SequenceType = new IfcSequenceEnum(tape[7])
    } else {
      SequenceType = null
    }
    let UserDefinedSequenceType
    if (tape[8]) {
      UserDefinedSequenceType = tape[8]
    } else {
      UserDefinedSequenceType = null
    }
    return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType)
  }
  IfcRelSequence.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingProcess)
    args.push(REF)
    args.push(this.RelatedProcess)
    if (this.TimeLag) {
      args.push(REF)
      args.push(this.TimeLag)
    } else {
      args.push(EMPTY)
    }
    if (this.SequenceType) {
      args.push(ENUM)
      args.push(this.SequenceType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedSequenceType) {
      args.push(STRING)
      args.push(this.UserDefinedSequenceType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelSequence
}())
exports.IfcRelSequence = IfcRelSequence

var IfcRelServicesBuildings = /** @class */ (function() {
  /**
   *
   */
  function IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingSystem = RelatingSystem
    this.RelatedBuildings = RelatedBuildings
  }
  IfcRelServicesBuildings.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingSystem
    RelatingSystem = tape[4]
    let RelatedBuildings
    RelatedBuildings = []
    let RelatedBuildings_index = 0
    while (RelatedBuildings_index < tape[5].length) {
      RelatedBuildings.push(tape[5][RelatedBuildings_index++])
    }
    return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings)
  }
  IfcRelServicesBuildings.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingSystem)
    args.push(SET_BEGIN)
    this.RelatedBuildings.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRelServicesBuildings
}())
exports.IfcRelServicesBuildings = IfcRelServicesBuildings

var IfcRelSpaceBoundary = /** @class */ (function() {
  /**
   *
   */
  function IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingSpace = RelatingSpace
    this.RelatedBuildingElement = RelatedBuildingElement
    this.ConnectionGeometry = ConnectionGeometry
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary
    this.InternalOrExternalBoundary = InternalOrExternalBoundary
  }
  IfcRelSpaceBoundary.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingSpace
    RelatingSpace = ParseType(tape[4], tape[5][0])
    let RelatedBuildingElement
    RelatedBuildingElement = tape[5]
    let ConnectionGeometry
    if (tape[6]) {
      ConnectionGeometry = tape[6]
    } else {
      ConnectionGeometry = null
    }
    let PhysicalOrVirtualBoundary
    PhysicalOrVirtualBoundary = new IfcPhysicalOrVirtualEnum(tape[7])
    let InternalOrExternalBoundary
    InternalOrExternalBoundary = new IfcInternalOrExternalEnum(tape[8])
    return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary)
  }
  IfcRelSpaceBoundary.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatedBuildingElement)
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PhysicalOrVirtualBoundary.value)
    args.push(ENUM)
    args.push(this.InternalOrExternalBoundary.value)
    return args
  }
  return IfcRelSpaceBoundary
}())
exports.IfcRelSpaceBoundary = IfcRelSpaceBoundary

var IfcRelSpaceBoundary1stLevel = /** @class */ (function() {
  /**
   *
   */
  function IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingSpace = RelatingSpace
    this.RelatedBuildingElement = RelatedBuildingElement
    this.ConnectionGeometry = ConnectionGeometry
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary
    this.InternalOrExternalBoundary = InternalOrExternalBoundary
    this.ParentBoundary = ParentBoundary
  }
  IfcRelSpaceBoundary1stLevel.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingSpace
    RelatingSpace = ParseType(tape[4], tape[5][0])
    let RelatedBuildingElement
    RelatedBuildingElement = tape[5]
    let ConnectionGeometry
    if (tape[6]) {
      ConnectionGeometry = tape[6]
    } else {
      ConnectionGeometry = null
    }
    let PhysicalOrVirtualBoundary
    PhysicalOrVirtualBoundary = new IfcPhysicalOrVirtualEnum(tape[7])
    let InternalOrExternalBoundary
    InternalOrExternalBoundary = new IfcInternalOrExternalEnum(tape[8])
    let ParentBoundary
    if (tape[9]) {
      ParentBoundary = tape[9]
    } else {
      ParentBoundary = null
    }
    return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary)
  }
  IfcRelSpaceBoundary1stLevel.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatedBuildingElement)
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PhysicalOrVirtualBoundary.value)
    args.push(ENUM)
    args.push(this.InternalOrExternalBoundary.value)
    if (this.ParentBoundary) {
      args.push(REF)
      args.push(this.ParentBoundary)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelSpaceBoundary1stLevel
}())
exports.IfcRelSpaceBoundary1stLevel = IfcRelSpaceBoundary1stLevel

var IfcRelSpaceBoundary2ndLevel = /** @class */ (function() {
  /**
   *
   */
  function IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingSpace = RelatingSpace
    this.RelatedBuildingElement = RelatedBuildingElement
    this.ConnectionGeometry = ConnectionGeometry
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary
    this.InternalOrExternalBoundary = InternalOrExternalBoundary
    this.ParentBoundary = ParentBoundary
    this.CorrespondingBoundary = CorrespondingBoundary
  }
  IfcRelSpaceBoundary2ndLevel.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingSpace
    RelatingSpace = ParseType(tape[4], tape[5][0])
    let RelatedBuildingElement
    RelatedBuildingElement = tape[5]
    let ConnectionGeometry
    if (tape[6]) {
      ConnectionGeometry = tape[6]
    } else {
      ConnectionGeometry = null
    }
    let PhysicalOrVirtualBoundary
    PhysicalOrVirtualBoundary = new IfcPhysicalOrVirtualEnum(tape[7])
    let InternalOrExternalBoundary
    InternalOrExternalBoundary = new IfcInternalOrExternalEnum(tape[8])
    let ParentBoundary
    if (tape[9]) {
      ParentBoundary = tape[9]
    } else {
      ParentBoundary = null
    }
    let CorrespondingBoundary
    if (tape[10]) {
      CorrespondingBoundary = tape[10]
    } else {
      CorrespondingBoundary = null
    }
    return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary)
  }
  IfcRelSpaceBoundary2ndLevel.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatedBuildingElement)
    if (this.ConnectionGeometry) {
      args.push(REF)
      args.push(this.ConnectionGeometry)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PhysicalOrVirtualBoundary.value)
    args.push(ENUM)
    args.push(this.InternalOrExternalBoundary.value)
    if (this.ParentBoundary) {
      args.push(REF)
      args.push(this.ParentBoundary)
    } else {
      args.push(EMPTY)
    }
    if (this.CorrespondingBoundary) {
      args.push(REF)
      args.push(this.CorrespondingBoundary)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelSpaceBoundary2ndLevel
}())
exports.IfcRelSpaceBoundary2ndLevel = IfcRelSpaceBoundary2ndLevel

var IfcRelVoidsElement = /** @class */ (function() {
  /**
   *
   */
  function IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.RelatingBuildingElement = RelatingBuildingElement
    this.RelatedOpeningElement = RelatedOpeningElement
  }
  IfcRelVoidsElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let RelatingBuildingElement
    RelatingBuildingElement = tape[4]
    let RelatedOpeningElement
    RelatedOpeningElement = tape[5]
    return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement)
  }
  IfcRelVoidsElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingBuildingElement)
    args.push(REF)
    args.push(this.RelatedOpeningElement)
    return args
  }
  return IfcRelVoidsElement
}())
exports.IfcRelVoidsElement = IfcRelVoidsElement

var IfcRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcRelationship.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcRelationship.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRelationship
}())
exports.IfcRelationship = IfcRelationship

var IfcReparametrisedCompositeCurveSegment = /** @class */ (function() {
  /**
   *
   */
  function IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
    this.expressID = expressID
    this.type = type
    this.Transition = Transition
    this.SameSense = SameSense
    this.ParentCurve = ParentCurve
    this.ParamLength = ParamLength
  }
  IfcReparametrisedCompositeCurveSegment.FromTape = function(expressID, type, tape) {
    let Transition
    Transition = new IfcTransitionCode(tape[0])
    let SameSense
    SameSense = tape[1]
    let ParentCurve
    ParentCurve = tape[2]
    let ParamLength
    ParamLength = tape[3]
    return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength)
  }
  IfcReparametrisedCompositeCurveSegment.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.Transition.value)
    args.push(REF)
    args.push(this.ParentCurve)
    args.push(REAL)
    args.push(this.ParamLength)
    return args
  }
  return IfcReparametrisedCompositeCurveSegment
}())
exports.IfcReparametrisedCompositeCurveSegment = IfcReparametrisedCompositeCurveSegment

var IfcRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcRepresentation.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcRepresentation.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcRepresentation
}())
exports.IfcRepresentation = IfcRepresentation

var IfcRepresentationContext = /** @class */ (function() {
  /**
   *
   */
  function IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType) {
    this.expressID = expressID
    this.type = type
    this.ContextIdentifier = ContextIdentifier
    this.ContextType = ContextType
  }
  IfcRepresentationContext.FromTape = function(expressID, type, tape) {
    let ContextIdentifier
    if (tape[0]) {
      ContextIdentifier = tape[0]
    } else {
      ContextIdentifier = null
    }
    let ContextType
    if (tape[1]) {
      ContextType = tape[1]
    } else {
      ContextType = null
    }
    return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType)
  }
  IfcRepresentationContext.prototype.ToTape = function() {
    const args = []
    if (this.ContextIdentifier) {
      args.push(STRING)
      args.push(this.ContextIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.ContextType) {
      args.push(STRING)
      args.push(this.ContextType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRepresentationContext
}())
exports.IfcRepresentationContext = IfcRepresentationContext

var IfcRepresentationItem = /** @class */ (function() {
  /**
   *
   */
  function IfcRepresentationItem(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcRepresentationItem.FromTape = function(expressID, type, tape) {
    return new IfcRepresentationItem(expressID, type)
  }
  IfcRepresentationItem.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcRepresentationItem
}())
exports.IfcRepresentationItem = IfcRepresentationItem

var IfcRepresentationMap = /** @class */ (function() {
  /**
   *
   */
  function IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation) {
    this.expressID = expressID
    this.type = type
    this.MappingOrigin = MappingOrigin
    this.MappedRepresentation = MappedRepresentation
  }
  IfcRepresentationMap.FromTape = function(expressID, type, tape) {
    let MappingOrigin
    MappingOrigin = ParseType(tape[0], tape[1][0])
    let MappedRepresentation
    MappedRepresentation = tape[1]
    return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation)
  }
  IfcRepresentationMap.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.MappedRepresentation)
    return args
  }
  return IfcRepresentationMap
}())
exports.IfcRepresentationMap = IfcRepresentationMap

var IfcResource = /** @class */ (function() {
  /**
   *
   */
  function IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
  }
  IfcResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
  }
  IfcResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcResource
}())
exports.IfcResource = IfcResource

var IfcResourceApprovalRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatedResourceObjects = RelatedResourceObjects
    this.RelatingApproval = RelatingApproval
  }
  IfcResourceApprovalRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatedResourceObjects
    RelatedResourceObjects = []
    let RelatedResourceObjects_index = 0
    while (RelatedResourceObjects_index < tape[2].length) {
      RelatedResourceObjects.push(ParseType(tape[2][RelatedResourceObjects_index++], tape[2][RelatedResourceObjects_index++][0]))
    }
    let RelatingApproval
    RelatingApproval = tape[3]
    return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval)
  }
  IfcResourceApprovalRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingApproval)
    return args
  }
  return IfcResourceApprovalRelationship
}())
exports.IfcResourceApprovalRelationship = IfcResourceApprovalRelationship

var IfcResourceConstraintRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.RelatingConstraint = RelatingConstraint
    this.RelatedResourceObjects = RelatedResourceObjects
  }
  IfcResourceConstraintRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let RelatingConstraint
    RelatingConstraint = tape[2]
    let RelatedResourceObjects
    RelatedResourceObjects = []
    let RelatedResourceObjects_index = 0
    while (RelatedResourceObjects_index < tape[3].length) {
      RelatedResourceObjects.push(ParseType(tape[3][RelatedResourceObjects_index++], tape[3][RelatedResourceObjects_index++][0]))
    }
    return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects)
  }
  IfcResourceConstraintRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.RelatingConstraint)
    return args
  }
  return IfcResourceConstraintRelationship
}())
exports.IfcResourceConstraintRelationship = IfcResourceConstraintRelationship

var IfcResourceLevelRelationship = /** @class */ (function() {
  /**
   *
   */
  function IfcResourceLevelRelationship(expressID, type, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
  }
  IfcResourceLevelRelationship.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    return new IfcResourceLevelRelationship(expressID, type, Name, Description)
  }
  IfcResourceLevelRelationship.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcResourceLevelRelationship
}())
exports.IfcResourceLevelRelationship = IfcResourceLevelRelationship

var IfcResourceTime = /** @class */ (function() {
  /**
   *
   */
  function IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.ScheduleWork = ScheduleWork
    this.ScheduleUsage = ScheduleUsage
    this.ScheduleStart = ScheduleStart
    this.ScheduleFinish = ScheduleFinish
    this.ScheduleContour = ScheduleContour
    this.LevelingDelay = LevelingDelay
    this.IsOverAllocated = IsOverAllocated
    this.StatusTime = StatusTime
    this.ActualWork = ActualWork
    this.ActualUsage = ActualUsage
    this.ActualStart = ActualStart
    this.ActualFinish = ActualFinish
    this.RemainingWork = RemainingWork
    this.RemainingUsage = RemainingUsage
    this.Completion = Completion
  }
  IfcResourceTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let ScheduleWork
    if (tape[3]) {
      ScheduleWork = tape[3]
    } else {
      ScheduleWork = null
    }
    let ScheduleUsage
    if (tape[4]) {
      ScheduleUsage = tape[4]
    } else {
      ScheduleUsage = null
    }
    let ScheduleStart
    if (tape[5]) {
      ScheduleStart = tape[5]
    } else {
      ScheduleStart = null
    }
    let ScheduleFinish
    if (tape[6]) {
      ScheduleFinish = tape[6]
    } else {
      ScheduleFinish = null
    }
    let ScheduleContour
    if (tape[7]) {
      ScheduleContour = tape[7]
    } else {
      ScheduleContour = null
    }
    let LevelingDelay
    if (tape[8]) {
      LevelingDelay = tape[8]
    } else {
      LevelingDelay = null
    }
    let IsOverAllocated
    if (tape[9]) {
      IsOverAllocated = tape[9]
    } else {
      IsOverAllocated = null
    }
    let StatusTime
    if (tape[10]) {
      StatusTime = tape[10]
    } else {
      StatusTime = null
    }
    let ActualWork
    if (tape[11]) {
      ActualWork = tape[11]
    } else {
      ActualWork = null
    }
    let ActualUsage
    if (tape[12]) {
      ActualUsage = tape[12]
    } else {
      ActualUsage = null
    }
    let ActualStart
    if (tape[13]) {
      ActualStart = tape[13]
    } else {
      ActualStart = null
    }
    let ActualFinish
    if (tape[14]) {
      ActualFinish = tape[14]
    } else {
      ActualFinish = null
    }
    let RemainingWork
    if (tape[15]) {
      RemainingWork = tape[15]
    } else {
      RemainingWork = null
    }
    let RemainingUsage
    if (tape[16]) {
      RemainingUsage = tape[16]
    } else {
      RemainingUsage = null
    }
    let Completion
    if (tape[17]) {
      Completion = tape[17]
    } else {
      Completion = null
    }
    return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion)
  }
  IfcResourceTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleWork) {
      args.push(STRING)
      args.push(this.ScheduleWork)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleUsage) {
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleStart) {
      args.push(STRING)
      args.push(this.ScheduleStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleFinish) {
      args.push(STRING)
      args.push(this.ScheduleFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleContour) {
      args.push(STRING)
      args.push(this.ScheduleContour)
    } else {
      args.push(EMPTY)
    }
    if (this.LevelingDelay) {
      args.push(STRING)
      args.push(this.LevelingDelay)
    } else {
      args.push(EMPTY)
    }
    if (this.IsOverAllocated) {
    } else {
      args.push(EMPTY)
    }
    if (this.StatusTime) {
      args.push(STRING)
      args.push(this.StatusTime)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualWork) {
      args.push(STRING)
      args.push(this.ActualWork)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualUsage) {
    } else {
      args.push(EMPTY)
    }
    if (this.ActualStart) {
      args.push(STRING)
      args.push(this.ActualStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualFinish) {
      args.push(STRING)
      args.push(this.ActualFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.RemainingWork) {
      args.push(STRING)
      args.push(this.RemainingWork)
    } else {
      args.push(EMPTY)
    }
    if (this.RemainingUsage) {
    } else {
      args.push(EMPTY)
    }
    if (this.Completion) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcResourceTime
}())
exports.IfcResourceTime = IfcResourceTime

var IfcRevolvedAreaSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.Axis = Axis
    this.Angle = Angle
  }
  IfcRevolvedAreaSolid.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let Axis
    Axis = tape[2]
    let Angle
    Angle = tape[3]
    return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle)
  }
  IfcRevolvedAreaSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Axis)
    args.push(REAL)
    args.push(this.Angle)
    return args
  }
  return IfcRevolvedAreaSolid
}())
exports.IfcRevolvedAreaSolid = IfcRevolvedAreaSolid

var IfcRevolvedAreaSolidTapered = /** @class */ (function() {
  /**
   *
   */
  function IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.Axis = Axis
    this.Angle = Angle
    this.EndSweptArea = EndSweptArea
  }
  IfcRevolvedAreaSolidTapered.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let Axis
    Axis = tape[2]
    let Angle
    Angle = tape[3]
    let EndSweptArea
    EndSweptArea = tape[4]
    return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea)
  }
  IfcRevolvedAreaSolidTapered.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Axis)
    args.push(REAL)
    args.push(this.Angle)
    args.push(REF)
    args.push(this.EndSweptArea)
    return args
  }
  return IfcRevolvedAreaSolidTapered
}())
exports.IfcRevolvedAreaSolidTapered = IfcRevolvedAreaSolidTapered

var IfcRightCircularCone = /** @class */ (function() {
  /**
   *
   */
  function IfcRightCircularCone(expressID, type, Position, Height, BottomRadius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Height = Height
    this.BottomRadius = BottomRadius
  }
  IfcRightCircularCone.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let Height
    Height = tape[1]
    let BottomRadius
    BottomRadius = tape[2]
    return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius)
  }
  IfcRightCircularCone.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcRightCircularCone
}())
exports.IfcRightCircularCone = IfcRightCircularCone

var IfcRightCircularCylinder = /** @class */ (function() {
  /**
   *
   */
  function IfcRightCircularCylinder(expressID, type, Position, Height, Radius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Height = Height
    this.Radius = Radius
  }
  IfcRightCircularCylinder.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let Height
    Height = tape[1]
    let Radius
    Radius = tape[2]
    return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius)
  }
  IfcRightCircularCylinder.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcRightCircularCylinder
}())
exports.IfcRightCircularCylinder = IfcRightCircularCylinder

var IfcRoof = /** @class */ (function() {
  /**
   *
   */
  function IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcRoof.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcRoofTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcRoof.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRoof
}())
exports.IfcRoof = IfcRoof

var IfcRoofType = /** @class */ (function() {
  /**
   *
   */
  function IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcRoofType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcRoofTypeEnum(tape[9])
    return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcRoofType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcRoofType
}())
exports.IfcRoofType = IfcRoofType

var IfcRoot = /** @class */ (function() {
  /**
   *
   */
  function IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
  }
  IfcRoot.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description)
  }
  IfcRoot.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRoot
}())
exports.IfcRoot = IfcRoot

var IfcRoundedRectangleProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.XDim = XDim
    this.YDim = YDim
    this.RoundingRadius = RoundingRadius
  }
  IfcRoundedRectangleProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let XDim
    XDim = tape[3]
    let YDim
    YDim = tape[4]
    let RoundingRadius
    RoundingRadius = tape[5]
    return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius)
  }
  IfcRoundedRectangleProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcRoundedRectangleProfileDef
}())
exports.IfcRoundedRectangleProfileDef = IfcRoundedRectangleProfileDef

var IfcSIUnit = /** @class */ (function() {
  /**
   *
   */
  function IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name) {
    this.expressID = expressID
    this.type = type
    this.Dimensions = Dimensions
    this.UnitType = UnitType
    this.Prefix = Prefix
    this.Name = Name
  }
  IfcSIUnit.FromTape = function(expressID, type, tape) {
    let Dimensions
    Dimensions = tape[0]
    let UnitType
    UnitType = new IfcUnitEnum(tape[1])
    let Prefix
    if (tape[2]) {
      Prefix = new IfcSIPrefix(tape[2])
    } else {
      Prefix = null
    }
    let Name
    Name = new IfcSIUnitName(tape[3])
    return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name)
  }
  IfcSIUnit.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Dimensions)
    args.push(ENUM)
    args.push(this.UnitType.value)
    if (this.Prefix) {
      args.push(ENUM)
      args.push(this.Prefix.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.Name.value)
    return args
  }
  return IfcSIUnit
}())
exports.IfcSIUnit = IfcSIUnit

var IfcSanitaryTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSanitaryTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSanitaryTerminalTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSanitaryTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSanitaryTerminal
}())
exports.IfcSanitaryTerminal = IfcSanitaryTerminal

var IfcSanitaryTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSanitaryTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSanitaryTerminalTypeEnum(tape[9])
    return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSanitaryTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSanitaryTerminalType
}())
exports.IfcSanitaryTerminalType = IfcSanitaryTerminalType

var IfcSchedulingTime = /** @class */ (function() {
  /**
   *
   */
  function IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
  }
  IfcSchedulingTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin)
  }
  IfcSchedulingTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSchedulingTime
}())
exports.IfcSchedulingTime = IfcSchedulingTime

var IfcSeamCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID
    this.type = type
    this.Curve3D = Curve3D
    this.AssociatedGeometry = AssociatedGeometry
    this.MasterRepresentation = MasterRepresentation
  }
  IfcSeamCurve.FromTape = function(expressID, type, tape) {
    let Curve3D
    Curve3D = tape[0]
    let AssociatedGeometry
    AssociatedGeometry = []
    let AssociatedGeometry_index = 0
    while (AssociatedGeometry_index < tape[1].length) {
      AssociatedGeometry.push(tape[1][AssociatedGeometry_index++])
    }
    let MasterRepresentation
    MasterRepresentation = new IfcPreferredSurfaceCurveRepresentation(tape[2])
    return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation)
  }
  IfcSeamCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Curve3D)
    args.push(SET_BEGIN)
    this.AssociatedGeometry.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.MasterRepresentation.value)
    return args
  }
  return IfcSeamCurve
}())
exports.IfcSeamCurve = IfcSeamCurve

var IfcSectionProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile) {
    this.expressID = expressID
    this.type = type
    this.SectionType = SectionType
    this.StartProfile = StartProfile
    this.EndProfile = EndProfile
  }
  IfcSectionProperties.FromTape = function(expressID, type, tape) {
    let SectionType
    SectionType = new IfcSectionTypeEnum(tape[0])
    let StartProfile
    StartProfile = tape[1]
    let EndProfile
    if (tape[2]) {
      EndProfile = tape[2]
    } else {
      EndProfile = null
    }
    return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile)
  }
  IfcSectionProperties.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.SectionType.value)
    args.push(REF)
    args.push(this.StartProfile)
    if (this.EndProfile) {
      args.push(REF)
      args.push(this.EndProfile)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSectionProperties
}())
exports.IfcSectionProperties = IfcSectionProperties

var IfcSectionReinforcementProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
    this.expressID = expressID
    this.type = type
    this.LongitudinalStartPosition = LongitudinalStartPosition
    this.LongitudinalEndPosition = LongitudinalEndPosition
    this.TransversePosition = TransversePosition
    this.ReinforcementRole = ReinforcementRole
    this.SectionDefinition = SectionDefinition
    this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions
  }
  IfcSectionReinforcementProperties.FromTape = function(expressID, type, tape) {
    let LongitudinalStartPosition
    LongitudinalStartPosition = tape[0]
    let LongitudinalEndPosition
    LongitudinalEndPosition = tape[1]
    let TransversePosition
    if (tape[2]) {
      TransversePosition = tape[2]
    } else {
      TransversePosition = null
    }
    let ReinforcementRole
    ReinforcementRole = new IfcReinforcingBarRoleEnum(tape[3])
    let SectionDefinition
    SectionDefinition = tape[4]
    let CrossSectionReinforcementDefinitions
    CrossSectionReinforcementDefinitions = []
    let CrossSectionReinforcementDefinitions_index = 0
    while (CrossSectionReinforcementDefinitions_index < tape[5].length) {
      CrossSectionReinforcementDefinitions.push(tape[5][CrossSectionReinforcementDefinitions_index++])
    }
    return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions)
  }
  IfcSectionReinforcementProperties.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push(this.LongitudinalStartPosition)
    args.push(REAL)
    args.push(this.LongitudinalEndPosition)
    if (this.TransversePosition) {
      args.push(REAL)
      args.push(this.TransversePosition)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ReinforcementRole.value)
    args.push(REF)
    args.push(this.SectionDefinition)
    args.push(SET_BEGIN)
    this.CrossSectionReinforcementDefinitions.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcSectionReinforcementProperties
}())
exports.IfcSectionReinforcementProperties = IfcSectionReinforcementProperties

var IfcSectionedSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionedSolid(expressID, type, Directrix, CrossSections) {
    this.expressID = expressID
    this.type = type
    this.Directrix = Directrix
    this.CrossSections = CrossSections
  }
  IfcSectionedSolid.FromTape = function(expressID, type, tape) {
    let Directrix
    Directrix = tape[0]
    let CrossSections
    CrossSections = []
    let CrossSections_index = 0
    while (CrossSections_index < tape[1].length) {
      CrossSections.push(tape[1][CrossSections_index++])
    }
    return new IfcSectionedSolid(expressID, type, Directrix, CrossSections)
  }
  IfcSectionedSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Directrix)
    args.push(SET_BEGIN)
    this.CrossSections.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcSectionedSolid
}())
exports.IfcSectionedSolid = IfcSectionedSolid

var IfcSectionedSolidHorizontal = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
    this.expressID = expressID
    this.type = type
    this.Directrix = Directrix
    this.CrossSections = CrossSections
    this.CrossSectionPositions = CrossSectionPositions
    this.FixedAxisVertical = FixedAxisVertical
  }
  IfcSectionedSolidHorizontal.FromTape = function(expressID, type, tape) {
    let Directrix
    Directrix = tape[0]
    let CrossSections
    CrossSections = []
    let CrossSections_index = 0
    while (CrossSections_index < tape[1].length) {
      CrossSections.push(tape[1][CrossSections_index++])
    }
    let CrossSectionPositions
    CrossSectionPositions = []
    let CrossSectionPositions_index = 0
    while (CrossSectionPositions_index < tape[2].length) {
      CrossSectionPositions.push(tape[2][CrossSectionPositions_index++])
    }
    let FixedAxisVertical
    FixedAxisVertical = tape[3]
    return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical)
  }
  IfcSectionedSolidHorizontal.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Directrix)
    args.push(SET_BEGIN)
    this.CrossSections.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(SET_BEGIN)
    this.CrossSectionPositions.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcSectionedSolidHorizontal
}())
exports.IfcSectionedSolidHorizontal = IfcSectionedSolidHorizontal

var IfcSectionedSpine = /** @class */ (function() {
  /**
   *
   */
  function IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
    this.expressID = expressID
    this.type = type
    this.SpineCurve = SpineCurve
    this.CrossSections = CrossSections
    this.CrossSectionPositions = CrossSectionPositions
  }
  IfcSectionedSpine.FromTape = function(expressID, type, tape) {
    let SpineCurve
    SpineCurve = tape[0]
    let CrossSections
    CrossSections = []
    let CrossSections_index = 0
    while (CrossSections_index < tape[1].length) {
      CrossSections.push(tape[1][CrossSections_index++])
    }
    let CrossSectionPositions
    CrossSectionPositions = []
    let CrossSectionPositions_index = 0
    while (CrossSectionPositions_index < tape[2].length) {
      CrossSectionPositions.push(tape[2][CrossSectionPositions_index++])
    }
    return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions)
  }
  IfcSectionedSpine.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SpineCurve)
    args.push(SET_BEGIN)
    this.CrossSections.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(SET_BEGIN)
    this.CrossSectionPositions.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcSectionedSpine
}())
exports.IfcSectionedSpine = IfcSectionedSpine

var IfcSensor = /** @class */ (function() {
  /**
   *
   */
  function IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSensor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSensorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSensor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSensor
}())
exports.IfcSensor = IfcSensor

var IfcSensorType = /** @class */ (function() {
  /**
   *
   */
  function IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSensorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSensorTypeEnum(tape[9])
    return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSensorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSensorType
}())
exports.IfcSensorType = IfcSensorType

var IfcShadingDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcShadingDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcShadingDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcShadingDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcShadingDevice
}())
exports.IfcShadingDevice = IfcShadingDevice

var IfcShadingDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcShadingDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcShadingDeviceTypeEnum(tape[9])
    return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcShadingDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcShadingDeviceType
}())
exports.IfcShadingDeviceType = IfcShadingDeviceType

var IfcShapeAspect = /** @class */ (function() {
  /**
   *
   */
  function IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
    this.expressID = expressID
    this.type = type
    this.ShapeRepresentations = ShapeRepresentations
    this.Name = Name
    this.Description = Description
    this.ProductDefinitional = ProductDefinitional
    this.PartOfProductDefinitionShape = PartOfProductDefinitionShape
  }
  IfcShapeAspect.FromTape = function(expressID, type, tape) {
    let ShapeRepresentations
    ShapeRepresentations = []
    let ShapeRepresentations_index = 0
    while (ShapeRepresentations_index < tape[0].length) {
      ShapeRepresentations.push(tape[0][ShapeRepresentations_index++])
    }
    let Name
    if (tape[1]) {
      Name = tape[1]
    } else {
      Name = null
    }
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    let ProductDefinitional
    ProductDefinitional = tape[3]
    let PartOfProductDefinitionShape
    if (tape[4]) {
      PartOfProductDefinitionShape = ParseType(tape[4], tape[5][0])
    } else {
      PartOfProductDefinitionShape = null
    }
    return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape)
  }
  IfcShapeAspect.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.ShapeRepresentations.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.PartOfProductDefinitionShape) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcShapeAspect
}())
exports.IfcShapeAspect = IfcShapeAspect

var IfcShapeModel = /** @class */ (function() {
  /**
   *
   */
  function IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcShapeModel.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcShapeModel.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcShapeModel
}())
exports.IfcShapeModel = IfcShapeModel

var IfcShapeRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcShapeRepresentation.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcShapeRepresentation.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcShapeRepresentation
}())
exports.IfcShapeRepresentation = IfcShapeRepresentation

var IfcShellBasedSurfaceModel = /** @class */ (function() {
  /**
   *
   */
  function IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary) {
    this.expressID = expressID
    this.type = type
    this.SbsmBoundary = SbsmBoundary
  }
  IfcShellBasedSurfaceModel.FromTape = function(expressID, type, tape) {
    let SbsmBoundary
    SbsmBoundary = []
    let SbsmBoundary_index = 0
    while (SbsmBoundary_index < tape[0].length) {
      SbsmBoundary.push(ParseType(tape[0][SbsmBoundary_index++], tape[0][SbsmBoundary_index++][0]))
    }
    return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary)
  }
  IfcShellBasedSurfaceModel.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcShellBasedSurfaceModel
}())
exports.IfcShellBasedSurfaceModel = IfcShellBasedSurfaceModel

var IfcSimpleProperty = /** @class */ (function() {
  /**
   *
   */
  function IfcSimpleProperty(expressID, type, Name, Description) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
  }
  IfcSimpleProperty.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    return new IfcSimpleProperty(expressID, type, Name, Description)
  }
  IfcSimpleProperty.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSimpleProperty
}())
exports.IfcSimpleProperty = IfcSimpleProperty

var IfcSimplePropertyTemplate = /** @class */ (function() {
  /**
   *
   */
  function IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.TemplateType = TemplateType
    this.PrimaryMeasureType = PrimaryMeasureType
    this.SecondaryMeasureType = SecondaryMeasureType
    this.Enumerators = Enumerators
    this.PrimaryUnit = PrimaryUnit
    this.SecondaryUnit = SecondaryUnit
    this.Expression = Expression
    this.AccessState = AccessState
  }
  IfcSimplePropertyTemplate.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let TemplateType
    if (tape[4]) {
      TemplateType = new IfcSimplePropertyTemplateTypeEnum(tape[4])
    } else {
      TemplateType = null
    }
    let PrimaryMeasureType
    if (tape[5]) {
      PrimaryMeasureType = tape[5]
    } else {
      PrimaryMeasureType = null
    }
    let SecondaryMeasureType
    if (tape[6]) {
      SecondaryMeasureType = tape[6]
    } else {
      SecondaryMeasureType = null
    }
    let Enumerators
    if (tape[7]) {
      Enumerators = tape[7]
    } else {
      Enumerators = null
    }
    let PrimaryUnit
    if (tape[8]) {
      PrimaryUnit = ParseType(tape[8], tape[9][0])
    } else {
      PrimaryUnit = null
    }
    let SecondaryUnit
    if (tape[9]) {
      SecondaryUnit = ParseType(tape[9], tape[10][0])
    } else {
      SecondaryUnit = null
    }
    let Expression
    if (tape[10]) {
      Expression = tape[10]
    } else {
      Expression = null
    }
    let AccessState
    if (tape[11]) {
      AccessState = new IfcStateEnum(tape[11])
    } else {
      AccessState = null
    }
    return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState)
  }
  IfcSimplePropertyTemplate.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.TemplateType) {
      args.push(ENUM)
      args.push(this.TemplateType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PrimaryMeasureType) {
      args.push(STRING)
      args.push(this.PrimaryMeasureType)
    } else {
      args.push(EMPTY)
    }
    if (this.SecondaryMeasureType) {
      args.push(STRING)
      args.push(this.SecondaryMeasureType)
    } else {
      args.push(EMPTY)
    }
    if (this.Enumerators) {
      args.push(REF)
      args.push(this.Enumerators)
    } else {
      args.push(EMPTY)
    }
    if (this.PrimaryUnit) {
    } else {
      args.push(EMPTY)
    }
    if (this.SecondaryUnit) {
    } else {
      args.push(EMPTY)
    }
    if (this.Expression) {
      args.push(STRING)
      args.push(this.Expression)
    } else {
      args.push(EMPTY)
    }
    if (this.AccessState) {
      args.push(ENUM)
      args.push(this.AccessState.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSimplePropertyTemplate
}())
exports.IfcSimplePropertyTemplate = IfcSimplePropertyTemplate

var IfcSite = /** @class */ (function() {
  /**
   *
   */
  function IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.RefLatitude = RefLatitude
    this.RefLongitude = RefLongitude
    this.RefElevation = RefElevation
    this.LandTitleNumber = LandTitleNumber
    this.SiteAddress = SiteAddress
  }
  IfcSite.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let RefLatitude
    if (tape[9]) {
      RefLatitude = tape[9]
    } else {
      RefLatitude = null
    }
    let RefLongitude
    if (tape[10]) {
      RefLongitude = tape[10]
    } else {
      RefLongitude = null
    }
    let RefElevation
    if (tape[11]) {
      RefElevation = tape[11]
    } else {
      RefElevation = null
    }
    let LandTitleNumber
    if (tape[12]) {
      LandTitleNumber = tape[12]
    } else {
      LandTitleNumber = null
    }
    let SiteAddress
    if (tape[13]) {
      SiteAddress = tape[13]
    } else {
      SiteAddress = null
    }
    return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress)
  }
  IfcSite.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.RefLatitude) {
      args.push(REAL)
      args.push(this.RefLatitude)
    } else {
      args.push(EMPTY)
    }
    if (this.RefLongitude) {
      args.push(REAL)
      args.push(this.RefLongitude)
    } else {
      args.push(EMPTY)
    }
    if (this.RefElevation) {
      args.push(REAL)
      args.push(this.RefElevation)
    } else {
      args.push(EMPTY)
    }
    if (this.LandTitleNumber) {
      args.push(STRING)
      args.push(this.LandTitleNumber)
    } else {
      args.push(EMPTY)
    }
    if (this.SiteAddress) {
      args.push(REF)
      args.push(this.SiteAddress)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSite
}())
exports.IfcSite = IfcSite

var IfcSlab = /** @class */ (function() {
  /**
   *
   */
  function IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSlab.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSlabTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSlab.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSlab
}())
exports.IfcSlab = IfcSlab

var IfcSlabElementedCase = /** @class */ (function() {
  /**
   *
   */
  function IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSlabElementedCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSlabTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSlabElementedCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSlabElementedCase
}())
exports.IfcSlabElementedCase = IfcSlabElementedCase

var IfcSlabStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSlabStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSlabTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSlabStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSlabStandardCase
}())
exports.IfcSlabStandardCase = IfcSlabStandardCase

var IfcSlabType = /** @class */ (function() {
  /**
   *
   */
  function IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSlabType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSlabTypeEnum(tape[9])
    return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSlabType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSlabType
}())
exports.IfcSlabType = IfcSlabType

var IfcSlippageConnectionCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.SlippageX = SlippageX
    this.SlippageY = SlippageY
    this.SlippageZ = SlippageZ
  }
  IfcSlippageConnectionCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let SlippageX
    if (tape[1]) {
      SlippageX = tape[1]
    } else {
      SlippageX = null
    }
    let SlippageY
    if (tape[2]) {
      SlippageY = tape[2]
    } else {
      SlippageY = null
    }
    let SlippageZ
    if (tape[3]) {
      SlippageZ = tape[3]
    } else {
      SlippageZ = null
    }
    return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ)
  }
  IfcSlippageConnectionCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.SlippageX) {
      args.push(REAL)
      args.push(this.SlippageX)
    } else {
      args.push(EMPTY)
    }
    if (this.SlippageY) {
      args.push(REAL)
      args.push(this.SlippageY)
    } else {
      args.push(EMPTY)
    }
    if (this.SlippageZ) {
      args.push(REAL)
      args.push(this.SlippageZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSlippageConnectionCondition
}())
exports.IfcSlippageConnectionCondition = IfcSlippageConnectionCondition

var IfcSolarDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSolarDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSolarDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSolarDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSolarDevice
}())
exports.IfcSolarDevice = IfcSolarDevice

var IfcSolarDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSolarDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSolarDeviceTypeEnum(tape[9])
    return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSolarDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSolarDeviceType
}())
exports.IfcSolarDeviceType = IfcSolarDeviceType

var IfcSolidModel = /** @class */ (function() {
  /**
   *
   */
  function IfcSolidModel(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcSolidModel.FromTape = function(expressID, type, tape) {
    return new IfcSolidModel(expressID, type)
  }
  IfcSolidModel.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcSolidModel
}())
exports.IfcSolidModel = IfcSolidModel

var IfcSpace = /** @class */ (function() {
  /**
   *
   */
  function IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
    this.PredefinedType = PredefinedType
    this.ElevationWithFlooring = ElevationWithFlooring
  }
  IfcSpace.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcSpaceTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    let ElevationWithFlooring
    if (tape[10]) {
      ElevationWithFlooring = tape[10]
    } else {
      ElevationWithFlooring = null
    }
    return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring)
  }
  IfcSpace.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ElevationWithFlooring) {
      args.push(REAL)
      args.push(this.ElevationWithFlooring)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpace
}())
exports.IfcSpace = IfcSpace

var IfcSpaceHeater = /** @class */ (function() {
  /**
   *
   */
  function IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSpaceHeater.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSpaceHeaterTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSpaceHeater.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpaceHeater
}())
exports.IfcSpaceHeater = IfcSpaceHeater

var IfcSpaceHeaterType = /** @class */ (function() {
  /**
   *
   */
  function IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSpaceHeaterType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSpaceHeaterTypeEnum(tape[9])
    return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSpaceHeaterType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSpaceHeaterType
}())
exports.IfcSpaceHeaterType = IfcSpaceHeaterType

var IfcSpaceType = /** @class */ (function() {
  /**
   *
   */
  function IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.LongName = LongName
  }
  IfcSpaceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSpaceTypeEnum(tape[9])
    let LongName
    if (tape[10]) {
      LongName = tape[10]
    } else {
      LongName = null
    }
    return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName)
  }
  IfcSpaceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpaceType
}())
exports.IfcSpaceType = IfcSpaceType

var IfcSpatialElement = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
  }
  IfcSpatialElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
  }
  IfcSpatialElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialElement
}())
exports.IfcSpatialElement = IfcSpatialElement

var IfcSpatialElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcSpatialElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcSpatialElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialElementType
}())
exports.IfcSpatialElementType = IfcSpatialElementType

var IfcSpatialStructureElement = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.CompositionType = CompositionType
  }
  IfcSpatialStructureElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let CompositionType
    if (tape[8]) {
      CompositionType = new IfcElementCompositionEnum(tape[8])
    } else {
      CompositionType = null
    }
    return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
  }
  IfcSpatialStructureElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.CompositionType) {
      args.push(ENUM)
      args.push(this.CompositionType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialStructureElement
}())
exports.IfcSpatialStructureElement = IfcSpatialStructureElement

var IfcSpatialStructureElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
  }
  IfcSpatialStructureElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType)
  }
  IfcSpatialStructureElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialStructureElementType
}())
exports.IfcSpatialStructureElementType = IfcSpatialStructureElementType

var IfcSpatialZone = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.LongName = LongName
    this.PredefinedType = PredefinedType
  }
  IfcSpatialZone.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let LongName
    if (tape[7]) {
      LongName = tape[7]
    } else {
      LongName = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSpatialZoneTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType)
  }
  IfcSpatialZone.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialZone
}())
exports.IfcSpatialZone = IfcSpatialZone

var IfcSpatialZoneType = /** @class */ (function() {
  /**
   *
   */
  function IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.LongName = LongName
  }
  IfcSpatialZoneType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSpatialZoneTypeEnum(tape[9])
    let LongName
    if (tape[10]) {
      LongName = tape[10]
    } else {
      LongName = null
    }
    return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName)
  }
  IfcSpatialZoneType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSpatialZoneType
}())
exports.IfcSpatialZoneType = IfcSpatialZoneType

var IfcSphere = /** @class */ (function() {
  /**
   *
   */
  function IfcSphere(expressID, type, Position, Radius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Radius = Radius
  }
  IfcSphere.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let Radius
    Radius = tape[1]
    return new IfcSphere(expressID, type, Position, Radius)
  }
  IfcSphere.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcSphere
}())
exports.IfcSphere = IfcSphere

var IfcSphericalSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcSphericalSurface(expressID, type, Position, Radius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.Radius = Radius
  }
  IfcSphericalSurface.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let Radius
    Radius = tape[1]
    return new IfcSphericalSurface(expressID, type, Position, Radius)
  }
  IfcSphericalSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcSphericalSurface
}())
exports.IfcSphericalSurface = IfcSphericalSurface

var IfcStackTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcStackTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcStackTerminalTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcStackTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStackTerminal
}())
exports.IfcStackTerminal = IfcStackTerminal

var IfcStackTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcStackTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcStackTerminalTypeEnum(tape[9])
    return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcStackTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStackTerminalType
}())
exports.IfcStackTerminalType = IfcStackTerminalType

var IfcStair = /** @class */ (function() {
  /**
   *
   */
  function IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcStair.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcStairTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcStair.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStair
}())
exports.IfcStair = IfcStair

var IfcStairFlight = /** @class */ (function() {
  /**
   *
   */
  function IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.NumberOfRisers = NumberOfRisers
    this.NumberOfTreads = NumberOfTreads
    this.RiserHeight = RiserHeight
    this.TreadLength = TreadLength
    this.PredefinedType = PredefinedType
  }
  IfcStairFlight.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let NumberOfRisers
    if (tape[8]) {
      NumberOfRisers = tape[8]
    } else {
      NumberOfRisers = null
    }
    let NumberOfTreads
    if (tape[9]) {
      NumberOfTreads = tape[9]
    } else {
      NumberOfTreads = null
    }
    let RiserHeight
    if (tape[10]) {
      RiserHeight = tape[10]
    } else {
      RiserHeight = null
    }
    let TreadLength
    if (tape[11]) {
      TreadLength = tape[11]
    } else {
      TreadLength = null
    }
    let PredefinedType
    if (tape[12]) {
      PredefinedType = new IfcStairFlightTypeEnum(tape[12])
    } else {
      PredefinedType = null
    }
    return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType)
  }
  IfcStairFlight.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.NumberOfRisers) {
      args.push(REAL)
      args.push(this.NumberOfRisers)
    } else {
      args.push(EMPTY)
    }
    if (this.NumberOfTreads) {
      args.push(REAL)
      args.push(this.NumberOfTreads)
    } else {
      args.push(EMPTY)
    }
    if (this.RiserHeight) {
    } else {
      args.push(EMPTY)
    }
    if (this.TreadLength) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStairFlight
}())
exports.IfcStairFlight = IfcStairFlight

var IfcStairFlightType = /** @class */ (function() {
  /**
   *
   */
  function IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcStairFlightType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcStairFlightTypeEnum(tape[9])
    return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcStairFlightType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStairFlightType
}())
exports.IfcStairFlightType = IfcStairFlightType

var IfcStairType = /** @class */ (function() {
  /**
   *
   */
  function IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcStairType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcStairTypeEnum(tape[9])
    return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcStairType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStairType
}())
exports.IfcStairType = IfcStairType

var IfcStructuralAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
  }
  IfcStructuralAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
  }
  IfcStructuralAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralAction
}())
exports.IfcStructuralAction = IfcStructuralAction

var IfcStructuralActivity = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
  }
  IfcStructuralActivity.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
  }
  IfcStructuralActivity.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    return args
  }
  return IfcStructuralActivity
}())
exports.IfcStructuralActivity = IfcStructuralActivity

var IfcStructuralAnalysisModel = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.PredefinedType = PredefinedType
    this.OrientationOf2DPlane = OrientationOf2DPlane
    this.LoadedBy = LoadedBy
    this.HasResults = HasResults
    this.SharedPlacement = SharedPlacement
  }
  IfcStructuralAnalysisModel.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let PredefinedType
    PredefinedType = new IfcAnalysisModelTypeEnum(tape[5])
    let OrientationOf2DPlane
    if (tape[6]) {
      OrientationOf2DPlane = tape[6]
    } else {
      OrientationOf2DPlane = null
    }
    let LoadedBy
    if (tape[7]) {
      LoadedBy = []
      let LoadedBy_index = 0
      while (LoadedBy_index < tape[7].length) {
        LoadedBy.push(tape[7][LoadedBy_index++])
      }
    } else {
      LoadedBy = null
    }
    let HasResults
    if (tape[8]) {
      HasResults = []
      let HasResults_index = 0
      while (HasResults_index < tape[8].length) {
        HasResults.push(tape[8][HasResults_index++])
      }
    } else {
      HasResults = null
    }
    let SharedPlacement
    if (tape[9]) {
      SharedPlacement = tape[9]
    } else {
      SharedPlacement = null
    }
    return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement)
  }
  IfcStructuralAnalysisModel.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.OrientationOf2DPlane) {
      args.push(REF)
      args.push(this.OrientationOf2DPlane)
    } else {
      args.push(EMPTY)
    }
    if (this.LoadedBy) {
      args.push(SET_BEGIN)
      this.LoadedBy.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.HasResults) {
      args.push(SET_BEGIN)
      this.HasResults.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.SharedPlacement) {
      args.push(REF)
      args.push(this.SharedPlacement)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralAnalysisModel
}())
exports.IfcStructuralAnalysisModel = IfcStructuralAnalysisModel

var IfcStructuralConnection = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedCondition = AppliedCondition
  }
  IfcStructuralConnection.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedCondition
    if (tape[7]) {
      AppliedCondition = tape[7]
    } else {
      AppliedCondition = null
    }
    return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
  }
  IfcStructuralConnection.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralConnection
}())
exports.IfcStructuralConnection = IfcStructuralConnection

var IfcStructuralConnectionCondition = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralConnectionCondition(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcStructuralConnectionCondition.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcStructuralConnectionCondition(expressID, type, Name)
  }
  IfcStructuralConnectionCondition.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralConnectionCondition
}())
exports.IfcStructuralConnectionCondition = IfcStructuralConnectionCondition

var IfcStructuralCurveAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
    this.ProjectedOrTrue = ProjectedOrTrue
    this.PredefinedType = PredefinedType
  }
  IfcStructuralCurveAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    let ProjectedOrTrue
    if (tape[10]) {
      ProjectedOrTrue = new IfcProjectedOrTrueLengthEnum(tape[10])
    } else {
      ProjectedOrTrue = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralCurveActivityTypeEnum(tape[11])
    return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
  }
  IfcStructuralCurveAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    if (this.ProjectedOrTrue) {
      args.push(ENUM)
      args.push(this.ProjectedOrTrue.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralCurveAction
}())
exports.IfcStructuralCurveAction = IfcStructuralCurveAction

var IfcStructuralCurveConnection = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedCondition = AppliedCondition
    this.Axis = Axis
  }
  IfcStructuralCurveConnection.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedCondition
    if (tape[7]) {
      AppliedCondition = tape[7]
    } else {
      AppliedCondition = null
    }
    let Axis
    Axis = tape[8]
    return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis)
  }
  IfcStructuralCurveConnection.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Axis)
    return args
  }
  return IfcStructuralCurveConnection
}())
exports.IfcStructuralCurveConnection = IfcStructuralCurveConnection

var IfcStructuralCurveMember = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.PredefinedType = PredefinedType
    this.Axis = Axis
  }
  IfcStructuralCurveMember.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralCurveMemberTypeEnum(tape[7])
    let Axis
    Axis = tape[8]
    return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis)
  }
  IfcStructuralCurveMember.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(REF)
    args.push(this.Axis)
    return args
  }
  return IfcStructuralCurveMember
}())
exports.IfcStructuralCurveMember = IfcStructuralCurveMember

var IfcStructuralCurveMemberVarying = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.PredefinedType = PredefinedType
    this.Axis = Axis
  }
  IfcStructuralCurveMemberVarying.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralCurveMemberTypeEnum(tape[7])
    let Axis
    Axis = tape[8]
    return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis)
  }
  IfcStructuralCurveMemberVarying.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(REF)
    args.push(this.Axis)
    return args
  }
  return IfcStructuralCurveMemberVarying
}())
exports.IfcStructuralCurveMemberVarying = IfcStructuralCurveMemberVarying

var IfcStructuralCurveReaction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.PredefinedType = PredefinedType
  }
  IfcStructuralCurveReaction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let PredefinedType
    PredefinedType = new IfcStructuralCurveActivityTypeEnum(tape[9])
    return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType)
  }
  IfcStructuralCurveReaction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralCurveReaction
}())
exports.IfcStructuralCurveReaction = IfcStructuralCurveReaction

var IfcStructuralItem = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcStructuralItem.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcStructuralItem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralItem
}())
exports.IfcStructuralItem = IfcStructuralItem

var IfcStructuralLinearAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
    this.ProjectedOrTrue = ProjectedOrTrue
    this.PredefinedType = PredefinedType
  }
  IfcStructuralLinearAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    let ProjectedOrTrue
    if (tape[10]) {
      ProjectedOrTrue = new IfcProjectedOrTrueLengthEnum(tape[10])
    } else {
      ProjectedOrTrue = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralCurveActivityTypeEnum(tape[11])
    return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
  }
  IfcStructuralLinearAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    if (this.ProjectedOrTrue) {
      args.push(ENUM)
      args.push(this.ProjectedOrTrue.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralLinearAction
}())
exports.IfcStructuralLinearAction = IfcStructuralLinearAction

var IfcStructuralLoad = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoad(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcStructuralLoad.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcStructuralLoad(expressID, type, Name)
  }
  IfcStructuralLoad.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoad
}())
exports.IfcStructuralLoad = IfcStructuralLoad

var IfcStructuralLoadCase = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.PredefinedType = PredefinedType
    this.ActionType = ActionType
    this.ActionSource = ActionSource
    this.Coefficient = Coefficient
    this.Purpose = Purpose
    this.SelfWeightCoefficients = SelfWeightCoefficients
  }
  IfcStructuralLoadCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let PredefinedType
    PredefinedType = new IfcLoadGroupTypeEnum(tape[5])
    let ActionType
    ActionType = new IfcActionTypeEnum(tape[6])
    let ActionSource
    ActionSource = new IfcActionSourceTypeEnum(tape[7])
    let Coefficient
    if (tape[8]) {
      Coefficient = tape[8]
    } else {
      Coefficient = null
    }
    let Purpose
    if (tape[9]) {
      Purpose = tape[9]
    } else {
      Purpose = null
    }
    let SelfWeightCoefficients
    if (tape[10]) {
      SelfWeightCoefficients = []
      let SelfWeightCoefficients_index = 0
      while (SelfWeightCoefficients_index < tape[10].length) {
        SelfWeightCoefficients.push(tape[10][SelfWeightCoefficients_index++])
      }
    } else {
      SelfWeightCoefficients = null
    }
    return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients)
  }
  IfcStructuralLoadCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(ENUM)
    args.push(this.ActionType.value)
    args.push(ENUM)
    args.push(this.ActionSource.value)
    if (this.Coefficient) {
      args.push(REAL)
      args.push(this.Coefficient)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    if (this.SelfWeightCoefficients) {
      args.push(REAL)
      args.push.apply(args, this.SelfWeightCoefficients)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadCase
}())
exports.IfcStructuralLoadCase = IfcStructuralLoadCase

var IfcStructuralLoadConfiguration = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Values = Values
    this.Locations = Locations
  }
  IfcStructuralLoadConfiguration.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Values
    Values = []
    let Values_index = 0
    while (Values_index < tape[1].length) {
      Values.push(tape[1][Values_index++])
    }
    let Locations
    if (tape[2]) {
      Locations = []
      let Locations_index = 0
      while (Locations_index < tape[2].length) {
        Locations.push(tape[2][Locations_index++])
      }
    } else {
      Locations = null
    }
    return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations)
  }
  IfcStructuralLoadConfiguration.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Values.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    if (this.Locations) {
      args.push(REAL)
      args.push.apply(args, this.Locations)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadConfiguration
}())
exports.IfcStructuralLoadConfiguration = IfcStructuralLoadConfiguration

var IfcStructuralLoadGroup = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.PredefinedType = PredefinedType
    this.ActionType = ActionType
    this.ActionSource = ActionSource
    this.Coefficient = Coefficient
    this.Purpose = Purpose
  }
  IfcStructuralLoadGroup.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let PredefinedType
    PredefinedType = new IfcLoadGroupTypeEnum(tape[5])
    let ActionType
    ActionType = new IfcActionTypeEnum(tape[6])
    let ActionSource
    ActionSource = new IfcActionSourceTypeEnum(tape[7])
    let Coefficient
    if (tape[8]) {
      Coefficient = tape[8]
    } else {
      Coefficient = null
    }
    let Purpose
    if (tape[9]) {
      Purpose = tape[9]
    } else {
      Purpose = null
    }
    return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose)
  }
  IfcStructuralLoadGroup.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(ENUM)
    args.push(this.ActionType.value)
    args.push(ENUM)
    args.push(this.ActionSource.value)
    if (this.Coefficient) {
      args.push(REAL)
      args.push(this.Coefficient)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadGroup
}())
exports.IfcStructuralLoadGroup = IfcStructuralLoadGroup

var IfcStructuralLoadLinearForce = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.LinearForceX = LinearForceX
    this.LinearForceY = LinearForceY
    this.LinearForceZ = LinearForceZ
    this.LinearMomentX = LinearMomentX
    this.LinearMomentY = LinearMomentY
    this.LinearMomentZ = LinearMomentZ
  }
  IfcStructuralLoadLinearForce.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let LinearForceX
    if (tape[1]) {
      LinearForceX = tape[1]
    } else {
      LinearForceX = null
    }
    let LinearForceY
    if (tape[2]) {
      LinearForceY = tape[2]
    } else {
      LinearForceY = null
    }
    let LinearForceZ
    if (tape[3]) {
      LinearForceZ = tape[3]
    } else {
      LinearForceZ = null
    }
    let LinearMomentX
    if (tape[4]) {
      LinearMomentX = tape[4]
    } else {
      LinearMomentX = null
    }
    let LinearMomentY
    if (tape[5]) {
      LinearMomentY = tape[5]
    } else {
      LinearMomentY = null
    }
    let LinearMomentZ
    if (tape[6]) {
      LinearMomentZ = tape[6]
    } else {
      LinearMomentZ = null
    }
    return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ)
  }
  IfcStructuralLoadLinearForce.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearForceX) {
      args.push(REAL)
      args.push(this.LinearForceX)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearForceY) {
      args.push(REAL)
      args.push(this.LinearForceY)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearForceZ) {
      args.push(REAL)
      args.push(this.LinearForceZ)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearMomentX) {
      args.push(REAL)
      args.push(this.LinearMomentX)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearMomentY) {
      args.push(REAL)
      args.push(this.LinearMomentY)
    } else {
      args.push(EMPTY)
    }
    if (this.LinearMomentZ) {
      args.push(REAL)
      args.push(this.LinearMomentZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadLinearForce
}())
exports.IfcStructuralLoadLinearForce = IfcStructuralLoadLinearForce

var IfcStructuralLoadOrResult = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadOrResult(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcStructuralLoadOrResult.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcStructuralLoadOrResult(expressID, type, Name)
  }
  IfcStructuralLoadOrResult.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadOrResult
}())
exports.IfcStructuralLoadOrResult = IfcStructuralLoadOrResult

var IfcStructuralLoadPlanarForce = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.PlanarForceX = PlanarForceX
    this.PlanarForceY = PlanarForceY
    this.PlanarForceZ = PlanarForceZ
  }
  IfcStructuralLoadPlanarForce.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let PlanarForceX
    if (tape[1]) {
      PlanarForceX = tape[1]
    } else {
      PlanarForceX = null
    }
    let PlanarForceY
    if (tape[2]) {
      PlanarForceY = tape[2]
    } else {
      PlanarForceY = null
    }
    let PlanarForceZ
    if (tape[3]) {
      PlanarForceZ = tape[3]
    } else {
      PlanarForceZ = null
    }
    return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ)
  }
  IfcStructuralLoadPlanarForce.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.PlanarForceX) {
      args.push(REAL)
      args.push(this.PlanarForceX)
    } else {
      args.push(EMPTY)
    }
    if (this.PlanarForceY) {
      args.push(REAL)
      args.push(this.PlanarForceY)
    } else {
      args.push(EMPTY)
    }
    if (this.PlanarForceZ) {
      args.push(REAL)
      args.push(this.PlanarForceZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadPlanarForce
}())
exports.IfcStructuralLoadPlanarForce = IfcStructuralLoadPlanarForce

var IfcStructuralLoadSingleDisplacement = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DisplacementX = DisplacementX
    this.DisplacementY = DisplacementY
    this.DisplacementZ = DisplacementZ
    this.RotationalDisplacementRX = RotationalDisplacementRX
    this.RotationalDisplacementRY = RotationalDisplacementRY
    this.RotationalDisplacementRZ = RotationalDisplacementRZ
  }
  IfcStructuralLoadSingleDisplacement.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DisplacementX
    if (tape[1]) {
      DisplacementX = tape[1]
    } else {
      DisplacementX = null
    }
    let DisplacementY
    if (tape[2]) {
      DisplacementY = tape[2]
    } else {
      DisplacementY = null
    }
    let DisplacementZ
    if (tape[3]) {
      DisplacementZ = tape[3]
    } else {
      DisplacementZ = null
    }
    let RotationalDisplacementRX
    if (tape[4]) {
      RotationalDisplacementRX = tape[4]
    } else {
      RotationalDisplacementRX = null
    }
    let RotationalDisplacementRY
    if (tape[5]) {
      RotationalDisplacementRY = tape[5]
    } else {
      RotationalDisplacementRY = null
    }
    let RotationalDisplacementRZ
    if (tape[6]) {
      RotationalDisplacementRZ = tape[6]
    } else {
      RotationalDisplacementRZ = null
    }
    return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ)
  }
  IfcStructuralLoadSingleDisplacement.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementX) {
      args.push(REAL)
      args.push(this.DisplacementX)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementY) {
      args.push(REAL)
      args.push(this.DisplacementY)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementZ) {
      args.push(REAL)
      args.push(this.DisplacementZ)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRX) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRX)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRY) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRY)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRZ) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadSingleDisplacement
}())
exports.IfcStructuralLoadSingleDisplacement = IfcStructuralLoadSingleDisplacement

var IfcStructuralLoadSingleDisplacementDistortion = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DisplacementX = DisplacementX
    this.DisplacementY = DisplacementY
    this.DisplacementZ = DisplacementZ
    this.RotationalDisplacementRX = RotationalDisplacementRX
    this.RotationalDisplacementRY = RotationalDisplacementRY
    this.RotationalDisplacementRZ = RotationalDisplacementRZ
    this.Distortion = Distortion
  }
  IfcStructuralLoadSingleDisplacementDistortion.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DisplacementX
    if (tape[1]) {
      DisplacementX = tape[1]
    } else {
      DisplacementX = null
    }
    let DisplacementY
    if (tape[2]) {
      DisplacementY = tape[2]
    } else {
      DisplacementY = null
    }
    let DisplacementZ
    if (tape[3]) {
      DisplacementZ = tape[3]
    } else {
      DisplacementZ = null
    }
    let RotationalDisplacementRX
    if (tape[4]) {
      RotationalDisplacementRX = tape[4]
    } else {
      RotationalDisplacementRX = null
    }
    let RotationalDisplacementRY
    if (tape[5]) {
      RotationalDisplacementRY = tape[5]
    } else {
      RotationalDisplacementRY = null
    }
    let RotationalDisplacementRZ
    if (tape[6]) {
      RotationalDisplacementRZ = tape[6]
    } else {
      RotationalDisplacementRZ = null
    }
    let Distortion
    if (tape[7]) {
      Distortion = tape[7]
    } else {
      Distortion = null
    }
    return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion)
  }
  IfcStructuralLoadSingleDisplacementDistortion.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementX) {
      args.push(REAL)
      args.push(this.DisplacementX)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementY) {
      args.push(REAL)
      args.push(this.DisplacementY)
    } else {
      args.push(EMPTY)
    }
    if (this.DisplacementZ) {
      args.push(REAL)
      args.push(this.DisplacementZ)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRX) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRX)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRY) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRY)
    } else {
      args.push(EMPTY)
    }
    if (this.RotationalDisplacementRZ) {
      args.push(REAL)
      args.push(this.RotationalDisplacementRZ)
    } else {
      args.push(EMPTY)
    }
    if (this.Distortion) {
      args.push(REAL)
      args.push(this.Distortion)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadSingleDisplacementDistortion
}())
exports.IfcStructuralLoadSingleDisplacementDistortion = IfcStructuralLoadSingleDisplacementDistortion

var IfcStructuralLoadSingleForce = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.ForceX = ForceX
    this.ForceY = ForceY
    this.ForceZ = ForceZ
    this.MomentX = MomentX
    this.MomentY = MomentY
    this.MomentZ = MomentZ
  }
  IfcStructuralLoadSingleForce.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let ForceX
    if (tape[1]) {
      ForceX = tape[1]
    } else {
      ForceX = null
    }
    let ForceY
    if (tape[2]) {
      ForceY = tape[2]
    } else {
      ForceY = null
    }
    let ForceZ
    if (tape[3]) {
      ForceZ = tape[3]
    } else {
      ForceZ = null
    }
    let MomentX
    if (tape[4]) {
      MomentX = tape[4]
    } else {
      MomentX = null
    }
    let MomentY
    if (tape[5]) {
      MomentY = tape[5]
    } else {
      MomentY = null
    }
    let MomentZ
    if (tape[6]) {
      MomentZ = tape[6]
    } else {
      MomentZ = null
    }
    return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ)
  }
  IfcStructuralLoadSingleForce.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceX) {
      args.push(REAL)
      args.push(this.ForceX)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceY) {
      args.push(REAL)
      args.push(this.ForceY)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceZ) {
      args.push(REAL)
      args.push(this.ForceZ)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentX) {
      args.push(REAL)
      args.push(this.MomentX)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentY) {
      args.push(REAL)
      args.push(this.MomentY)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentZ) {
      args.push(REAL)
      args.push(this.MomentZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadSingleForce
}())
exports.IfcStructuralLoadSingleForce = IfcStructuralLoadSingleForce

var IfcStructuralLoadSingleForceWarping = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.ForceX = ForceX
    this.ForceY = ForceY
    this.ForceZ = ForceZ
    this.MomentX = MomentX
    this.MomentY = MomentY
    this.MomentZ = MomentZ
    this.WarpingMoment = WarpingMoment
  }
  IfcStructuralLoadSingleForceWarping.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let ForceX
    if (tape[1]) {
      ForceX = tape[1]
    } else {
      ForceX = null
    }
    let ForceY
    if (tape[2]) {
      ForceY = tape[2]
    } else {
      ForceY = null
    }
    let ForceZ
    if (tape[3]) {
      ForceZ = tape[3]
    } else {
      ForceZ = null
    }
    let MomentX
    if (tape[4]) {
      MomentX = tape[4]
    } else {
      MomentX = null
    }
    let MomentY
    if (tape[5]) {
      MomentY = tape[5]
    } else {
      MomentY = null
    }
    let MomentZ
    if (tape[6]) {
      MomentZ = tape[6]
    } else {
      MomentZ = null
    }
    let WarpingMoment
    if (tape[7]) {
      WarpingMoment = tape[7]
    } else {
      WarpingMoment = null
    }
    return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment)
  }
  IfcStructuralLoadSingleForceWarping.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceX) {
      args.push(REAL)
      args.push(this.ForceX)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceY) {
      args.push(REAL)
      args.push(this.ForceY)
    } else {
      args.push(EMPTY)
    }
    if (this.ForceZ) {
      args.push(REAL)
      args.push(this.ForceZ)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentX) {
      args.push(REAL)
      args.push(this.MomentX)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentY) {
      args.push(REAL)
      args.push(this.MomentY)
    } else {
      args.push(EMPTY)
    }
    if (this.MomentZ) {
      args.push(REAL)
      args.push(this.MomentZ)
    } else {
      args.push(EMPTY)
    }
    if (this.WarpingMoment) {
      args.push(REAL)
      args.push(this.WarpingMoment)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadSingleForceWarping
}())
exports.IfcStructuralLoadSingleForceWarping = IfcStructuralLoadSingleForceWarping

var IfcStructuralLoadStatic = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadStatic(expressID, type, Name) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
  }
  IfcStructuralLoadStatic.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    return new IfcStructuralLoadStatic(expressID, type, Name)
  }
  IfcStructuralLoadStatic.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadStatic
}())
exports.IfcStructuralLoadStatic = IfcStructuralLoadStatic

var IfcStructuralLoadTemperature = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DeltaTConstant = DeltaTConstant
    this.DeltaTY = DeltaTY
    this.DeltaTZ = DeltaTZ
  }
  IfcStructuralLoadTemperature.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DeltaTConstant
    if (tape[1]) {
      DeltaTConstant = tape[1]
    } else {
      DeltaTConstant = null
    }
    let DeltaTY
    if (tape[2]) {
      DeltaTY = tape[2]
    } else {
      DeltaTY = null
    }
    let DeltaTZ
    if (tape[3]) {
      DeltaTZ = tape[3]
    } else {
      DeltaTZ = null
    }
    return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ)
  }
  IfcStructuralLoadTemperature.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DeltaTConstant) {
      args.push(REAL)
      args.push(this.DeltaTConstant)
    } else {
      args.push(EMPTY)
    }
    if (this.DeltaTY) {
      args.push(REAL)
      args.push(this.DeltaTY)
    } else {
      args.push(EMPTY)
    }
    if (this.DeltaTZ) {
      args.push(REAL)
      args.push(this.DeltaTZ)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralLoadTemperature
}())
exports.IfcStructuralLoadTemperature = IfcStructuralLoadTemperature

var IfcStructuralMember = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
  }
  IfcStructuralMember.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
  }
  IfcStructuralMember.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralMember
}())
exports.IfcStructuralMember = IfcStructuralMember

var IfcStructuralPlanarAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
    this.ProjectedOrTrue = ProjectedOrTrue
    this.PredefinedType = PredefinedType
  }
  IfcStructuralPlanarAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    let ProjectedOrTrue
    if (tape[10]) {
      ProjectedOrTrue = new IfcProjectedOrTrueLengthEnum(tape[10])
    } else {
      ProjectedOrTrue = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralSurfaceActivityTypeEnum(tape[11])
    return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
  }
  IfcStructuralPlanarAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    if (this.ProjectedOrTrue) {
      args.push(ENUM)
      args.push(this.ProjectedOrTrue.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralPlanarAction
}())
exports.IfcStructuralPlanarAction = IfcStructuralPlanarAction

var IfcStructuralPointAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
  }
  IfcStructuralPointAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
  }
  IfcStructuralPointAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralPointAction
}())
exports.IfcStructuralPointAction = IfcStructuralPointAction

var IfcStructuralPointConnection = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedCondition = AppliedCondition
    this.ConditionCoordinateSystem = ConditionCoordinateSystem
  }
  IfcStructuralPointConnection.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedCondition
    if (tape[7]) {
      AppliedCondition = tape[7]
    } else {
      AppliedCondition = null
    }
    let ConditionCoordinateSystem
    if (tape[8]) {
      ConditionCoordinateSystem = tape[8]
    } else {
      ConditionCoordinateSystem = null
    }
    return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem)
  }
  IfcStructuralPointConnection.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    if (this.ConditionCoordinateSystem) {
      args.push(REF)
      args.push(this.ConditionCoordinateSystem)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralPointConnection
}())
exports.IfcStructuralPointConnection = IfcStructuralPointConnection

var IfcStructuralPointReaction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
  }
  IfcStructuralPointReaction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
  }
  IfcStructuralPointReaction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    return args
  }
  return IfcStructuralPointReaction
}())
exports.IfcStructuralPointReaction = IfcStructuralPointReaction

var IfcStructuralReaction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
  }
  IfcStructuralReaction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
  }
  IfcStructuralReaction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    return args
  }
  return IfcStructuralReaction
}())
exports.IfcStructuralReaction = IfcStructuralReaction

var IfcStructuralResultGroup = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.TheoryType = TheoryType
    this.ResultForLoadGroup = ResultForLoadGroup
    this.IsLinear = IsLinear
  }
  IfcStructuralResultGroup.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let TheoryType
    TheoryType = new IfcAnalysisTheoryTypeEnum(tape[5])
    let ResultForLoadGroup
    if (tape[6]) {
      ResultForLoadGroup = tape[6]
    } else {
      ResultForLoadGroup = null
    }
    let IsLinear
    IsLinear = tape[7]
    return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear)
  }
  IfcStructuralResultGroup.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.TheoryType.value)
    if (this.ResultForLoadGroup) {
      args.push(REF)
      args.push(this.ResultForLoadGroup)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralResultGroup
}())
exports.IfcStructuralResultGroup = IfcStructuralResultGroup

var IfcStructuralSurfaceAction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.DestabilizingLoad = DestabilizingLoad
    this.ProjectedOrTrue = ProjectedOrTrue
    this.PredefinedType = PredefinedType
  }
  IfcStructuralSurfaceAction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let DestabilizingLoad
    if (tape[9]) {
      DestabilizingLoad = tape[9]
    } else {
      DestabilizingLoad = null
    }
    let ProjectedOrTrue
    if (tape[10]) {
      ProjectedOrTrue = new IfcProjectedOrTrueLengthEnum(tape[10])
    } else {
      ProjectedOrTrue = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralSurfaceActivityTypeEnum(tape[11])
    return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
  }
  IfcStructuralSurfaceAction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    if (this.DestabilizingLoad) {
    } else {
      args.push(EMPTY)
    }
    if (this.ProjectedOrTrue) {
      args.push(ENUM)
      args.push(this.ProjectedOrTrue.value)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralSurfaceAction
}())
exports.IfcStructuralSurfaceAction = IfcStructuralSurfaceAction

var IfcStructuralSurfaceConnection = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedCondition = AppliedCondition
  }
  IfcStructuralSurfaceConnection.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedCondition
    if (tape[7]) {
      AppliedCondition = tape[7]
    } else {
      AppliedCondition = null
    }
    return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
  }
  IfcStructuralSurfaceConnection.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.AppliedCondition) {
      args.push(REF)
      args.push(this.AppliedCondition)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralSurfaceConnection
}())
exports.IfcStructuralSurfaceConnection = IfcStructuralSurfaceConnection

var IfcStructuralSurfaceMember = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.PredefinedType = PredefinedType
    this.Thickness = Thickness
  }
  IfcStructuralSurfaceMember.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralSurfaceMemberTypeEnum(tape[7])
    let Thickness
    if (tape[8]) {
      Thickness = tape[8]
    } else {
      Thickness = null
    }
    return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness)
  }
  IfcStructuralSurfaceMember.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.Thickness) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralSurfaceMember
}())
exports.IfcStructuralSurfaceMember = IfcStructuralSurfaceMember

var IfcStructuralSurfaceMemberVarying = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.PredefinedType = PredefinedType
    this.Thickness = Thickness
  }
  IfcStructuralSurfaceMemberVarying.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let PredefinedType
    PredefinedType = new IfcStructuralSurfaceMemberTypeEnum(tape[7])
    let Thickness
    if (tape[8]) {
      Thickness = tape[8]
    } else {
      Thickness = null
    }
    return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness)
  }
  IfcStructuralSurfaceMemberVarying.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.Thickness) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStructuralSurfaceMemberVarying
}())
exports.IfcStructuralSurfaceMemberVarying = IfcStructuralSurfaceMemberVarying

var IfcStructuralSurfaceReaction = /** @class */ (function() {
  /**
   *
   */
  function IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.AppliedLoad = AppliedLoad
    this.GlobalOrLocal = GlobalOrLocal
    this.PredefinedType = PredefinedType
  }
  IfcStructuralSurfaceReaction.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let AppliedLoad
    AppliedLoad = tape[7]
    let GlobalOrLocal
    GlobalOrLocal = new IfcGlobalOrLocalEnum(tape[8])
    let PredefinedType
    PredefinedType = new IfcStructuralSurfaceActivityTypeEnum(tape[9])
    return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType)
  }
  IfcStructuralSurfaceReaction.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AppliedLoad)
    args.push(ENUM)
    args.push(this.GlobalOrLocal.value)
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcStructuralSurfaceReaction
}())
exports.IfcStructuralSurfaceReaction = IfcStructuralSurfaceReaction

var IfcStyleModel = /** @class */ (function() {
  /**
   *
   */
  function IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcStyleModel.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcStyleModel.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcStyleModel
}())
exports.IfcStyleModel = IfcStyleModel

var IfcStyledItem = /** @class */ (function() {
  /**
   *
   */
  function IfcStyledItem(expressID, type, Item, Styles, Name) {
    this.expressID = expressID
    this.type = type
    this.Item = Item
    this.Styles = Styles
    this.Name = Name
  }
  IfcStyledItem.FromTape = function(expressID, type, tape) {
    let Item
    if (tape[0]) {
      Item = tape[0]
    } else {
      Item = null
    }
    let Styles
    Styles = []
    let Styles_index = 0
    while (Styles_index < tape[1].length) {
      Styles.push(ParseType(tape[1][Styles_index++], tape[1][Styles_index++][0]))
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    return new IfcStyledItem(expressID, type, Item, Styles, Name)
  }
  IfcStyledItem.prototype.ToTape = function() {
    const args = []
    if (this.Item) {
      args.push(REF)
      args.push(this.Item)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcStyledItem
}())
exports.IfcStyledItem = IfcStyledItem

var IfcStyledRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcStyledRepresentation.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcStyledRepresentation.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcStyledRepresentation
}())
exports.IfcStyledRepresentation = IfcStyledRepresentation

var IfcSubContractResource = /** @class */ (function() {
  /**
   *
   */
  function IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Usage = Usage
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcSubContractResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Usage
    if (tape[7]) {
      Usage = tape[7]
    } else {
      Usage = null
    }
    let BaseCosts
    if (tape[8]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[8].length) {
        BaseCosts.push(tape[8][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[9]) {
      BaseQuantity = tape[9]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcSubContractResourceTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcSubContractResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Usage) {
      args.push(REF)
      args.push(this.Usage)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSubContractResource
}())
exports.IfcSubContractResource = IfcSubContractResource

var IfcSubContractResourceType = /** @class */ (function() {
  /**
   *
   */
  function IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
    this.BaseCosts = BaseCosts
    this.BaseQuantity = BaseQuantity
    this.PredefinedType = PredefinedType
  }
  IfcSubContractResourceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    let BaseCosts
    if (tape[9]) {
      BaseCosts = []
      let BaseCosts_index = 0
      while (BaseCosts_index < tape[9].length) {
        BaseCosts.push(tape[9][BaseCosts_index++])
      }
    } else {
      BaseCosts = null
    }
    let BaseQuantity
    if (tape[10]) {
      BaseQuantity = tape[10]
    } else {
      BaseQuantity = null
    }
    let PredefinedType
    PredefinedType = new IfcSubContractResourceTypeEnum(tape[11])
    return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType)
  }
  IfcSubContractResourceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseCosts) {
      args.push(SET_BEGIN)
      this.BaseCosts.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.BaseQuantity) {
      args.push(REF)
      args.push(this.BaseQuantity)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSubContractResourceType
}())
exports.IfcSubContractResourceType = IfcSubContractResourceType

var IfcSubedge = /** @class */ (function() {
  /**
   *
   */
  function IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
    this.expressID = expressID
    this.type = type
    this.EdgeStart = EdgeStart
    this.EdgeEnd = EdgeEnd
    this.ParentEdge = ParentEdge
  }
  IfcSubedge.FromTape = function(expressID, type, tape) {
    let EdgeStart
    EdgeStart = tape[0]
    let EdgeEnd
    EdgeEnd = tape[1]
    let ParentEdge
    ParentEdge = tape[2]
    return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge)
  }
  IfcSubedge.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.EdgeStart)
    args.push(REF)
    args.push(this.EdgeEnd)
    args.push(REF)
    args.push(this.ParentEdge)
    return args
  }
  return IfcSubedge
}())
exports.IfcSubedge = IfcSubedge

var IfcSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcSurface(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcSurface.FromTape = function(expressID, type, tape) {
    return new IfcSurface(expressID, type)
  }
  IfcSurface.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcSurface
}())
exports.IfcSurface = IfcSurface

var IfcSurfaceCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID
    this.type = type
    this.Curve3D = Curve3D
    this.AssociatedGeometry = AssociatedGeometry
    this.MasterRepresentation = MasterRepresentation
  }
  IfcSurfaceCurve.FromTape = function(expressID, type, tape) {
    let Curve3D
    Curve3D = tape[0]
    let AssociatedGeometry
    AssociatedGeometry = []
    let AssociatedGeometry_index = 0
    while (AssociatedGeometry_index < tape[1].length) {
      AssociatedGeometry.push(tape[1][AssociatedGeometry_index++])
    }
    let MasterRepresentation
    MasterRepresentation = new IfcPreferredSurfaceCurveRepresentation(tape[2])
    return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation)
  }
  IfcSurfaceCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Curve3D)
    args.push(SET_BEGIN)
    this.AssociatedGeometry.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(ENUM)
    args.push(this.MasterRepresentation.value)
    return args
  }
  return IfcSurfaceCurve
}())
exports.IfcSurfaceCurve = IfcSurfaceCurve

var IfcSurfaceCurveSweptAreaSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
    this.Directrix = Directrix
    this.StartParam = StartParam
    this.EndParam = EndParam
    this.ReferenceSurface = ReferenceSurface
  }
  IfcSurfaceCurveSweptAreaSolid.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let Directrix
    Directrix = tape[2]
    let StartParam
    if (tape[3]) {
      StartParam = tape[3]
    } else {
      StartParam = null
    }
    let EndParam
    if (tape[4]) {
      EndParam = tape[4]
    } else {
      EndParam = null
    }
    let ReferenceSurface
    ReferenceSurface = tape[5]
    return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface)
  }
  IfcSurfaceCurveSweptAreaSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Directrix)
    if (this.StartParam) {
      args.push(REAL)
      args.push(this.StartParam)
    } else {
      args.push(EMPTY)
    }
    if (this.EndParam) {
      args.push(REAL)
      args.push(this.EndParam)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ReferenceSurface)
    return args
  }
  return IfcSurfaceCurveSweptAreaSolid
}())
exports.IfcSurfaceCurveSweptAreaSolid = IfcSurfaceCurveSweptAreaSolid

var IfcSurfaceFeature = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSurfaceFeature.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSurfaceFeatureTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSurfaceFeature.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSurfaceFeature
}())
exports.IfcSurfaceFeature = IfcSurfaceFeature

var IfcSurfaceOfLinearExtrusion = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID
    this.type = type
    this.SweptCurve = SweptCurve
    this.Position = Position
    this.ExtrudedDirection = ExtrudedDirection
    this.Depth = Depth
  }
  IfcSurfaceOfLinearExtrusion.FromTape = function(expressID, type, tape) {
    let SweptCurve
    SweptCurve = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let ExtrudedDirection
    ExtrudedDirection = tape[2]
    let Depth
    Depth = tape[3]
    return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth)
  }
  IfcSurfaceOfLinearExtrusion.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptCurve)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.ExtrudedDirection)
    args.push(REAL)
    args.push(this.Depth)
    return args
  }
  return IfcSurfaceOfLinearExtrusion
}())
exports.IfcSurfaceOfLinearExtrusion = IfcSurfaceOfLinearExtrusion

var IfcSurfaceOfRevolution = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition) {
    this.expressID = expressID
    this.type = type
    this.SweptCurve = SweptCurve
    this.Position = Position
    this.AxisPosition = AxisPosition
  }
  IfcSurfaceOfRevolution.FromTape = function(expressID, type, tape) {
    let SweptCurve
    SweptCurve = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    let AxisPosition
    AxisPosition = tape[2]
    return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition)
  }
  IfcSurfaceOfRevolution.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptCurve)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.AxisPosition)
    return args
  }
  return IfcSurfaceOfRevolution
}())
exports.IfcSurfaceOfRevolution = IfcSurfaceOfRevolution

var IfcSurfaceReinforcementArea = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.SurfaceReinforcement1 = SurfaceReinforcement1
    this.SurfaceReinforcement2 = SurfaceReinforcement2
    this.ShearReinforcement = ShearReinforcement
  }
  IfcSurfaceReinforcementArea.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let SurfaceReinforcement1
    if (tape[1]) {
      SurfaceReinforcement1 = []
      let SurfaceReinforcement1_index = 0
      while (SurfaceReinforcement1_index < tape[1].length) {
        SurfaceReinforcement1.push(tape[1][SurfaceReinforcement1_index++])
      }
    } else {
      SurfaceReinforcement1 = null
    }
    let SurfaceReinforcement2
    if (tape[2]) {
      SurfaceReinforcement2 = []
      let SurfaceReinforcement2_index = 0
      while (SurfaceReinforcement2_index < tape[2].length) {
        SurfaceReinforcement2.push(tape[2][SurfaceReinforcement2_index++])
      }
    } else {
      SurfaceReinforcement2 = null
    }
    let ShearReinforcement
    if (tape[3]) {
      ShearReinforcement = tape[3]
    } else {
      ShearReinforcement = null
    }
    return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement)
  }
  IfcSurfaceReinforcementArea.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.SurfaceReinforcement1) {
      args.push(REAL)
      args.push.apply(args, this.SurfaceReinforcement1)
    } else {
      args.push(EMPTY)
    }
    if (this.SurfaceReinforcement2) {
      args.push(REAL)
      args.push.apply(args, this.SurfaceReinforcement2)
    } else {
      args.push(EMPTY)
    }
    if (this.ShearReinforcement) {
      args.push(REAL)
      args.push(this.ShearReinforcement)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSurfaceReinforcementArea
}())
exports.IfcSurfaceReinforcementArea = IfcSurfaceReinforcementArea

var IfcSurfaceStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyle(expressID, type, Name, Side, Styles) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Side = Side
    this.Styles = Styles
  }
  IfcSurfaceStyle.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Side
    Side = new IfcSurfaceSide(tape[1])
    let Styles
    Styles = []
    let Styles_index = 0
    while (Styles_index < tape[2].length) {
      Styles.push(ParseType(tape[2][Styles_index++], tape[2][Styles_index++][0]))
    }
    return new IfcSurfaceStyle(expressID, type, Name, Side, Styles)
  }
  IfcSurfaceStyle.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.Side.value)
    return args
  }
  return IfcSurfaceStyle
}())
exports.IfcSurfaceStyle = IfcSurfaceStyle

var IfcSurfaceStyleLighting = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
    this.expressID = expressID
    this.type = type
    this.DiffuseTransmissionColour = DiffuseTransmissionColour
    this.DiffuseReflectionColour = DiffuseReflectionColour
    this.TransmissionColour = TransmissionColour
    this.ReflectanceColour = ReflectanceColour
  }
  IfcSurfaceStyleLighting.FromTape = function(expressID, type, tape) {
    let DiffuseTransmissionColour
    DiffuseTransmissionColour = tape[0]
    let DiffuseReflectionColour
    DiffuseReflectionColour = tape[1]
    let TransmissionColour
    TransmissionColour = tape[2]
    let ReflectanceColour
    ReflectanceColour = tape[3]
    return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour)
  }
  IfcSurfaceStyleLighting.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.DiffuseTransmissionColour)
    args.push(REF)
    args.push(this.DiffuseReflectionColour)
    args.push(REF)
    args.push(this.TransmissionColour)
    args.push(REF)
    args.push(this.ReflectanceColour)
    return args
  }
  return IfcSurfaceStyleLighting
}())
exports.IfcSurfaceStyleLighting = IfcSurfaceStyleLighting

var IfcSurfaceStyleRefraction = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor) {
    this.expressID = expressID
    this.type = type
    this.RefractionIndex = RefractionIndex
    this.DispersionFactor = DispersionFactor
  }
  IfcSurfaceStyleRefraction.FromTape = function(expressID, type, tape) {
    let RefractionIndex
    if (tape[0]) {
      RefractionIndex = tape[0]
    } else {
      RefractionIndex = null
    }
    let DispersionFactor
    if (tape[1]) {
      DispersionFactor = tape[1]
    } else {
      DispersionFactor = null
    }
    return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor)
  }
  IfcSurfaceStyleRefraction.prototype.ToTape = function() {
    const args = []
    if (this.RefractionIndex) {
      args.push(REAL)
      args.push(this.RefractionIndex)
    } else {
      args.push(EMPTY)
    }
    if (this.DispersionFactor) {
      args.push(REAL)
      args.push(this.DispersionFactor)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSurfaceStyleRefraction
}())
exports.IfcSurfaceStyleRefraction = IfcSurfaceStyleRefraction

var IfcSurfaceStyleRendering = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
    this.expressID = expressID
    this.type = type
    this.SurfaceColour = SurfaceColour
    this.Transparency = Transparency
    this.DiffuseColour = DiffuseColour
    this.TransmissionColour = TransmissionColour
    this.DiffuseTransmissionColour = DiffuseTransmissionColour
    this.ReflectionColour = ReflectionColour
    this.SpecularColour = SpecularColour
    this.SpecularHighlight = SpecularHighlight
    this.ReflectanceMethod = ReflectanceMethod
  }
  IfcSurfaceStyleRendering.FromTape = function(expressID, type, tape) {
    let SurfaceColour
    SurfaceColour = tape[0]
    let Transparency
    if (tape[1]) {
      Transparency = tape[1]
    } else {
      Transparency = null
    }
    let DiffuseColour
    if (tape[2]) {
      DiffuseColour = ParseType(tape[2], tape[3][0])
    } else {
      DiffuseColour = null
    }
    let TransmissionColour
    if (tape[3]) {
      TransmissionColour = ParseType(tape[3], tape[4][0])
    } else {
      TransmissionColour = null
    }
    let DiffuseTransmissionColour
    if (tape[4]) {
      DiffuseTransmissionColour = ParseType(tape[4], tape[5][0])
    } else {
      DiffuseTransmissionColour = null
    }
    let ReflectionColour
    if (tape[5]) {
      ReflectionColour = ParseType(tape[5], tape[6][0])
    } else {
      ReflectionColour = null
    }
    let SpecularColour
    if (tape[6]) {
      SpecularColour = ParseType(tape[6], tape[7][0])
    } else {
      SpecularColour = null
    }
    let SpecularHighlight
    if (tape[7]) {
      SpecularHighlight = ParseType(tape[7], tape[8][0])
    } else {
      SpecularHighlight = null
    }
    let ReflectanceMethod
    ReflectanceMethod = new IfcReflectanceMethodEnum(tape[8])
    return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod)
  }
  IfcSurfaceStyleRendering.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SurfaceColour)
    if (this.Transparency) {
    } else {
      args.push(EMPTY)
    }
    if (this.DiffuseColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransmissionColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.DiffuseTransmissionColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.ReflectionColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.SpecularColour) {
    } else {
      args.push(EMPTY)
    }
    if (this.SpecularHighlight) {
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ReflectanceMethod.value)
    return args
  }
  return IfcSurfaceStyleRendering
}())
exports.IfcSurfaceStyleRendering = IfcSurfaceStyleRendering

var IfcSurfaceStyleShading = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency) {
    this.expressID = expressID
    this.type = type
    this.SurfaceColour = SurfaceColour
    this.Transparency = Transparency
  }
  IfcSurfaceStyleShading.FromTape = function(expressID, type, tape) {
    let SurfaceColour
    SurfaceColour = tape[0]
    let Transparency
    if (tape[1]) {
      Transparency = tape[1]
    } else {
      Transparency = null
    }
    return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency)
  }
  IfcSurfaceStyleShading.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SurfaceColour)
    if (this.Transparency) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSurfaceStyleShading
}())
exports.IfcSurfaceStyleShading = IfcSurfaceStyleShading

var IfcSurfaceStyleWithTextures = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceStyleWithTextures(expressID, type, Textures) {
    this.expressID = expressID
    this.type = type
    this.Textures = Textures
  }
  IfcSurfaceStyleWithTextures.FromTape = function(expressID, type, tape) {
    let Textures
    Textures = []
    let Textures_index = 0
    while (Textures_index < tape[0].length) {
      Textures.push(tape[0][Textures_index++])
    }
    return new IfcSurfaceStyleWithTextures(expressID, type, Textures)
  }
  IfcSurfaceStyleWithTextures.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Textures.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcSurfaceStyleWithTextures
}())
exports.IfcSurfaceStyleWithTextures = IfcSurfaceStyleWithTextures

var IfcSurfaceTexture = /** @class */ (function() {
  /**
   *
   */
  function IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
    this.expressID = expressID
    this.type = type
    this.RepeatS = RepeatS
    this.RepeatT = RepeatT
    this.Mode = Mode
    this.TextureTransform = TextureTransform
    this.Parameter = Parameter
  }
  IfcSurfaceTexture.FromTape = function(expressID, type, tape) {
    let RepeatS
    RepeatS = tape[0]
    let RepeatT
    RepeatT = tape[1]
    let Mode
    if (tape[2]) {
      Mode = tape[2]
    } else {
      Mode = null
    }
    let TextureTransform
    if (tape[3]) {
      TextureTransform = tape[3]
    } else {
      TextureTransform = null
    }
    let Parameter
    if (tape[4]) {
      Parameter = []
      let Parameter_index = 0
      while (Parameter_index < tape[4].length) {
        Parameter.push(tape[4][Parameter_index++])
      }
    } else {
      Parameter = null
    }
    return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter)
  }
  IfcSurfaceTexture.prototype.ToTape = function() {
    const args = []
    if (this.Mode) {
      args.push(STRING)
      args.push(this.Mode)
    } else {
      args.push(EMPTY)
    }
    if (this.TextureTransform) {
      args.push(REF)
      args.push(this.TextureTransform)
    } else {
      args.push(EMPTY)
    }
    if (this.Parameter) {
      args.push(STRING)
      args.push.apply(args, this.Parameter)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSurfaceTexture
}())
exports.IfcSurfaceTexture = IfcSurfaceTexture

var IfcSweptAreaSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcSweptAreaSolid(expressID, type, SweptArea, Position) {
    this.expressID = expressID
    this.type = type
    this.SweptArea = SweptArea
    this.Position = Position
  }
  IfcSweptAreaSolid.FromTape = function(expressID, type, tape) {
    let SweptArea
    SweptArea = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    return new IfcSweptAreaSolid(expressID, type, SweptArea, Position)
  }
  IfcSweptAreaSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptArea)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSweptAreaSolid
}())
exports.IfcSweptAreaSolid = IfcSweptAreaSolid

var IfcSweptDiskSolid = /** @class */ (function() {
  /**
   *
   */
  function IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
    this.expressID = expressID
    this.type = type
    this.Directrix = Directrix
    this.Radius = Radius
    this.InnerRadius = InnerRadius
    this.StartParam = StartParam
    this.EndParam = EndParam
  }
  IfcSweptDiskSolid.FromTape = function(expressID, type, tape) {
    let Directrix
    Directrix = tape[0]
    let Radius
    Radius = tape[1]
    let InnerRadius
    if (tape[2]) {
      InnerRadius = tape[2]
    } else {
      InnerRadius = null
    }
    let StartParam
    if (tape[3]) {
      StartParam = tape[3]
    } else {
      StartParam = null
    }
    let EndParam
    if (tape[4]) {
      EndParam = tape[4]
    } else {
      EndParam = null
    }
    return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam)
  }
  IfcSweptDiskSolid.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Directrix)
    if (this.InnerRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartParam) {
      args.push(REAL)
      args.push(this.StartParam)
    } else {
      args.push(EMPTY)
    }
    if (this.EndParam) {
      args.push(REAL)
      args.push(this.EndParam)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSweptDiskSolid
}())
exports.IfcSweptDiskSolid = IfcSweptDiskSolid

var IfcSweptDiskSolidPolygonal = /** @class */ (function() {
  /**
   *
   */
  function IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
    this.expressID = expressID
    this.type = type
    this.Directrix = Directrix
    this.Radius = Radius
    this.InnerRadius = InnerRadius
    this.StartParam = StartParam
    this.EndParam = EndParam
    this.FilletRadius = FilletRadius
  }
  IfcSweptDiskSolidPolygonal.FromTape = function(expressID, type, tape) {
    let Directrix
    Directrix = tape[0]
    let Radius
    Radius = tape[1]
    let InnerRadius
    if (tape[2]) {
      InnerRadius = tape[2]
    } else {
      InnerRadius = null
    }
    let StartParam
    if (tape[3]) {
      StartParam = tape[3]
    } else {
      StartParam = null
    }
    let EndParam
    if (tape[4]) {
      EndParam = tape[4]
    } else {
      EndParam = null
    }
    let FilletRadius
    if (tape[5]) {
      FilletRadius = tape[5]
    } else {
      FilletRadius = null
    }
    return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius)
  }
  IfcSweptDiskSolidPolygonal.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Directrix)
    if (this.InnerRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.StartParam) {
      args.push(REAL)
      args.push(this.StartParam)
    } else {
      args.push(EMPTY)
    }
    if (this.EndParam) {
      args.push(REAL)
      args.push(this.EndParam)
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSweptDiskSolidPolygonal
}())
exports.IfcSweptDiskSolidPolygonal = IfcSweptDiskSolidPolygonal

var IfcSweptSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcSweptSurface(expressID, type, SweptCurve, Position) {
    this.expressID = expressID
    this.type = type
    this.SweptCurve = SweptCurve
    this.Position = Position
  }
  IfcSweptSurface.FromTape = function(expressID, type, tape) {
    let SweptCurve
    SweptCurve = tape[0]
    let Position
    if (tape[1]) {
      Position = tape[1]
    } else {
      Position = null
    }
    return new IfcSweptSurface(expressID, type, SweptCurve, Position)
  }
  IfcSweptSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.SweptCurve)
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSweptSurface
}())
exports.IfcSweptSurface = IfcSweptSurface

var IfcSwitchingDevice = /** @class */ (function() {
  /**
   *
   */
  function IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSwitchingDevice.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSwitchingDeviceTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSwitchingDevice.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSwitchingDevice
}())
exports.IfcSwitchingDevice = IfcSwitchingDevice

var IfcSwitchingDeviceType = /** @class */ (function() {
  /**
   *
   */
  function IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSwitchingDeviceType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcSwitchingDeviceTypeEnum(tape[9])
    return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSwitchingDeviceType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcSwitchingDeviceType
}())
exports.IfcSwitchingDeviceType = IfcSwitchingDeviceType

var IfcSystem = /** @class */ (function() {
  /**
   *
   */
  function IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
  }
  IfcSystem.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType)
  }
  IfcSystem.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSystem
}())
exports.IfcSystem = IfcSystem

var IfcSystemFurnitureElement = /** @class */ (function() {
  /**
   *
   */
  function IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcSystemFurnitureElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcSystemFurnitureElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcSystemFurnitureElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSystemFurnitureElement
}())
exports.IfcSystemFurnitureElement = IfcSystemFurnitureElement

var IfcSystemFurnitureElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcSystemFurnitureElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcSystemFurnitureElementTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcSystemFurnitureElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcSystemFurnitureElementType
}())
exports.IfcSystemFurnitureElementType = IfcSystemFurnitureElementType

var IfcTShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Depth = Depth
    this.FlangeWidth = FlangeWidth
    this.WebThickness = WebThickness
    this.FlangeThickness = FlangeThickness
    this.FilletRadius = FilletRadius
    this.FlangeEdgeRadius = FlangeEdgeRadius
    this.WebEdgeRadius = WebEdgeRadius
    this.WebSlope = WebSlope
    this.FlangeSlope = FlangeSlope
  }
  IfcTShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Depth
    Depth = tape[3]
    let FlangeWidth
    FlangeWidth = tape[4]
    let WebThickness
    WebThickness = tape[5]
    let FlangeThickness
    FlangeThickness = tape[6]
    let FilletRadius
    if (tape[7]) {
      FilletRadius = tape[7]
    } else {
      FilletRadius = null
    }
    let FlangeEdgeRadius
    if (tape[8]) {
      FlangeEdgeRadius = tape[8]
    } else {
      FlangeEdgeRadius = null
    }
    let WebEdgeRadius
    if (tape[9]) {
      WebEdgeRadius = tape[9]
    } else {
      WebEdgeRadius = null
    }
    let WebSlope
    if (tape[10]) {
      WebSlope = tape[10]
    } else {
      WebSlope = null
    }
    let FlangeSlope
    if (tape[11]) {
      FlangeSlope = tape[11]
    } else {
      FlangeSlope = null
    }
    return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope)
  }
  IfcTShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.FlangeEdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.WebEdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.WebSlope) {
      args.push(REAL)
      args.push(this.WebSlope)
    } else {
      args.push(EMPTY)
    }
    if (this.FlangeSlope) {
      args.push(REAL)
      args.push(this.FlangeSlope)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTShapeProfileDef
}())
exports.IfcTShapeProfileDef = IfcTShapeProfileDef

var IfcTable = /** @class */ (function() {
  /**
   *
   */
  function IfcTable(expressID, type, Name, Rows, Columns) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Rows = Rows
    this.Columns = Columns
  }
  IfcTable.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let Rows
    if (tape[1]) {
      Rows = []
      let Rows_index = 0
      while (Rows_index < tape[1].length) {
        Rows.push(tape[1][Rows_index++])
      }
    } else {
      Rows = null
    }
    let Columns
    if (tape[2]) {
      Columns = []
      let Columns_index = 0
      while (Columns_index < tape[2].length) {
        Columns.push(tape[2][Columns_index++])
      }
    } else {
      Columns = null
    }
    return new IfcTable(expressID, type, Name, Rows, Columns)
  }
  IfcTable.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Rows) {
      args.push(SET_BEGIN)
      this.Rows.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Columns) {
      args.push(SET_BEGIN)
      this.Columns.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTable
}())
exports.IfcTable = IfcTable

var IfcTableColumn = /** @class */ (function() {
  /**
   *
   */
  function IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
    this.expressID = expressID
    this.type = type
    this.Identifier = Identifier
    this.Name = Name
    this.Description = Description
    this.Unit = Unit
    this.ReferencePath = ReferencePath
  }
  IfcTableColumn.FromTape = function(expressID, type, tape) {
    let Identifier
    if (tape[0]) {
      Identifier = tape[0]
    } else {
      Identifier = null
    }
    let Name
    if (tape[1]) {
      Name = tape[1]
    } else {
      Name = null
    }
    let Description
    if (tape[2]) {
      Description = tape[2]
    } else {
      Description = null
    }
    let Unit
    if (tape[3]) {
      Unit = ParseType(tape[3], tape[4][0])
    } else {
      Unit = null
    }
    let ReferencePath
    if (tape[4]) {
      ReferencePath = tape[4]
    } else {
      ReferencePath = null
    }
    return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath)
  }
  IfcTableColumn.prototype.ToTape = function() {
    const args = []
    if (this.Identifier) {
      args.push(STRING)
      args.push(this.Identifier)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    if (this.ReferencePath) {
      args.push(REF)
      args.push(this.ReferencePath)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTableColumn
}())
exports.IfcTableColumn = IfcTableColumn

var IfcTableRow = /** @class */ (function() {
  /**
   *
   */
  function IfcTableRow(expressID, type, RowCells, IsHeading) {
    this.expressID = expressID
    this.type = type
    this.RowCells = RowCells
    this.IsHeading = IsHeading
  }
  IfcTableRow.FromTape = function(expressID, type, tape) {
    let RowCells
    if (tape[0]) {
      RowCells = []
      let RowCells_index = 0
      while (RowCells_index < tape[0].length) {
        RowCells.push(ParseType(tape[0][RowCells_index++], tape[0][RowCells_index++][0]))
      }
    } else {
      RowCells = null
    }
    let IsHeading
    if (tape[1]) {
      IsHeading = tape[1]
    } else {
      IsHeading = null
    }
    return new IfcTableRow(expressID, type, RowCells, IsHeading)
  }
  IfcTableRow.prototype.ToTape = function() {
    const args = []
    if (this.RowCells) {
    } else {
      args.push(EMPTY)
    }
    if (this.IsHeading) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTableRow
}())
exports.IfcTableRow = IfcTableRow

var IfcTank = /** @class */ (function() {
  /**
   *
   */
  function IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcTank.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcTankTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcTank.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTank
}())
exports.IfcTank = IfcTank

var IfcTankType = /** @class */ (function() {
  /**
   *
   */
  function IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTankType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTankTypeEnum(tape[9])
    return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTankType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTankType
}())
exports.IfcTankType = IfcTankType

var IfcTask = /** @class */ (function() {
  /**
   *
   */
  function IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.Status = Status
    this.WorkMethod = WorkMethod
    this.IsMilestone = IsMilestone
    this.Priority = Priority
    this.TaskTime = TaskTime
    this.PredefinedType = PredefinedType
  }
  IfcTask.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[6]) {
      LongDescription = tape[6]
    } else {
      LongDescription = null
    }
    let Status
    if (tape[7]) {
      Status = tape[7]
    } else {
      Status = null
    }
    let WorkMethod
    if (tape[8]) {
      WorkMethod = tape[8]
    } else {
      WorkMethod = null
    }
    let IsMilestone
    IsMilestone = tape[9]
    let Priority
    if (tape[10]) {
      Priority = tape[10]
    } else {
      Priority = null
    }
    let TaskTime
    if (tape[11]) {
      TaskTime = tape[11]
    } else {
      TaskTime = null
    }
    let PredefinedType
    if (tape[12]) {
      PredefinedType = new IfcTaskTypeEnum(tape[12])
    } else {
      PredefinedType = null
    }
    return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType)
  }
  IfcTask.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.Status) {
      args.push(STRING)
      args.push(this.Status)
    } else {
      args.push(EMPTY)
    }
    if (this.WorkMethod) {
      args.push(STRING)
      args.push(this.WorkMethod)
    } else {
      args.push(EMPTY)
    }
    if (this.Priority) {
      args.push(REAL)
      args.push(this.Priority)
    } else {
      args.push(EMPTY)
    }
    if (this.TaskTime) {
      args.push(REF)
      args.push(this.TaskTime)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTask
}())
exports.IfcTask = IfcTask

var IfcTaskTime = /** @class */ (function() {
  /**
   *
   */
  function IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.DurationType = DurationType
    this.ScheduleDuration = ScheduleDuration
    this.ScheduleStart = ScheduleStart
    this.ScheduleFinish = ScheduleFinish
    this.EarlyStart = EarlyStart
    this.EarlyFinish = EarlyFinish
    this.LateStart = LateStart
    this.LateFinish = LateFinish
    this.FreeFloat = FreeFloat
    this.TotalFloat = TotalFloat
    this.IsCritical = IsCritical
    this.StatusTime = StatusTime
    this.ActualDuration = ActualDuration
    this.ActualStart = ActualStart
    this.ActualFinish = ActualFinish
    this.RemainingTime = RemainingTime
    this.Completion = Completion
  }
  IfcTaskTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let DurationType
    if (tape[3]) {
      DurationType = new IfcTaskDurationEnum(tape[3])
    } else {
      DurationType = null
    }
    let ScheduleDuration
    if (tape[4]) {
      ScheduleDuration = tape[4]
    } else {
      ScheduleDuration = null
    }
    let ScheduleStart
    if (tape[5]) {
      ScheduleStart = tape[5]
    } else {
      ScheduleStart = null
    }
    let ScheduleFinish
    if (tape[6]) {
      ScheduleFinish = tape[6]
    } else {
      ScheduleFinish = null
    }
    let EarlyStart
    if (tape[7]) {
      EarlyStart = tape[7]
    } else {
      EarlyStart = null
    }
    let EarlyFinish
    if (tape[8]) {
      EarlyFinish = tape[8]
    } else {
      EarlyFinish = null
    }
    let LateStart
    if (tape[9]) {
      LateStart = tape[9]
    } else {
      LateStart = null
    }
    let LateFinish
    if (tape[10]) {
      LateFinish = tape[10]
    } else {
      LateFinish = null
    }
    let FreeFloat
    if (tape[11]) {
      FreeFloat = tape[11]
    } else {
      FreeFloat = null
    }
    let TotalFloat
    if (tape[12]) {
      TotalFloat = tape[12]
    } else {
      TotalFloat = null
    }
    let IsCritical
    if (tape[13]) {
      IsCritical = tape[13]
    } else {
      IsCritical = null
    }
    let StatusTime
    if (tape[14]) {
      StatusTime = tape[14]
    } else {
      StatusTime = null
    }
    let ActualDuration
    if (tape[15]) {
      ActualDuration = tape[15]
    } else {
      ActualDuration = null
    }
    let ActualStart
    if (tape[16]) {
      ActualStart = tape[16]
    } else {
      ActualStart = null
    }
    let ActualFinish
    if (tape[17]) {
      ActualFinish = tape[17]
    } else {
      ActualFinish = null
    }
    let RemainingTime
    if (tape[18]) {
      RemainingTime = tape[18]
    } else {
      RemainingTime = null
    }
    let Completion
    if (tape[19]) {
      Completion = tape[19]
    } else {
      Completion = null
    }
    return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion)
  }
  IfcTaskTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.DurationType) {
      args.push(ENUM)
      args.push(this.DurationType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleDuration) {
      args.push(STRING)
      args.push(this.ScheduleDuration)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleStart) {
      args.push(STRING)
      args.push(this.ScheduleStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleFinish) {
      args.push(STRING)
      args.push(this.ScheduleFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.EarlyStart) {
      args.push(STRING)
      args.push(this.EarlyStart)
    } else {
      args.push(EMPTY)
    }
    if (this.EarlyFinish) {
      args.push(STRING)
      args.push(this.EarlyFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.LateStart) {
      args.push(STRING)
      args.push(this.LateStart)
    } else {
      args.push(EMPTY)
    }
    if (this.LateFinish) {
      args.push(STRING)
      args.push(this.LateFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.FreeFloat) {
      args.push(STRING)
      args.push(this.FreeFloat)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalFloat) {
      args.push(STRING)
      args.push(this.TotalFloat)
    } else {
      args.push(EMPTY)
    }
    if (this.IsCritical) {
    } else {
      args.push(EMPTY)
    }
    if (this.StatusTime) {
      args.push(STRING)
      args.push(this.StatusTime)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualDuration) {
      args.push(STRING)
      args.push(this.ActualDuration)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualStart) {
      args.push(STRING)
      args.push(this.ActualStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualFinish) {
      args.push(STRING)
      args.push(this.ActualFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.RemainingTime) {
      args.push(STRING)
      args.push(this.RemainingTime)
    } else {
      args.push(EMPTY)
    }
    if (this.Completion) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTaskTime
}())
exports.IfcTaskTime = IfcTaskTime

var IfcTaskTimeRecurring = /** @class */ (function() {
  /**
   *
   */
  function IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.DurationType = DurationType
    this.ScheduleDuration = ScheduleDuration
    this.ScheduleStart = ScheduleStart
    this.ScheduleFinish = ScheduleFinish
    this.EarlyStart = EarlyStart
    this.EarlyFinish = EarlyFinish
    this.LateStart = LateStart
    this.LateFinish = LateFinish
    this.FreeFloat = FreeFloat
    this.TotalFloat = TotalFloat
    this.IsCritical = IsCritical
    this.StatusTime = StatusTime
    this.ActualDuration = ActualDuration
    this.ActualStart = ActualStart
    this.ActualFinish = ActualFinish
    this.RemainingTime = RemainingTime
    this.Completion = Completion
    this.Recurrence = Recurrence
  }
  IfcTaskTimeRecurring.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let DurationType
    if (tape[3]) {
      DurationType = new IfcTaskDurationEnum(tape[3])
    } else {
      DurationType = null
    }
    let ScheduleDuration
    if (tape[4]) {
      ScheduleDuration = tape[4]
    } else {
      ScheduleDuration = null
    }
    let ScheduleStart
    if (tape[5]) {
      ScheduleStart = tape[5]
    } else {
      ScheduleStart = null
    }
    let ScheduleFinish
    if (tape[6]) {
      ScheduleFinish = tape[6]
    } else {
      ScheduleFinish = null
    }
    let EarlyStart
    if (tape[7]) {
      EarlyStart = tape[7]
    } else {
      EarlyStart = null
    }
    let EarlyFinish
    if (tape[8]) {
      EarlyFinish = tape[8]
    } else {
      EarlyFinish = null
    }
    let LateStart
    if (tape[9]) {
      LateStart = tape[9]
    } else {
      LateStart = null
    }
    let LateFinish
    if (tape[10]) {
      LateFinish = tape[10]
    } else {
      LateFinish = null
    }
    let FreeFloat
    if (tape[11]) {
      FreeFloat = tape[11]
    } else {
      FreeFloat = null
    }
    let TotalFloat
    if (tape[12]) {
      TotalFloat = tape[12]
    } else {
      TotalFloat = null
    }
    let IsCritical
    if (tape[13]) {
      IsCritical = tape[13]
    } else {
      IsCritical = null
    }
    let StatusTime
    if (tape[14]) {
      StatusTime = tape[14]
    } else {
      StatusTime = null
    }
    let ActualDuration
    if (tape[15]) {
      ActualDuration = tape[15]
    } else {
      ActualDuration = null
    }
    let ActualStart
    if (tape[16]) {
      ActualStart = tape[16]
    } else {
      ActualStart = null
    }
    let ActualFinish
    if (tape[17]) {
      ActualFinish = tape[17]
    } else {
      ActualFinish = null
    }
    let RemainingTime
    if (tape[18]) {
      RemainingTime = tape[18]
    } else {
      RemainingTime = null
    }
    let Completion
    if (tape[19]) {
      Completion = tape[19]
    } else {
      Completion = null
    }
    let Recurrence
    Recurrence = tape[20]
    return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence)
  }
  IfcTaskTimeRecurring.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.DurationType) {
      args.push(ENUM)
      args.push(this.DurationType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleDuration) {
      args.push(STRING)
      args.push(this.ScheduleDuration)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleStart) {
      args.push(STRING)
      args.push(this.ScheduleStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ScheduleFinish) {
      args.push(STRING)
      args.push(this.ScheduleFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.EarlyStart) {
      args.push(STRING)
      args.push(this.EarlyStart)
    } else {
      args.push(EMPTY)
    }
    if (this.EarlyFinish) {
      args.push(STRING)
      args.push(this.EarlyFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.LateStart) {
      args.push(STRING)
      args.push(this.LateStart)
    } else {
      args.push(EMPTY)
    }
    if (this.LateFinish) {
      args.push(STRING)
      args.push(this.LateFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.FreeFloat) {
      args.push(STRING)
      args.push(this.FreeFloat)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalFloat) {
      args.push(STRING)
      args.push(this.TotalFloat)
    } else {
      args.push(EMPTY)
    }
    if (this.IsCritical) {
    } else {
      args.push(EMPTY)
    }
    if (this.StatusTime) {
      args.push(STRING)
      args.push(this.StatusTime)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualDuration) {
      args.push(STRING)
      args.push(this.ActualDuration)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualStart) {
      args.push(STRING)
      args.push(this.ActualStart)
    } else {
      args.push(EMPTY)
    }
    if (this.ActualFinish) {
      args.push(STRING)
      args.push(this.ActualFinish)
    } else {
      args.push(EMPTY)
    }
    if (this.RemainingTime) {
      args.push(STRING)
      args.push(this.RemainingTime)
    } else {
      args.push(EMPTY)
    }
    if (this.Completion) {
    } else {
      args.push(EMPTY)
    }
    args.push(REF)
    args.push(this.Recurrence)
    return args
  }
  return IfcTaskTimeRecurring
}())
exports.IfcTaskTimeRecurring = IfcTaskTimeRecurring

var IfcTaskType = /** @class */ (function() {
  /**
   *
   */
  function IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ProcessType = ProcessType
    this.PredefinedType = PredefinedType
    this.WorkMethod = WorkMethod
  }
  IfcTaskType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ProcessType
    if (tape[8]) {
      ProcessType = tape[8]
    } else {
      ProcessType = null
    }
    let PredefinedType
    PredefinedType = new IfcTaskTypeEnum(tape[9])
    let WorkMethod
    if (tape[10]) {
      WorkMethod = tape[10]
    } else {
      WorkMethod = null
    }
    return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod)
  }
  IfcTaskType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ProcessType) {
      args.push(STRING)
      args.push(this.ProcessType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.WorkMethod) {
      args.push(STRING)
      args.push(this.WorkMethod)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTaskType
}())
exports.IfcTaskType = IfcTaskType

var IfcTelecomAddress = /** @class */ (function() {
  /**
   *
   */
  function IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
    this.expressID = expressID
    this.type = type
    this.Purpose = Purpose
    this.Description = Description
    this.UserDefinedPurpose = UserDefinedPurpose
    this.TelephoneNumbers = TelephoneNumbers
    this.FacsimileNumbers = FacsimileNumbers
    this.PagerNumber = PagerNumber
    this.ElectronicMailAddresses = ElectronicMailAddresses
    this.WWWHomePageURL = WWWHomePageURL
    this.MessagingIDs = MessagingIDs
  }
  IfcTelecomAddress.FromTape = function(expressID, type, tape) {
    let Purpose
    if (tape[0]) {
      Purpose = new IfcAddressTypeEnum(tape[0])
    } else {
      Purpose = null
    }
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let UserDefinedPurpose
    if (tape[2]) {
      UserDefinedPurpose = tape[2]
    } else {
      UserDefinedPurpose = null
    }
    let TelephoneNumbers
    if (tape[3]) {
      TelephoneNumbers = []
      let TelephoneNumbers_index = 0
      while (TelephoneNumbers_index < tape[3].length) {
        TelephoneNumbers.push(tape[3][TelephoneNumbers_index++])
      }
    } else {
      TelephoneNumbers = null
    }
    let FacsimileNumbers
    if (tape[4]) {
      FacsimileNumbers = []
      let FacsimileNumbers_index = 0
      while (FacsimileNumbers_index < tape[4].length) {
        FacsimileNumbers.push(tape[4][FacsimileNumbers_index++])
      }
    } else {
      FacsimileNumbers = null
    }
    let PagerNumber
    if (tape[5]) {
      PagerNumber = tape[5]
    } else {
      PagerNumber = null
    }
    let ElectronicMailAddresses
    if (tape[6]) {
      ElectronicMailAddresses = []
      let ElectronicMailAddresses_index = 0
      while (ElectronicMailAddresses_index < tape[6].length) {
        ElectronicMailAddresses.push(tape[6][ElectronicMailAddresses_index++])
      }
    } else {
      ElectronicMailAddresses = null
    }
    let WWWHomePageURL
    if (tape[7]) {
      WWWHomePageURL = tape[7]
    } else {
      WWWHomePageURL = null
    }
    let MessagingIDs
    if (tape[8]) {
      MessagingIDs = []
      let MessagingIDs_index = 0
      while (MessagingIDs_index < tape[8].length) {
        MessagingIDs.push(tape[8][MessagingIDs_index++])
      }
    } else {
      MessagingIDs = null
    }
    return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs)
  }
  IfcTelecomAddress.prototype.ToTape = function() {
    const args = []
    if (this.Purpose) {
      args.push(ENUM)
      args.push(this.Purpose.value)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPurpose) {
      args.push(STRING)
      args.push(this.UserDefinedPurpose)
    } else {
      args.push(EMPTY)
    }
    if (this.TelephoneNumbers) {
      args.push(STRING)
      args.push.apply(args, this.TelephoneNumbers)
    } else {
      args.push(EMPTY)
    }
    if (this.FacsimileNumbers) {
      args.push(STRING)
      args.push.apply(args, this.FacsimileNumbers)
    } else {
      args.push(EMPTY)
    }
    if (this.PagerNumber) {
      args.push(STRING)
      args.push(this.PagerNumber)
    } else {
      args.push(EMPTY)
    }
    if (this.ElectronicMailAddresses) {
      args.push(STRING)
      args.push.apply(args, this.ElectronicMailAddresses)
    } else {
      args.push(EMPTY)
    }
    if (this.WWWHomePageURL) {
      args.push(STRING)
      args.push(this.WWWHomePageURL)
    } else {
      args.push(EMPTY)
    }
    if (this.MessagingIDs) {
      args.push(STRING)
      args.push.apply(args, this.MessagingIDs)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTelecomAddress
}())
exports.IfcTelecomAddress = IfcTelecomAddress

var IfcTendon = /** @class */ (function() {
  /**
   *
   */
  function IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
    this.PredefinedType = PredefinedType
    this.NominalDiameter = NominalDiameter
    this.CrossSectionArea = CrossSectionArea
    this.TensionForce = TensionForce
    this.PreStress = PreStress
    this.FrictionCoefficient = FrictionCoefficient
    this.AnchorageSlip = AnchorageSlip
    this.MinCurvatureRadius = MinCurvatureRadius
  }
  IfcTendon.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcTendonTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    let NominalDiameter
    if (tape[10]) {
      NominalDiameter = tape[10]
    } else {
      NominalDiameter = null
    }
    let CrossSectionArea
    if (tape[11]) {
      CrossSectionArea = tape[11]
    } else {
      CrossSectionArea = null
    }
    let TensionForce
    if (tape[12]) {
      TensionForce = tape[12]
    } else {
      TensionForce = null
    }
    let PreStress
    if (tape[13]) {
      PreStress = tape[13]
    } else {
      PreStress = null
    }
    let FrictionCoefficient
    if (tape[14]) {
      FrictionCoefficient = tape[14]
    } else {
      FrictionCoefficient = null
    }
    let AnchorageSlip
    if (tape[15]) {
      AnchorageSlip = tape[15]
    } else {
      AnchorageSlip = null
    }
    let MinCurvatureRadius
    if (tape[16]) {
      MinCurvatureRadius = tape[16]
    } else {
      MinCurvatureRadius = null
    }
    return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius)
  }
  IfcTendon.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.CrossSectionArea) {
      args.push(REAL)
      args.push(this.CrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.TensionForce) {
      args.push(REAL)
      args.push(this.TensionForce)
    } else {
      args.push(EMPTY)
    }
    if (this.PreStress) {
      args.push(REAL)
      args.push(this.PreStress)
    } else {
      args.push(EMPTY)
    }
    if (this.FrictionCoefficient) {
    } else {
      args.push(EMPTY)
    }
    if (this.AnchorageSlip) {
    } else {
      args.push(EMPTY)
    }
    if (this.MinCurvatureRadius) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTendon
}())
exports.IfcTendon = IfcTendon

var IfcTendonAnchor = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
    this.PredefinedType = PredefinedType
  }
  IfcTendonAnchor.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcTendonAnchorTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType)
  }
  IfcTendonAnchor.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTendonAnchor
}())
exports.IfcTendonAnchor = IfcTendonAnchor

var IfcTendonAnchorType = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTendonAnchorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTendonAnchorTypeEnum(tape[9])
    return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTendonAnchorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTendonAnchorType
}())
exports.IfcTendonAnchorType = IfcTendonAnchorType

var IfcTendonConduit = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.SteelGrade = SteelGrade
    this.PredefinedType = PredefinedType
  }
  IfcTendonConduit.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let SteelGrade
    if (tape[8]) {
      SteelGrade = tape[8]
    } else {
      SteelGrade = null
    }
    let PredefinedType
    PredefinedType = new IfcTendonConduitTypeEnum(tape[9])
    return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType)
  }
  IfcTendonConduit.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.SteelGrade) {
      args.push(STRING)
      args.push(this.SteelGrade)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTendonConduit
}())
exports.IfcTendonConduit = IfcTendonConduit

var IfcTendonConduitType = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTendonConduitType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTendonConduitTypeEnum(tape[9])
    return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTendonConduitType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTendonConduitType
}())
exports.IfcTendonConduitType = IfcTendonConduitType

var IfcTendonType = /** @class */ (function() {
  /**
   *
   */
  function IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.NominalDiameter = NominalDiameter
    this.CrossSectionArea = CrossSectionArea
    this.SheathDiameter = SheathDiameter
  }
  IfcTendonType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTendonTypeEnum(tape[9])
    let NominalDiameter
    if (tape[10]) {
      NominalDiameter = tape[10]
    } else {
      NominalDiameter = null
    }
    let CrossSectionArea
    if (tape[11]) {
      CrossSectionArea = tape[11]
    } else {
      CrossSectionArea = null
    }
    let SheathDiameter
    if (tape[12]) {
      SheathDiameter = tape[12]
    } else {
      SheathDiameter = null
    }
    return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter)
  }
  IfcTendonType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    if (this.NominalDiameter) {
    } else {
      args.push(EMPTY)
    }
    if (this.CrossSectionArea) {
      args.push(REAL)
      args.push(this.CrossSectionArea)
    } else {
      args.push(EMPTY)
    }
    if (this.SheathDiameter) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTendonType
}())
exports.IfcTendonType = IfcTendonType

var IfcTessellatedFaceSet = /** @class */ (function() {
  /**
   *
   */
  function IfcTessellatedFaceSet(expressID, type, Coordinates) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
  }
  IfcTessellatedFaceSet.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = tape[0]
    return new IfcTessellatedFaceSet(expressID, type, Coordinates)
  }
  IfcTessellatedFaceSet.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Coordinates)
    return args
  }
  return IfcTessellatedFaceSet
}())
exports.IfcTessellatedFaceSet = IfcTessellatedFaceSet

var IfcTessellatedItem = /** @class */ (function() {
  /**
   *
   */
  function IfcTessellatedItem(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcTessellatedItem.FromTape = function(expressID, type, tape) {
    return new IfcTessellatedItem(expressID, type)
  }
  IfcTessellatedItem.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcTessellatedItem
}())
exports.IfcTessellatedItem = IfcTessellatedItem

var IfcTextLiteral = /** @class */ (function() {
  /**
   *
   */
  function IfcTextLiteral(expressID, type, Literal, Placement, Path) {
    this.expressID = expressID
    this.type = type
    this.Literal = Literal
    this.Placement = Placement
    this.Path = Path
  }
  IfcTextLiteral.FromTape = function(expressID, type, tape) {
    let Literal
    Literal = tape[0]
    let Placement
    Placement = ParseType(tape[1], tape[2][0])
    let Path
    Path = new IfcTextPath(tape[2])
    return new IfcTextLiteral(expressID, type, Literal, Placement, Path)
  }
  IfcTextLiteral.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Literal)
    args.push(ENUM)
    args.push(this.Path.value)
    return args
  }
  return IfcTextLiteral
}())
exports.IfcTextLiteral = IfcTextLiteral

var IfcTextLiteralWithExtent = /** @class */ (function() {
  /**
   *
   */
  function IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
    this.expressID = expressID
    this.type = type
    this.Literal = Literal
    this.Placement = Placement
    this.Path = Path
    this.Extent = Extent
    this.BoxAlignment = BoxAlignment
  }
  IfcTextLiteralWithExtent.FromTape = function(expressID, type, tape) {
    let Literal
    Literal = tape[0]
    let Placement
    Placement = ParseType(tape[1], tape[2][0])
    let Path
    Path = new IfcTextPath(tape[2])
    let Extent
    Extent = tape[3]
    let BoxAlignment
    BoxAlignment = tape[4]
    return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment)
  }
  IfcTextLiteralWithExtent.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Literal)
    args.push(ENUM)
    args.push(this.Path.value)
    args.push(REF)
    args.push(this.Extent)
    return args
  }
  return IfcTextLiteralWithExtent
}())
exports.IfcTextLiteralWithExtent = IfcTextLiteralWithExtent

var IfcTextStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.TextCharacterAppearance = TextCharacterAppearance
    this.TextStyle = TextStyle
    this.TextFontStyle = TextFontStyle
    this.ModelOrDraughting = ModelOrDraughting
  }
  IfcTextStyle.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let TextCharacterAppearance
    if (tape[1]) {
      TextCharacterAppearance = tape[1]
    } else {
      TextCharacterAppearance = null
    }
    let TextStyle
    if (tape[2]) {
      TextStyle = tape[2]
    } else {
      TextStyle = null
    }
    let TextFontStyle
    TextFontStyle = ParseType(tape[3], tape[4][0])
    let ModelOrDraughting
    if (tape[4]) {
      ModelOrDraughting = tape[4]
    } else {
      ModelOrDraughting = null
    }
    return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting)
  }
  IfcTextStyle.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.TextCharacterAppearance) {
      args.push(REF)
      args.push(this.TextCharacterAppearance)
    } else {
      args.push(EMPTY)
    }
    if (this.TextStyle) {
      args.push(REF)
      args.push(this.TextStyle)
    } else {
      args.push(EMPTY)
    }
    if (this.ModelOrDraughting) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTextStyle
}())
exports.IfcTextStyle = IfcTextStyle

var IfcTextStyleFontModel = /** @class */ (function() {
  /**
   *
   */
  function IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.FontFamily = FontFamily
    this.FontStyle = FontStyle
    this.FontVariant = FontVariant
    this.FontWeight = FontWeight
    this.FontSize = FontSize
  }
  IfcTextStyleFontModel.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let FontFamily
    FontFamily = []
    let FontFamily_index = 0
    while (FontFamily_index < tape[1].length) {
      FontFamily.push(tape[1][FontFamily_index++])
    }
    let FontStyle
    if (tape[2]) {
      FontStyle = tape[2]
    } else {
      FontStyle = null
    }
    let FontVariant
    if (tape[3]) {
      FontVariant = tape[3]
    } else {
      FontVariant = null
    }
    let FontWeight
    if (tape[4]) {
      FontWeight = tape[4]
    } else {
      FontWeight = null
    }
    let FontSize
    FontSize = ParseType(tape[5], tape[6][0])
    return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize)
  }
  IfcTextStyleFontModel.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    args.push(STRING)
    args.push.apply(args, this.FontFamily)
    if (this.FontStyle) {
      args.push(STRING)
      args.push(this.FontStyle)
    } else {
      args.push(EMPTY)
    }
    if (this.FontVariant) {
      args.push(STRING)
      args.push(this.FontVariant)
    } else {
      args.push(EMPTY)
    }
    if (this.FontWeight) {
      args.push(STRING)
      args.push(this.FontWeight)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTextStyleFontModel
}())
exports.IfcTextStyleFontModel = IfcTextStyleFontModel

var IfcTextStyleForDefinedFont = /** @class */ (function() {
  /**
   *
   */
  function IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour) {
    this.expressID = expressID
    this.type = type
    this.Colour = Colour
    this.BackgroundColour = BackgroundColour
  }
  IfcTextStyleForDefinedFont.FromTape = function(expressID, type, tape) {
    let Colour
    Colour = ParseType(tape[0], tape[1][0])
    let BackgroundColour
    if (tape[1]) {
      BackgroundColour = ParseType(tape[1], tape[2][0])
    } else {
      BackgroundColour = null
    }
    return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour)
  }
  IfcTextStyleForDefinedFont.prototype.ToTape = function() {
    const args = []
    if (this.BackgroundColour) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTextStyleForDefinedFont
}())
exports.IfcTextStyleForDefinedFont = IfcTextStyleForDefinedFont

var IfcTextStyleTextModel = /** @class */ (function() {
  /**
   *
   */
  function IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
    this.expressID = expressID
    this.type = type
    this.TextIndent = TextIndent
    this.TextAlign = TextAlign
    this.TextDecoration = TextDecoration
    this.LetterSpacing = LetterSpacing
    this.WordSpacing = WordSpacing
    this.TextTransform = TextTransform
    this.LineHeight = LineHeight
  }
  IfcTextStyleTextModel.FromTape = function(expressID, type, tape) {
    let TextIndent
    if (tape[0]) {
      TextIndent = ParseType(tape[0], tape[1][0])
    } else {
      TextIndent = null
    }
    let TextAlign
    if (tape[1]) {
      TextAlign = tape[1]
    } else {
      TextAlign = null
    }
    let TextDecoration
    if (tape[2]) {
      TextDecoration = tape[2]
    } else {
      TextDecoration = null
    }
    let LetterSpacing
    if (tape[3]) {
      LetterSpacing = ParseType(tape[3], tape[4][0])
    } else {
      LetterSpacing = null
    }
    let WordSpacing
    if (tape[4]) {
      WordSpacing = ParseType(tape[4], tape[5][0])
    } else {
      WordSpacing = null
    }
    let TextTransform
    if (tape[5]) {
      TextTransform = tape[5]
    } else {
      TextTransform = null
    }
    let LineHeight
    if (tape[6]) {
      LineHeight = ParseType(tape[6], tape[7][0])
    } else {
      LineHeight = null
    }
    return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight)
  }
  IfcTextStyleTextModel.prototype.ToTape = function() {
    const args = []
    if (this.TextIndent) {
    } else {
      args.push(EMPTY)
    }
    if (this.TextAlign) {
      args.push(STRING)
      args.push(this.TextAlign)
    } else {
      args.push(EMPTY)
    }
    if (this.TextDecoration) {
      args.push(STRING)
      args.push(this.TextDecoration)
    } else {
      args.push(EMPTY)
    }
    if (this.LetterSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.WordSpacing) {
    } else {
      args.push(EMPTY)
    }
    if (this.TextTransform) {
      args.push(STRING)
      args.push(this.TextTransform)
    } else {
      args.push(EMPTY)
    }
    if (this.LineHeight) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTextStyleTextModel
}())
exports.IfcTextStyleTextModel = IfcTextStyleTextModel

var IfcTextureCoordinate = /** @class */ (function() {
  /**
   *
   */
  function IfcTextureCoordinate(expressID, type, Maps) {
    this.expressID = expressID
    this.type = type
    this.Maps = Maps
  }
  IfcTextureCoordinate.FromTape = function(expressID, type, tape) {
    let Maps
    Maps = []
    let Maps_index = 0
    while (Maps_index < tape[0].length) {
      Maps.push(tape[0][Maps_index++])
    }
    return new IfcTextureCoordinate(expressID, type, Maps)
  }
  IfcTextureCoordinate.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Maps.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcTextureCoordinate
}())
exports.IfcTextureCoordinate = IfcTextureCoordinate

var IfcTextureCoordinateGenerator = /** @class */ (function() {
  /**
   *
   */
  function IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter) {
    this.expressID = expressID
    this.type = type
    this.Maps = Maps
    this.Mode = Mode
    this.Parameter = Parameter
  }
  IfcTextureCoordinateGenerator.FromTape = function(expressID, type, tape) {
    let Maps
    Maps = []
    let Maps_index = 0
    while (Maps_index < tape[0].length) {
      Maps.push(tape[0][Maps_index++])
    }
    let Mode
    Mode = tape[1]
    let Parameter
    if (tape[2]) {
      Parameter = []
      let Parameter_index = 0
      while (Parameter_index < tape[2].length) {
        Parameter.push(tape[2][Parameter_index++])
      }
    } else {
      Parameter = null
    }
    return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter)
  }
  IfcTextureCoordinateGenerator.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Maps.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(STRING)
    args.push(this.Mode)
    if (this.Parameter) {
      args.push(REAL)
      args.push.apply(args, this.Parameter)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTextureCoordinateGenerator
}())
exports.IfcTextureCoordinateGenerator = IfcTextureCoordinateGenerator

var IfcTextureMap = /** @class */ (function() {
  /**
   *
   */
  function IfcTextureMap(expressID, type, Maps, Vertices, MappedTo) {
    this.expressID = expressID
    this.type = type
    this.Maps = Maps
    this.Vertices = Vertices
    this.MappedTo = MappedTo
  }
  IfcTextureMap.FromTape = function(expressID, type, tape) {
    let Maps
    Maps = []
    let Maps_index = 0
    while (Maps_index < tape[0].length) {
      Maps.push(tape[0][Maps_index++])
    }
    let Vertices
    Vertices = []
    let Vertices_index = 0
    while (Vertices_index < tape[1].length) {
      Vertices.push(tape[1][Vertices_index++])
    }
    let MappedTo
    MappedTo = tape[2]
    return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo)
  }
  IfcTextureMap.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.Maps.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(SET_BEGIN)
    this.Vertices.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REF)
    args.push(this.MappedTo)
    return args
  }
  return IfcTextureMap
}())
exports.IfcTextureMap = IfcTextureMap

var IfcTextureVertex = /** @class */ (function() {
  /**
   *
   */
  function IfcTextureVertex(expressID, type, Coordinates) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
  }
  IfcTextureVertex.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = []
    let Coordinates_index = 0
    while (Coordinates_index < tape[0].length) {
      Coordinates.push(tape[0][Coordinates_index++])
    }
    return new IfcTextureVertex(expressID, type, Coordinates)
  }
  IfcTextureVertex.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.Coordinates)
    return args
  }
  return IfcTextureVertex
}())
exports.IfcTextureVertex = IfcTextureVertex

var IfcTextureVertexList = /** @class */ (function() {
  /**
   *
   */
  function IfcTextureVertexList(expressID, type, TexCoordsList) {
    this.expressID = expressID
    this.type = type
    this.TexCoordsList = TexCoordsList
  }
  IfcTextureVertexList.FromTape = function(expressID, type, tape) {
    let TexCoordsList
    TexCoordsList = []
    let TexCoordsList_index = 0
    while (TexCoordsList_index < tape[0].length) {
      TexCoordsList.push(tape[0][TexCoordsList_index++])
    }
    return new IfcTextureVertexList(expressID, type, TexCoordsList)
  }
  IfcTextureVertexList.prototype.ToTape = function() {
    const args = []
    args.push(REAL)
    args.push.apply(args, this.TexCoordsList)
    return args
  }
  return IfcTextureVertexList
}())
exports.IfcTextureVertexList = IfcTextureVertexList

var IfcTimePeriod = /** @class */ (function() {
  /**
   *
   */
  function IfcTimePeriod(expressID, type, StartTime, EndTime) {
    this.expressID = expressID
    this.type = type
    this.StartTime = StartTime
    this.EndTime = EndTime
  }
  IfcTimePeriod.FromTape = function(expressID, type, tape) {
    let StartTime
    StartTime = tape[0]
    let EndTime
    EndTime = tape[1]
    return new IfcTimePeriod(expressID, type, StartTime, EndTime)
  }
  IfcTimePeriod.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.StartTime)
    args.push(STRING)
    args.push(this.EndTime)
    return args
  }
  return IfcTimePeriod
}())
exports.IfcTimePeriod = IfcTimePeriod

var IfcTimeSeries = /** @class */ (function() {
  /**
   *
   */
  function IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.Description = Description
    this.StartTime = StartTime
    this.EndTime = EndTime
    this.TimeSeriesDataType = TimeSeriesDataType
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.Unit = Unit
  }
  IfcTimeSeries.FromTape = function(expressID, type, tape) {
    let Name
    Name = tape[0]
    let Description
    if (tape[1]) {
      Description = tape[1]
    } else {
      Description = null
    }
    let StartTime
    StartTime = tape[2]
    let EndTime
    EndTime = tape[3]
    let TimeSeriesDataType
    TimeSeriesDataType = new IfcTimeSeriesDataTypeEnum(tape[4])
    let DataOrigin
    DataOrigin = new IfcDataOriginEnum(tape[5])
    let UserDefinedDataOrigin
    if (tape[6]) {
      UserDefinedDataOrigin = tape[6]
    } else {
      UserDefinedDataOrigin = null
    }
    let Unit
    if (tape[7]) {
      Unit = ParseType(tape[7], tape[8][0])
    } else {
      Unit = null
    }
    return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
  }
  IfcTimeSeries.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.Name)
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    args.push(STRING)
    args.push(this.EndTime)
    args.push(ENUM)
    args.push(this.TimeSeriesDataType.value)
    args.push(ENUM)
    args.push(this.DataOrigin.value)
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.Unit) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTimeSeries
}())
exports.IfcTimeSeries = IfcTimeSeries

var IfcTimeSeriesValue = /** @class */ (function() {
  /**
   *
   */
  function IfcTimeSeriesValue(expressID, type, ListValues) {
    this.expressID = expressID
    this.type = type
    this.ListValues = ListValues
  }
  IfcTimeSeriesValue.FromTape = function(expressID, type, tape) {
    let ListValues
    ListValues = []
    let ListValues_index = 0
    while (ListValues_index < tape[0].length) {
      ListValues.push(ParseType(tape[0][ListValues_index++], tape[0][ListValues_index++][0]))
    }
    return new IfcTimeSeriesValue(expressID, type, ListValues)
  }
  IfcTimeSeriesValue.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcTimeSeriesValue
}())
exports.IfcTimeSeriesValue = IfcTimeSeriesValue

var IfcTopologicalRepresentationItem = /** @class */ (function() {
  /**
   *
   */
  function IfcTopologicalRepresentationItem(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcTopologicalRepresentationItem.FromTape = function(expressID, type, tape) {
    return new IfcTopologicalRepresentationItem(expressID, type)
  }
  IfcTopologicalRepresentationItem.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcTopologicalRepresentationItem
}())
exports.IfcTopologicalRepresentationItem = IfcTopologicalRepresentationItem

var IfcTopologyRepresentation = /** @class */ (function() {
  /**
   *
   */
  function IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID
    this.type = type
    this.ContextOfItems = ContextOfItems
    this.RepresentationIdentifier = RepresentationIdentifier
    this.RepresentationType = RepresentationType
    this.Items = Items
  }
  IfcTopologyRepresentation.FromTape = function(expressID, type, tape) {
    let ContextOfItems
    ContextOfItems = tape[0]
    let RepresentationIdentifier
    if (tape[1]) {
      RepresentationIdentifier = tape[1]
    } else {
      RepresentationIdentifier = null
    }
    let RepresentationType
    if (tape[2]) {
      RepresentationType = tape[2]
    } else {
      RepresentationType = null
    }
    let Items
    Items = []
    let Items_index = 0
    while (Items_index < tape[3].length) {
      Items.push(tape[3][Items_index++])
    }
    return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
  }
  IfcTopologyRepresentation.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.ContextOfItems)
    if (this.RepresentationIdentifier) {
      args.push(STRING)
      args.push(this.RepresentationIdentifier)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationType) {
      args.push(STRING)
      args.push(this.RepresentationType)
    } else {
      args.push(EMPTY)
    }
    args.push(SET_BEGIN)
    this.Items.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    return args
  }
  return IfcTopologyRepresentation
}())
exports.IfcTopologyRepresentation = IfcTopologyRepresentation

var IfcToroidalSurface = /** @class */ (function() {
  /**
   *
   */
  function IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius) {
    this.expressID = expressID
    this.type = type
    this.Position = Position
    this.MajorRadius = MajorRadius
    this.MinorRadius = MinorRadius
  }
  IfcToroidalSurface.FromTape = function(expressID, type, tape) {
    let Position
    Position = tape[0]
    let MajorRadius
    MajorRadius = tape[1]
    let MinorRadius
    MinorRadius = tape[2]
    return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius)
  }
  IfcToroidalSurface.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Position)
    return args
  }
  return IfcToroidalSurface
}())
exports.IfcToroidalSurface = IfcToroidalSurface

var IfcTransformer = /** @class */ (function() {
  /**
   *
   */
  function IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcTransformer.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcTransformerTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcTransformer.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTransformer
}())
exports.IfcTransformer = IfcTransformer

var IfcTransformerType = /** @class */ (function() {
  /**
   *
   */
  function IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTransformerType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTransformerTypeEnum(tape[9])
    return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTransformerType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTransformerType
}())
exports.IfcTransformerType = IfcTransformerType

var IfcTransitionCurveSegment2D = /** @class */ (function() {
  /**
   *
   */
  function IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
    this.expressID = expressID
    this.type = type
    this.StartPoint = StartPoint
    this.StartDirection = StartDirection
    this.SegmentLength = SegmentLength
    this.StartRadius = StartRadius
    this.EndRadius = EndRadius
    this.IsStartRadiusCCW = IsStartRadiusCCW
    this.IsEndRadiusCCW = IsEndRadiusCCW
    this.TransitionCurveType = TransitionCurveType
  }
  IfcTransitionCurveSegment2D.FromTape = function(expressID, type, tape) {
    let StartPoint
    StartPoint = tape[0]
    let StartDirection
    StartDirection = tape[1]
    let SegmentLength
    SegmentLength = tape[2]
    let StartRadius
    if (tape[3]) {
      StartRadius = tape[3]
    } else {
      StartRadius = null
    }
    let EndRadius
    if (tape[4]) {
      EndRadius = tape[4]
    } else {
      EndRadius = null
    }
    let IsStartRadiusCCW
    IsStartRadiusCCW = tape[5]
    let IsEndRadiusCCW
    IsEndRadiusCCW = tape[6]
    let TransitionCurveType
    TransitionCurveType = new IfcTransitionCurveType(tape[7])
    return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType)
  }
  IfcTransitionCurveSegment2D.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.StartPoint)
    args.push(REAL)
    args.push(this.StartDirection)
    if (this.StartRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.EndRadius) {
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.TransitionCurveType.value)
    return args
  }
  return IfcTransitionCurveSegment2D
}())
exports.IfcTransitionCurveSegment2D = IfcTransitionCurveSegment2D

var IfcTransportElement = /** @class */ (function() {
  /**
   *
   */
  function IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcTransportElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcTransportElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcTransportElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTransportElement
}())
exports.IfcTransportElement = IfcTransportElement

var IfcTransportElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTransportElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTransportElementTypeEnum(tape[9])
    return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTransportElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTransportElementType
}())
exports.IfcTransportElementType = IfcTransportElementType

var IfcTrapeziumProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.BottomXDim = BottomXDim
    this.TopXDim = TopXDim
    this.YDim = YDim
    this.TopXOffset = TopXOffset
  }
  IfcTrapeziumProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let BottomXDim
    BottomXDim = tape[3]
    let TopXDim
    TopXDim = tape[4]
    let YDim
    YDim = tape[5]
    let TopXOffset
    TopXOffset = tape[6]
    return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset)
  }
  IfcTrapeziumProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push(this.TopXOffset)
    return args
  }
  return IfcTrapeziumProfileDef
}())
exports.IfcTrapeziumProfileDef = IfcTrapeziumProfileDef

var IfcTriangulatedFaceSet = /** @class */ (function() {
  /**
   *
   */
  function IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
    this.Normals = Normals
    this.Closed = Closed
    this.CoordIndex = CoordIndex
    this.PnIndex = PnIndex
  }
  IfcTriangulatedFaceSet.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = tape[0]
    let Normals
    if (tape[1]) {
      Normals = []
      let Normals_index = 0
      while (Normals_index < tape[1].length) {
        Normals.push(tape[1][Normals_index++])
      }
    } else {
      Normals = null
    }
    let Closed
    if (tape[2]) {
      Closed = tape[2]
    } else {
      Closed = null
    }
    let CoordIndex
    CoordIndex = []
    let CoordIndex_index = 0
    while (CoordIndex_index < tape[3].length) {
      CoordIndex.push(tape[3][CoordIndex_index++])
    }
    let PnIndex
    if (tape[4]) {
      PnIndex = []
      let PnIndex_index = 0
      while (PnIndex_index < tape[4].length) {
        PnIndex.push(tape[4][PnIndex_index++])
      }
    } else {
      PnIndex = null
    }
    return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex)
  }
  IfcTriangulatedFaceSet.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Coordinates)
    if (this.Normals) {
      args.push(REAL)
      args.push.apply(args, this.Normals)
    } else {
      args.push(EMPTY)
    }
    if (this.Closed) {
    } else {
      args.push(EMPTY)
    }
    if (this.PnIndex) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTriangulatedFaceSet
}())
exports.IfcTriangulatedFaceSet = IfcTriangulatedFaceSet

var IfcTriangulatedIrregularNetwork = /** @class */ (function() {
  /**
   *
   */
  function IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
    this.expressID = expressID
    this.type = type
    this.Coordinates = Coordinates
    this.Normals = Normals
    this.Closed = Closed
    this.CoordIndex = CoordIndex
    this.PnIndex = PnIndex
    this.Flags = Flags
  }
  IfcTriangulatedIrregularNetwork.FromTape = function(expressID, type, tape) {
    let Coordinates
    Coordinates = tape[0]
    let Normals
    if (tape[1]) {
      Normals = []
      let Normals_index = 0
      while (Normals_index < tape[1].length) {
        Normals.push(tape[1][Normals_index++])
      }
    } else {
      Normals = null
    }
    let Closed
    if (tape[2]) {
      Closed = tape[2]
    } else {
      Closed = null
    }
    let CoordIndex
    CoordIndex = []
    let CoordIndex_index = 0
    while (CoordIndex_index < tape[3].length) {
      CoordIndex.push(tape[3][CoordIndex_index++])
    }
    let PnIndex
    if (tape[4]) {
      PnIndex = []
      let PnIndex_index = 0
      while (PnIndex_index < tape[4].length) {
        PnIndex.push(tape[4][PnIndex_index++])
      }
    } else {
      PnIndex = null
    }
    let Flags
    Flags = []
    let Flags_index = 0
    while (Flags_index < tape[5].length) {
      Flags.push(tape[5][Flags_index++])
    }
    return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags)
  }
  IfcTriangulatedIrregularNetwork.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Coordinates)
    if (this.Normals) {
      args.push(REAL)
      args.push.apply(args, this.Normals)
    } else {
      args.push(EMPTY)
    }
    if (this.Closed) {
    } else {
      args.push(EMPTY)
    }
    if (this.PnIndex) {
    } else {
      args.push(EMPTY)
    }
    args.push(REAL)
    args.push.apply(args, this.Flags)
    return args
  }
  return IfcTriangulatedIrregularNetwork
}())
exports.IfcTriangulatedIrregularNetwork = IfcTriangulatedIrregularNetwork

var IfcTrimmedCurve = /** @class */ (function() {
  /**
   *
   */
  function IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
    this.expressID = expressID
    this.type = type
    this.BasisCurve = BasisCurve
    this.Trim1 = Trim1
    this.Trim2 = Trim2
    this.SenseAgreement = SenseAgreement
    this.MasterRepresentation = MasterRepresentation
  }
  IfcTrimmedCurve.FromTape = function(expressID, type, tape) {
    let BasisCurve
    BasisCurve = tape[0]
    let Trim1
    Trim1 = []
    let Trim1_index = 0
    while (Trim1_index < tape[1].length) {
      Trim1.push(ParseType(tape[1][Trim1_index++], tape[1][Trim1_index++][0]))
    }
    let Trim2
    Trim2 = []
    let Trim2_index = 0
    while (Trim2_index < tape[2].length) {
      Trim2.push(ParseType(tape[2][Trim2_index++], tape[2][Trim2_index++][0]))
    }
    let SenseAgreement
    SenseAgreement = tape[3]
    let MasterRepresentation
    MasterRepresentation = new IfcTrimmingPreference(tape[4])
    return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation)
  }
  IfcTrimmedCurve.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.BasisCurve)
    args.push(ENUM)
    args.push(this.MasterRepresentation.value)
    return args
  }
  return IfcTrimmedCurve
}())
exports.IfcTrimmedCurve = IfcTrimmedCurve

var IfcTubeBundle = /** @class */ (function() {
  /**
   *
   */
  function IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcTubeBundle.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcTubeBundleTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcTubeBundle.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTubeBundle
}())
exports.IfcTubeBundle = IfcTubeBundle

var IfcTubeBundleType = /** @class */ (function() {
  /**
   *
   */
  function IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcTubeBundleType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcTubeBundleTypeEnum(tape[9])
    return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcTubeBundleType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcTubeBundleType
}())
exports.IfcTubeBundleType = IfcTubeBundleType

var IfcTypeObject = /** @class */ (function() {
  /**
   *
   */
  function IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
  }
  IfcTypeObject.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
  }
  IfcTypeObject.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTypeObject
}())
exports.IfcTypeObject = IfcTypeObject

var IfcTypeProcess = /** @class */ (function() {
  /**
   *
   */
  function IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ProcessType = ProcessType
  }
  IfcTypeProcess.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ProcessType
    if (tape[8]) {
      ProcessType = tape[8]
    } else {
      ProcessType = null
    }
    return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
  }
  IfcTypeProcess.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ProcessType) {
      args.push(STRING)
      args.push(this.ProcessType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTypeProcess
}())
exports.IfcTypeProcess = IfcTypeProcess

var IfcTypeProduct = /** @class */ (function() {
  /**
   *
   */
  function IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
  }
  IfcTypeProduct.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag)
  }
  IfcTypeProduct.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTypeProduct
}())
exports.IfcTypeProduct = IfcTypeProduct

var IfcTypeResource = /** @class */ (function() {
  /**
   *
   */
  function IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.Identification = Identification
    this.LongDescription = LongDescription
    this.ResourceType = ResourceType
  }
  IfcTypeResource.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let Identification
    if (tape[6]) {
      Identification = tape[6]
    } else {
      Identification = null
    }
    let LongDescription
    if (tape[7]) {
      LongDescription = tape[7]
    } else {
      LongDescription = null
    }
    let ResourceType
    if (tape[8]) {
      ResourceType = tape[8]
    } else {
      ResourceType = null
    }
    return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType)
  }
  IfcTypeResource.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.LongDescription) {
      args.push(STRING)
      args.push(this.LongDescription)
    } else {
      args.push(EMPTY)
    }
    if (this.ResourceType) {
      args.push(STRING)
      args.push(this.ResourceType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcTypeResource
}())
exports.IfcTypeResource = IfcTypeResource

var IfcUShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Depth = Depth
    this.FlangeWidth = FlangeWidth
    this.WebThickness = WebThickness
    this.FlangeThickness = FlangeThickness
    this.FilletRadius = FilletRadius
    this.EdgeRadius = EdgeRadius
    this.FlangeSlope = FlangeSlope
  }
  IfcUShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Depth
    Depth = tape[3]
    let FlangeWidth
    FlangeWidth = tape[4]
    let WebThickness
    WebThickness = tape[5]
    let FlangeThickness
    FlangeThickness = tape[6]
    let FilletRadius
    if (tape[7]) {
      FilletRadius = tape[7]
    } else {
      FilletRadius = null
    }
    let EdgeRadius
    if (tape[8]) {
      EdgeRadius = tape[8]
    } else {
      EdgeRadius = null
    }
    let FlangeSlope
    if (tape[9]) {
      FlangeSlope = tape[9]
    } else {
      FlangeSlope = null
    }
    return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope)
  }
  IfcUShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.EdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.FlangeSlope) {
      args.push(REAL)
      args.push(this.FlangeSlope)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcUShapeProfileDef
}())
exports.IfcUShapeProfileDef = IfcUShapeProfileDef

var IfcUnitAssignment = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitAssignment(expressID, type, Units) {
    this.expressID = expressID
    this.type = type
    this.Units = Units
  }
  IfcUnitAssignment.FromTape = function(expressID, type, tape) {
    let Units
    Units = []
    let Units_index = 0
    while (Units_index < tape[0].length) {
      Units.push(ParseType(tape[0][Units_index++], tape[0][Units_index++][0]))
    }
    return new IfcUnitAssignment(expressID, type, Units)
  }
  IfcUnitAssignment.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcUnitAssignment
}())
exports.IfcUnitAssignment = IfcUnitAssignment

var IfcUnitaryControlElement = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcUnitaryControlElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcUnitaryControlElementTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcUnitaryControlElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcUnitaryControlElement
}())
exports.IfcUnitaryControlElement = IfcUnitaryControlElement

var IfcUnitaryControlElementType = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcUnitaryControlElementType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcUnitaryControlElementTypeEnum(tape[9])
    return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcUnitaryControlElementType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcUnitaryControlElementType
}())
exports.IfcUnitaryControlElementType = IfcUnitaryControlElementType

var IfcUnitaryEquipment = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcUnitaryEquipment.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcUnitaryEquipmentTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcUnitaryEquipment.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcUnitaryEquipment
}())
exports.IfcUnitaryEquipment = IfcUnitaryEquipment

var IfcUnitaryEquipmentType = /** @class */ (function() {
  /**
   *
   */
  function IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcUnitaryEquipmentType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcUnitaryEquipmentTypeEnum(tape[9])
    return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcUnitaryEquipmentType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcUnitaryEquipmentType
}())
exports.IfcUnitaryEquipmentType = IfcUnitaryEquipmentType

var IfcValve = /** @class */ (function() {
  /**
   *
   */
  function IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcValve.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcValveTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcValve.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcValve
}())
exports.IfcValve = IfcValve

var IfcValveType = /** @class */ (function() {
  /**
   *
   */
  function IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcValveType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcValveTypeEnum(tape[9])
    return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcValveType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcValveType
}())
exports.IfcValveType = IfcValveType

var IfcVector = /** @class */ (function() {
  /**
   *
   */
  function IfcVector(expressID, type, Orientation, Magnitude) {
    this.expressID = expressID
    this.type = type
    this.Orientation = Orientation
    this.Magnitude = Magnitude
  }
  IfcVector.FromTape = function(expressID, type, tape) {
    let Orientation
    Orientation = tape[0]
    let Magnitude
    Magnitude = tape[1]
    return new IfcVector(expressID, type, Orientation, Magnitude)
  }
  IfcVector.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.Orientation)
    args.push(REAL)
    args.push(this.Magnitude)
    return args
  }
  return IfcVector
}())
exports.IfcVector = IfcVector

var IfcVertex = /** @class */ (function() {
  /**
   *
   */
  function IfcVertex(expressID, type) {
    this.expressID = expressID
    this.type = type
  }
  IfcVertex.FromTape = function(expressID, type, tape) {
    return new IfcVertex(expressID, type)
  }
  IfcVertex.prototype.ToTape = function() {
    const args = []
    return args
  }
  return IfcVertex
}())
exports.IfcVertex = IfcVertex

var IfcVertexLoop = /** @class */ (function() {
  /**
   *
   */
  function IfcVertexLoop(expressID, type, LoopVertex) {
    this.expressID = expressID
    this.type = type
    this.LoopVertex = LoopVertex
  }
  IfcVertexLoop.FromTape = function(expressID, type, tape) {
    let LoopVertex
    LoopVertex = tape[0]
    return new IfcVertexLoop(expressID, type, LoopVertex)
  }
  IfcVertexLoop.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.LoopVertex)
    return args
  }
  return IfcVertexLoop
}())
exports.IfcVertexLoop = IfcVertexLoop

var IfcVertexPoint = /** @class */ (function() {
  /**
   *
   */
  function IfcVertexPoint(expressID, type, VertexGeometry) {
    this.expressID = expressID
    this.type = type
    this.VertexGeometry = VertexGeometry
  }
  IfcVertexPoint.FromTape = function(expressID, type, tape) {
    let VertexGeometry
    VertexGeometry = tape[0]
    return new IfcVertexPoint(expressID, type, VertexGeometry)
  }
  IfcVertexPoint.prototype.ToTape = function() {
    const args = []
    args.push(REF)
    args.push(this.VertexGeometry)
    return args
  }
  return IfcVertexPoint
}())
exports.IfcVertexPoint = IfcVertexPoint

var IfcVibrationDamper = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcVibrationDamper.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcVibrationDamperTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcVibrationDamper.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcVibrationDamper
}())
exports.IfcVibrationDamper = IfcVibrationDamper

var IfcVibrationDamperType = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcVibrationDamperType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    if (tape[9]) {
      PredefinedType = new IfcVibrationDamperTypeEnum(tape[9])
    } else {
      PredefinedType = null
    }
    return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcVibrationDamperType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcVibrationDamperType
}())
exports.IfcVibrationDamperType = IfcVibrationDamperType

var IfcVibrationIsolator = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcVibrationIsolator.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcVibrationIsolatorTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcVibrationIsolator.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcVibrationIsolator
}())
exports.IfcVibrationIsolator = IfcVibrationIsolator

var IfcVibrationIsolatorType = /** @class */ (function() {
  /**
   *
   */
  function IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcVibrationIsolatorType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcVibrationIsolatorTypeEnum(tape[9])
    return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcVibrationIsolatorType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcVibrationIsolatorType
}())
exports.IfcVibrationIsolatorType = IfcVibrationIsolatorType

var IfcVirtualElement = /** @class */ (function() {
  /**
   *
   */
  function IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
  }
  IfcVirtualElement.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
  }
  IfcVirtualElement.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcVirtualElement
}())
exports.IfcVirtualElement = IfcVirtualElement

var IfcVirtualGridIntersection = /** @class */ (function() {
  /**
   *
   */
  function IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances) {
    this.expressID = expressID
    this.type = type
    this.IntersectingAxes = IntersectingAxes
    this.OffsetDistances = OffsetDistances
  }
  IfcVirtualGridIntersection.FromTape = function(expressID, type, tape) {
    let IntersectingAxes
    IntersectingAxes = []
    let IntersectingAxes_index = 0
    while (IntersectingAxes_index < tape[0].length) {
      IntersectingAxes.push(tape[0][IntersectingAxes_index++])
    }
    let OffsetDistances
    OffsetDistances = []
    let OffsetDistances_index = 0
    while (OffsetDistances_index < tape[1].length) {
      OffsetDistances.push(tape[1][OffsetDistances_index++])
    }
    return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances)
  }
  IfcVirtualGridIntersection.prototype.ToTape = function() {
    const args = []
    args.push(SET_BEGIN)
    this.IntersectingAxes.forEach(function(e) {
      args.push(REF); args.push(e)
    })
    args.push(SET_END)
    args.push(REAL)
    args.push.apply(args, this.OffsetDistances)
    return args
  }
  return IfcVirtualGridIntersection
}())
exports.IfcVirtualGridIntersection = IfcVirtualGridIntersection

var IfcVoidingFeature = /** @class */ (function() {
  /**
   *
   */
  function IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcVoidingFeature.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcVoidingFeatureTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcVoidingFeature.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcVoidingFeature
}())
exports.IfcVoidingFeature = IfcVoidingFeature

var IfcWall = /** @class */ (function() {
  /**
   *
   */
  function IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcWall.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcWallTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcWall.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWall
}())
exports.IfcWall = IfcWall

var IfcWallElementedCase = /** @class */ (function() {
  /**
   *
   */
  function IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcWallElementedCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcWallTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcWallElementedCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWallElementedCase
}())
exports.IfcWallElementedCase = IfcWallElementedCase

var IfcWallStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcWallStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcWallTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcWallStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWallStandardCase
}())
exports.IfcWallStandardCase = IfcWallStandardCase

var IfcWallType = /** @class */ (function() {
  /**
   *
   */
  function IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcWallType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcWallTypeEnum(tape[9])
    return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcWallType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcWallType
}())
exports.IfcWallType = IfcWallType

var IfcWasteTerminal = /** @class */ (function() {
  /**
   *
   */
  function IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.PredefinedType = PredefinedType
  }
  IfcWasteTerminal.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcWasteTerminalTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
  }
  IfcWasteTerminal.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWasteTerminal
}())
exports.IfcWasteTerminal = IfcWasteTerminal

var IfcWasteTerminalType = /** @class */ (function() {
  /**
   *
   */
  function IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
  }
  IfcWasteTerminalType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcWasteTerminalTypeEnum(tape[9])
    return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType)
  }
  IfcWasteTerminalType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    return args
  }
  return IfcWasteTerminalType
}())
exports.IfcWasteTerminalType = IfcWasteTerminalType

var IfcWindow = /** @class */ (function() {
  /**
   *
   */
  function IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.OverallHeight = OverallHeight
    this.OverallWidth = OverallWidth
    this.PredefinedType = PredefinedType
    this.PartitioningType = PartitioningType
    this.UserDefinedPartitioningType = UserDefinedPartitioningType
  }
  IfcWindow.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let OverallHeight
    if (tape[8]) {
      OverallHeight = tape[8]
    } else {
      OverallHeight = null
    }
    let OverallWidth
    if (tape[9]) {
      OverallWidth = tape[9]
    } else {
      OverallWidth = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcWindowTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    let PartitioningType
    if (tape[11]) {
      PartitioningType = new IfcWindowTypePartitioningEnum(tape[11])
    } else {
      PartitioningType = null
    }
    let UserDefinedPartitioningType
    if (tape[12]) {
      UserDefinedPartitioningType = tape[12]
    } else {
      UserDefinedPartitioningType = null
    }
    return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType)
  }
  IfcWindow.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.OverallHeight) {
    } else {
      args.push(EMPTY)
    }
    if (this.OverallWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PartitioningType) {
      args.push(ENUM)
      args.push(this.PartitioningType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPartitioningType) {
      args.push(STRING)
      args.push(this.UserDefinedPartitioningType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWindow
}())
exports.IfcWindow = IfcWindow

var IfcWindowLiningProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.LiningDepth = LiningDepth
    this.LiningThickness = LiningThickness
    this.TransomThickness = TransomThickness
    this.MullionThickness = MullionThickness
    this.FirstTransomOffset = FirstTransomOffset
    this.SecondTransomOffset = SecondTransomOffset
    this.FirstMullionOffset = FirstMullionOffset
    this.SecondMullionOffset = SecondMullionOffset
    this.ShapeAspectStyle = ShapeAspectStyle
    this.LiningOffset = LiningOffset
    this.LiningToPanelOffsetX = LiningToPanelOffsetX
    this.LiningToPanelOffsetY = LiningToPanelOffsetY
  }
  IfcWindowLiningProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let LiningDepth
    if (tape[4]) {
      LiningDepth = tape[4]
    } else {
      LiningDepth = null
    }
    let LiningThickness
    if (tape[5]) {
      LiningThickness = tape[5]
    } else {
      LiningThickness = null
    }
    let TransomThickness
    if (tape[6]) {
      TransomThickness = tape[6]
    } else {
      TransomThickness = null
    }
    let MullionThickness
    if (tape[7]) {
      MullionThickness = tape[7]
    } else {
      MullionThickness = null
    }
    let FirstTransomOffset
    if (tape[8]) {
      FirstTransomOffset = tape[8]
    } else {
      FirstTransomOffset = null
    }
    let SecondTransomOffset
    if (tape[9]) {
      SecondTransomOffset = tape[9]
    } else {
      SecondTransomOffset = null
    }
    let FirstMullionOffset
    if (tape[10]) {
      FirstMullionOffset = tape[10]
    } else {
      FirstMullionOffset = null
    }
    let SecondMullionOffset
    if (tape[11]) {
      SecondMullionOffset = tape[11]
    } else {
      SecondMullionOffset = null
    }
    let ShapeAspectStyle
    if (tape[12]) {
      ShapeAspectStyle = tape[12]
    } else {
      ShapeAspectStyle = null
    }
    let LiningOffset
    if (tape[13]) {
      LiningOffset = tape[13]
    } else {
      LiningOffset = null
    }
    let LiningToPanelOffsetX
    if (tape[14]) {
      LiningToPanelOffsetX = tape[14]
    } else {
      LiningToPanelOffsetX = null
    }
    let LiningToPanelOffsetY
    if (tape[15]) {
      LiningToPanelOffsetY = tape[15]
    } else {
      LiningToPanelOffsetY = null
    }
    return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY)
  }
  IfcWindowLiningProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.LiningThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.TransomThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.MullionThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.FirstTransomOffset) {
    } else {
      args.push(EMPTY)
    }
    if (this.SecondTransomOffset) {
    } else {
      args.push(EMPTY)
    }
    if (this.FirstMullionOffset) {
    } else {
      args.push(EMPTY)
    }
    if (this.SecondMullionOffset) {
    } else {
      args.push(EMPTY)
    }
    if (this.ShapeAspectStyle) {
      args.push(REF)
      args.push(this.ShapeAspectStyle)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningOffset) {
      args.push(REAL)
      args.push(this.LiningOffset)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningToPanelOffsetX) {
      args.push(REAL)
      args.push(this.LiningToPanelOffsetX)
    } else {
      args.push(EMPTY)
    }
    if (this.LiningToPanelOffsetY) {
      args.push(REAL)
      args.push(this.LiningToPanelOffsetY)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWindowLiningProperties
}())
exports.IfcWindowLiningProperties = IfcWindowLiningProperties

var IfcWindowPanelProperties = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.OperationType = OperationType
    this.PanelPosition = PanelPosition
    this.FrameDepth = FrameDepth
    this.FrameThickness = FrameThickness
    this.ShapeAspectStyle = ShapeAspectStyle
  }
  IfcWindowPanelProperties.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let OperationType
    OperationType = new IfcWindowPanelOperationEnum(tape[4])
    let PanelPosition
    PanelPosition = new IfcWindowPanelPositionEnum(tape[5])
    let FrameDepth
    if (tape[6]) {
      FrameDepth = tape[6]
    } else {
      FrameDepth = null
    }
    let FrameThickness
    if (tape[7]) {
      FrameThickness = tape[7]
    } else {
      FrameThickness = null
    }
    let ShapeAspectStyle
    if (tape[8]) {
      ShapeAspectStyle = tape[8]
    } else {
      ShapeAspectStyle = null
    }
    return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle)
  }
  IfcWindowPanelProperties.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.OperationType.value)
    args.push(ENUM)
    args.push(this.PanelPosition.value)
    if (this.FrameDepth) {
    } else {
      args.push(EMPTY)
    }
    if (this.FrameThickness) {
    } else {
      args.push(EMPTY)
    }
    if (this.ShapeAspectStyle) {
      args.push(REF)
      args.push(this.ShapeAspectStyle)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWindowPanelProperties
}())
exports.IfcWindowPanelProperties = IfcWindowPanelProperties

var IfcWindowStandardCase = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.ObjectPlacement = ObjectPlacement
    this.Representation = Representation
    this.Tag = Tag
    this.OverallHeight = OverallHeight
    this.OverallWidth = OverallWidth
    this.PredefinedType = PredefinedType
    this.PartitioningType = PartitioningType
    this.UserDefinedPartitioningType = UserDefinedPartitioningType
  }
  IfcWindowStandardCase.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let ObjectPlacement
    if (tape[5]) {
      ObjectPlacement = tape[5]
    } else {
      ObjectPlacement = null
    }
    let Representation
    if (tape[6]) {
      Representation = tape[6]
    } else {
      Representation = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let OverallHeight
    if (tape[8]) {
      OverallHeight = tape[8]
    } else {
      OverallHeight = null
    }
    let OverallWidth
    if (tape[9]) {
      OverallWidth = tape[9]
    } else {
      OverallWidth = null
    }
    let PredefinedType
    if (tape[10]) {
      PredefinedType = new IfcWindowTypeEnum(tape[10])
    } else {
      PredefinedType = null
    }
    let PartitioningType
    if (tape[11]) {
      PartitioningType = new IfcWindowTypePartitioningEnum(tape[11])
    } else {
      PartitioningType = null
    }
    let UserDefinedPartitioningType
    if (tape[12]) {
      UserDefinedPartitioningType = tape[12]
    } else {
      UserDefinedPartitioningType = null
    }
    return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType)
  }
  IfcWindowStandardCase.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectPlacement) {
      args.push(REF)
      args.push(this.ObjectPlacement)
    } else {
      args.push(EMPTY)
    }
    if (this.Representation) {
      args.push(REF)
      args.push(this.Representation)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.OverallHeight) {
    } else {
      args.push(EMPTY)
    }
    if (this.OverallWidth) {
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.PartitioningType) {
      args.push(ENUM)
      args.push(this.PartitioningType.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPartitioningType) {
      args.push(STRING)
      args.push(this.UserDefinedPartitioningType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWindowStandardCase
}())
exports.IfcWindowStandardCase = IfcWindowStandardCase

var IfcWindowStyle = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ConstructionType = ConstructionType
    this.OperationType = OperationType
    this.ParameterTakesPrecedence = ParameterTakesPrecedence
    this.Sizeable = Sizeable
  }
  IfcWindowStyle.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ConstructionType
    ConstructionType = new IfcWindowStyleConstructionEnum(tape[8])
    let OperationType
    OperationType = new IfcWindowStyleOperationEnum(tape[9])
    let ParameterTakesPrecedence
    ParameterTakesPrecedence = tape[10]
    let Sizeable
    Sizeable = tape[11]
    return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable)
  }
  IfcWindowStyle.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.ConstructionType.value)
    args.push(ENUM)
    args.push(this.OperationType.value)
    return args
  }
  return IfcWindowStyle
}())
exports.IfcWindowStyle = IfcWindowStyle

var IfcWindowType = /** @class */ (function() {
  /**
   *
   */
  function IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ApplicableOccurrence = ApplicableOccurrence
    this.HasPropertySets = HasPropertySets
    this.RepresentationMaps = RepresentationMaps
    this.Tag = Tag
    this.ElementType = ElementType
    this.PredefinedType = PredefinedType
    this.PartitioningType = PartitioningType
    this.ParameterTakesPrecedence = ParameterTakesPrecedence
    this.UserDefinedPartitioningType = UserDefinedPartitioningType
  }
  IfcWindowType.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ApplicableOccurrence
    if (tape[4]) {
      ApplicableOccurrence = tape[4]
    } else {
      ApplicableOccurrence = null
    }
    let HasPropertySets
    if (tape[5]) {
      HasPropertySets = []
      let HasPropertySets_index = 0
      while (HasPropertySets_index < tape[5].length) {
        HasPropertySets.push(tape[5][HasPropertySets_index++])
      }
    } else {
      HasPropertySets = null
    }
    let RepresentationMaps
    if (tape[6]) {
      RepresentationMaps = []
      let RepresentationMaps_index = 0
      while (RepresentationMaps_index < tape[6].length) {
        RepresentationMaps.push(tape[6][RepresentationMaps_index++])
      }
    } else {
      RepresentationMaps = null
    }
    let Tag
    if (tape[7]) {
      Tag = tape[7]
    } else {
      Tag = null
    }
    let ElementType
    if (tape[8]) {
      ElementType = tape[8]
    } else {
      ElementType = null
    }
    let PredefinedType
    PredefinedType = new IfcWindowTypeEnum(tape[9])
    let PartitioningType
    PartitioningType = new IfcWindowTypePartitioningEnum(tape[10])
    let ParameterTakesPrecedence
    if (tape[11]) {
      ParameterTakesPrecedence = tape[11]
    } else {
      ParameterTakesPrecedence = null
    }
    let UserDefinedPartitioningType
    if (tape[12]) {
      UserDefinedPartitioningType = tape[12]
    } else {
      UserDefinedPartitioningType = null
    }
    return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType)
  }
  IfcWindowType.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ApplicableOccurrence) {
      args.push(STRING)
      args.push(this.ApplicableOccurrence)
    } else {
      args.push(EMPTY)
    }
    if (this.HasPropertySets) {
      args.push(SET_BEGIN)
      this.HasPropertySets.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.RepresentationMaps) {
      args.push(SET_BEGIN)
      this.RepresentationMaps.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Tag) {
      args.push(STRING)
      args.push(this.Tag)
    } else {
      args.push(EMPTY)
    }
    if (this.ElementType) {
      args.push(STRING)
      args.push(this.ElementType)
    } else {
      args.push(EMPTY)
    }
    args.push(ENUM)
    args.push(this.PredefinedType.value)
    args.push(ENUM)
    args.push(this.PartitioningType.value)
    if (this.ParameterTakesPrecedence) {
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedPartitioningType) {
      args.push(STRING)
      args.push(this.UserDefinedPartitioningType)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWindowType
}())
exports.IfcWindowType = IfcWindowType

var IfcWorkCalendar = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.WorkingTimes = WorkingTimes
    this.ExceptionTimes = ExceptionTimes
    this.PredefinedType = PredefinedType
  }
  IfcWorkCalendar.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let WorkingTimes
    if (tape[6]) {
      WorkingTimes = []
      let WorkingTimes_index = 0
      while (WorkingTimes_index < tape[6].length) {
        WorkingTimes.push(tape[6][WorkingTimes_index++])
      }
    } else {
      WorkingTimes = null
    }
    let ExceptionTimes
    if (tape[7]) {
      ExceptionTimes = []
      let ExceptionTimes_index = 0
      while (ExceptionTimes_index < tape[7].length) {
        ExceptionTimes.push(tape[7][ExceptionTimes_index++])
      }
    } else {
      ExceptionTimes = null
    }
    let PredefinedType
    if (tape[8]) {
      PredefinedType = new IfcWorkCalendarTypeEnum(tape[8])
    } else {
      PredefinedType = null
    }
    return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType)
  }
  IfcWorkCalendar.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    if (this.WorkingTimes) {
      args.push(SET_BEGIN)
      this.WorkingTimes.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.ExceptionTimes) {
      args.push(SET_BEGIN)
      this.ExceptionTimes.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWorkCalendar
}())
exports.IfcWorkCalendar = IfcWorkCalendar

var IfcWorkControl = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.CreationDate = CreationDate
    this.Creators = Creators
    this.Purpose = Purpose
    this.Duration = Duration
    this.TotalFloat = TotalFloat
    this.StartTime = StartTime
    this.FinishTime = FinishTime
  }
  IfcWorkControl.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let CreationDate
    CreationDate = tape[6]
    let Creators
    if (tape[7]) {
      Creators = []
      let Creators_index = 0
      while (Creators_index < tape[7].length) {
        Creators.push(tape[7][Creators_index++])
      }
    } else {
      Creators = null
    }
    let Purpose
    if (tape[8]) {
      Purpose = tape[8]
    } else {
      Purpose = null
    }
    let Duration
    if (tape[9]) {
      Duration = tape[9]
    } else {
      Duration = null
    }
    let TotalFloat
    if (tape[10]) {
      TotalFloat = tape[10]
    } else {
      TotalFloat = null
    }
    let StartTime
    StartTime = tape[11]
    let FinishTime
    if (tape[12]) {
      FinishTime = tape[12]
    } else {
      FinishTime = null
    }
    return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
  }
  IfcWorkControl.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.CreationDate)
    if (this.Creators) {
      args.push(SET_BEGIN)
      this.Creators.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    if (this.Duration) {
      args.push(STRING)
      args.push(this.Duration)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalFloat) {
      args.push(STRING)
      args.push(this.TotalFloat)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    if (this.FinishTime) {
      args.push(STRING)
      args.push(this.FinishTime)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWorkControl
}())
exports.IfcWorkControl = IfcWorkControl

var IfcWorkPlan = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.CreationDate = CreationDate
    this.Creators = Creators
    this.Purpose = Purpose
    this.Duration = Duration
    this.TotalFloat = TotalFloat
    this.StartTime = StartTime
    this.FinishTime = FinishTime
    this.PredefinedType = PredefinedType
  }
  IfcWorkPlan.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let CreationDate
    CreationDate = tape[6]
    let Creators
    if (tape[7]) {
      Creators = []
      let Creators_index = 0
      while (Creators_index < tape[7].length) {
        Creators.push(tape[7][Creators_index++])
      }
    } else {
      Creators = null
    }
    let Purpose
    if (tape[8]) {
      Purpose = tape[8]
    } else {
      Purpose = null
    }
    let Duration
    if (tape[9]) {
      Duration = tape[9]
    } else {
      Duration = null
    }
    let TotalFloat
    if (tape[10]) {
      TotalFloat = tape[10]
    } else {
      TotalFloat = null
    }
    let StartTime
    StartTime = tape[11]
    let FinishTime
    if (tape[12]) {
      FinishTime = tape[12]
    } else {
      FinishTime = null
    }
    let PredefinedType
    if (tape[13]) {
      PredefinedType = new IfcWorkPlanTypeEnum(tape[13])
    } else {
      PredefinedType = null
    }
    return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType)
  }
  IfcWorkPlan.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.CreationDate)
    if (this.Creators) {
      args.push(SET_BEGIN)
      this.Creators.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    if (this.Duration) {
      args.push(STRING)
      args.push(this.Duration)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalFloat) {
      args.push(STRING)
      args.push(this.TotalFloat)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    if (this.FinishTime) {
      args.push(STRING)
      args.push(this.FinishTime)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWorkPlan
}())
exports.IfcWorkPlan = IfcWorkPlan

var IfcWorkSchedule = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.Identification = Identification
    this.CreationDate = CreationDate
    this.Creators = Creators
    this.Purpose = Purpose
    this.Duration = Duration
    this.TotalFloat = TotalFloat
    this.StartTime = StartTime
    this.FinishTime = FinishTime
    this.PredefinedType = PredefinedType
  }
  IfcWorkSchedule.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let Identification
    if (tape[5]) {
      Identification = tape[5]
    } else {
      Identification = null
    }
    let CreationDate
    CreationDate = tape[6]
    let Creators
    if (tape[7]) {
      Creators = []
      let Creators_index = 0
      while (Creators_index < tape[7].length) {
        Creators.push(tape[7][Creators_index++])
      }
    } else {
      Creators = null
    }
    let Purpose
    if (tape[8]) {
      Purpose = tape[8]
    } else {
      Purpose = null
    }
    let Duration
    if (tape[9]) {
      Duration = tape[9]
    } else {
      Duration = null
    }
    let TotalFloat
    if (tape[10]) {
      TotalFloat = tape[10]
    } else {
      TotalFloat = null
    }
    let StartTime
    StartTime = tape[11]
    let FinishTime
    if (tape[12]) {
      FinishTime = tape[12]
    } else {
      FinishTime = null
    }
    let PredefinedType
    if (tape[13]) {
      PredefinedType = new IfcWorkScheduleTypeEnum(tape[13])
    } else {
      PredefinedType = null
    }
    return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType)
  }
  IfcWorkSchedule.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.Identification) {
      args.push(STRING)
      args.push(this.Identification)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.CreationDate)
    if (this.Creators) {
      args.push(SET_BEGIN)
      this.Creators.forEach(function(e) {
        args.push(REF); args.push(e)
      })
      args.push(SET_END)
    } else {
      args.push(EMPTY)
    }
    if (this.Purpose) {
      args.push(STRING)
      args.push(this.Purpose)
    } else {
      args.push(EMPTY)
    }
    if (this.Duration) {
      args.push(STRING)
      args.push(this.Duration)
    } else {
      args.push(EMPTY)
    }
    if (this.TotalFloat) {
      args.push(STRING)
      args.push(this.TotalFloat)
    } else {
      args.push(EMPTY)
    }
    args.push(STRING)
    args.push(this.StartTime)
    if (this.FinishTime) {
      args.push(STRING)
      args.push(this.FinishTime)
    } else {
      args.push(EMPTY)
    }
    if (this.PredefinedType) {
      args.push(ENUM)
      args.push(this.PredefinedType.value)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWorkSchedule
}())
exports.IfcWorkSchedule = IfcWorkSchedule

var IfcWorkTime = /** @class */ (function() {
  /**
   *
   */
  function IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
    this.expressID = expressID
    this.type = type
    this.Name = Name
    this.DataOrigin = DataOrigin
    this.UserDefinedDataOrigin = UserDefinedDataOrigin
    this.RecurrencePattern = RecurrencePattern
    this.Start = Start
    this.Finish = Finish
  }
  IfcWorkTime.FromTape = function(expressID, type, tape) {
    let Name
    if (tape[0]) {
      Name = tape[0]
    } else {
      Name = null
    }
    let DataOrigin
    if (tape[1]) {
      DataOrigin = new IfcDataOriginEnum(tape[1])
    } else {
      DataOrigin = null
    }
    let UserDefinedDataOrigin
    if (tape[2]) {
      UserDefinedDataOrigin = tape[2]
    } else {
      UserDefinedDataOrigin = null
    }
    let RecurrencePattern
    if (tape[3]) {
      RecurrencePattern = tape[3]
    } else {
      RecurrencePattern = null
    }
    let Start
    if (tape[4]) {
      Start = tape[4]
    } else {
      Start = null
    }
    let Finish
    if (tape[5]) {
      Finish = tape[5]
    } else {
      Finish = null
    }
    return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish)
  }
  IfcWorkTime.prototype.ToTape = function() {
    const args = []
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.DataOrigin) {
      args.push(ENUM)
      args.push(this.DataOrigin.value)
    } else {
      args.push(EMPTY)
    }
    if (this.UserDefinedDataOrigin) {
      args.push(STRING)
      args.push(this.UserDefinedDataOrigin)
    } else {
      args.push(EMPTY)
    }
    if (this.RecurrencePattern) {
      args.push(REF)
      args.push(this.RecurrencePattern)
    } else {
      args.push(EMPTY)
    }
    if (this.Start) {
      args.push(STRING)
      args.push(this.Start)
    } else {
      args.push(EMPTY)
    }
    if (this.Finish) {
      args.push(STRING)
      args.push(this.Finish)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcWorkTime
}())
exports.IfcWorkTime = IfcWorkTime

var IfcZShapeProfileDef = /** @class */ (function() {
  /**
   *
   */
  function IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
    this.expressID = expressID
    this.type = type
    this.ProfileType = ProfileType
    this.ProfileName = ProfileName
    this.Position = Position
    this.Depth = Depth
    this.FlangeWidth = FlangeWidth
    this.WebThickness = WebThickness
    this.FlangeThickness = FlangeThickness
    this.FilletRadius = FilletRadius
    this.EdgeRadius = EdgeRadius
  }
  IfcZShapeProfileDef.FromTape = function(expressID, type, tape) {
    let ProfileType
    ProfileType = new IfcProfileTypeEnum(tape[0])
    let ProfileName
    if (tape[1]) {
      ProfileName = tape[1]
    } else {
      ProfileName = null
    }
    let Position
    if (tape[2]) {
      Position = tape[2]
    } else {
      Position = null
    }
    let Depth
    Depth = tape[3]
    let FlangeWidth
    FlangeWidth = tape[4]
    let WebThickness
    WebThickness = tape[5]
    let FlangeThickness
    FlangeThickness = tape[6]
    let FilletRadius
    if (tape[7]) {
      FilletRadius = tape[7]
    } else {
      FilletRadius = null
    }
    let EdgeRadius
    if (tape[8]) {
      EdgeRadius = tape[8]
    } else {
      EdgeRadius = null
    }
    return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius)
  }
  IfcZShapeProfileDef.prototype.ToTape = function() {
    const args = []
    args.push(ENUM)
    args.push(this.ProfileType.value)
    if (this.ProfileName) {
      args.push(STRING)
      args.push(this.ProfileName)
    } else {
      args.push(EMPTY)
    }
    if (this.Position) {
      args.push(REF)
      args.push(this.Position)
    } else {
      args.push(EMPTY)
    }
    if (this.FilletRadius) {
    } else {
      args.push(EMPTY)
    }
    if (this.EdgeRadius) {
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcZShapeProfileDef
}())
exports.IfcZShapeProfileDef = IfcZShapeProfileDef

var IfcZone = /** @class */ (function() {
  /**
   *
   */
  function IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
    this.expressID = expressID
    this.type = type
    this.GlobalId = GlobalId
    this.OwnerHistory = OwnerHistory
    this.Name = Name
    this.Description = Description
    this.ObjectType = ObjectType
    this.LongName = LongName
  }
  IfcZone.FromTape = function(expressID, type, tape) {
    let GlobalId
    GlobalId = tape[0]
    let OwnerHistory
    if (tape[1]) {
      OwnerHistory = tape[1]
    } else {
      OwnerHistory = null
    }
    let Name
    if (tape[2]) {
      Name = tape[2]
    } else {
      Name = null
    }
    let Description
    if (tape[3]) {
      Description = tape[3]
    } else {
      Description = null
    }
    let ObjectType
    if (tape[4]) {
      ObjectType = tape[4]
    } else {
      ObjectType = null
    }
    let LongName
    if (tape[5]) {
      LongName = tape[5]
    } else {
      LongName = null
    }
    return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName)
  }
  IfcZone.prototype.ToTape = function() {
    const args = []
    args.push(STRING)
    args.push(this.GlobalId)
    if (this.OwnerHistory) {
      args.push(REF)
      args.push(this.OwnerHistory)
    } else {
      args.push(EMPTY)
    }
    if (this.Name) {
      args.push(STRING)
      args.push(this.Name)
    } else {
      args.push(EMPTY)
    }
    if (this.Description) {
      args.push(STRING)
      args.push(this.Description)
    } else {
      args.push(EMPTY)
    }
    if (this.ObjectType) {
      args.push(STRING)
      args.push(this.ObjectType)
    } else {
      args.push(EMPTY)
    }
    if (this.LongName) {
      args.push(STRING)
      args.push(this.LongName)
    } else {
      args.push(EMPTY)
    }
    return args
  }
  return IfcZone
}())
exports.IfcZone = IfcZone

